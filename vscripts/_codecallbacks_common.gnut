untyped

global function CodeCallbacksCommon_Init

global function CodeCallback_DamageEntity
global function HandleFootstepDamage
global function CodeCallback_OnEntityKilled

global function AddDamageCallback
global function RemoveDamageCallback
global function RunClassDamageCallbacks
global function AddDamageFinalCallback
global function RunClassDamageFinalCallbacks
global function AddPostDamageCallback
global function RunClassPostDamageCallbacks

global function AddDamageByCallback
global function AddDamageCallbackSourceID
global function AddDeathCallback
global function RemoveDeathCallback
global function AddSoulDeathCallback
global function AddCallback_OnPlayerRespawned
global function AddCallback_OnPlayerKilled
global function AddCallback_OnNPCKilled
global function AddCallback_OnTitanDoomed
global function AddCallback_OnTitanHealthSegmentLost
global function AddCallback_OnClientConnecting
global function AddCallback_OnClientConnected
global function AddCallback_OnClientDisconnected
global function AddCallback_OnPilotBecomesTitan
global function AddCallback_OnTitanBecomesPilot
global function AddCallback_EntityChangedTeam
global function AddCallback_OnTouchHealthKit
global function AddCallback_OnPlayerAssist
global function AddCallback_OnPlayerGetsNewPilotLoadout
global function AddCallback_OnTitanGetsNewTitanLoadout
global function AddCallback_OnUpdateDerivedPilotLoadout
global function AddCallback_OnUpdateDerivedTitanLoadout
global function AddCallback_OnUpdateDerivedPlayerTitanLoadout
global function AddClientCommandCallback
global function AddPlayerDropScriptedItemsCallback
global function AddCallback_OnPlayerInventoryChanged

// r5 stuff
global function AddCallback_OnWeaponAttack

global function AddClientCommandCallbackNew
global function RemoveClientCommandCallbackNewFunc
global function ClientCommandCallbackNewExists
global function RemoveClientCommandCallback

global function AddCallback_OnPreClientDisconnected
global function AddCallback_OnDeathBoxSpawned
global function AddCallback_OnGetBestObserverTarget
global function AddCallback_GameStatePostEnter
global function AddCallback_OnThreatEventActivation
global function AddCallback_OnThreatEventStateChange

// Register functions are called when an entity spawns.
global function RegisterForDamageDeathCallbacks
global function CodeCallback_OnInventoryChanged
global function CodeCallback_OnEntityChangedTeam

global function AddEntityCallback_OnDamaged
global function EntityCallback_Exists
global function RemoveEntityCallback_OnDamaged
global function AddEntityCallback_OnPostDamaged
global function RemoveEntityCallback_OnPostDamaged
global function AddEntityCallback_OnKilled
global function RemoveEntityCallback_OnKilled
global function AddEntityCallback_OnPostShieldDamage
global function RemoveEntityCallback_OnPostShieldDamage

global function AddTitanCallback_OnHealthSegmentLost
global function RemoveTitanCallback_OnHealthSegmentLost

// Player movement callbacks
global function AddPlayerMovementEventCallback
global function RemovePlayerMovementEventCallback
global function CodeCallback_OnPlayerJump
global function CodeCallback_OnPlayerDoubleJump
global function CodeCallback_OnPlayerDodge
global function CodeCallback_OnPlayerLeaveGround
global function CodeCallback_OnPlayerTouchGround
global function CodeCallback_OnPlayerMantle
global function CodeCallback_OnPlayerBeginWallrun
global function CodeCallback_OnPlayerEndWallrun
global function CodeCallback_OnPlayerBeginWallhang
global function CodeCallback_OnPlayerEndWallhang
global function CodeCallback_OnClientConnectionCompleted 

global function CodeCallback_GetBestObserverTarget
global function CodeCallback_OnClientDisconnected
global function CodeCallback_OnWeaponAttack

global function CodeCallback_OnNavMeshHotSwapBegin
global function CodeCallback_OnNavMeshHotSwapEnd

global function SetDefaultObserverBehavior
global function CodeCallback_OnPlayerRespawned

const bool PRINT_MOVEMENT = false

#document("CodeCallback_OnClientConnectionCompleted", "Called when player finishes connecting to the server")
void function CodeCallback_OnClientConnectionCompleted( entity player )
{
	#if TRACKER && HAS_TRACKER_DLL //TODO(dw): server messages
		if( IsBotEnt( player ) )
			return
	#endif
		
	player.p.activeGladiatorCardStatTrackerEntries = [0,0,0]
	player.s.activeTrapArrayId <- CreateScriptManagedEntArray()

	ShGRX_OnClientConnectionCompleted( player )

	if ( !DEV_ShouldIgnorePersistence() )
	{
		SvPersistentData_OnClientConnectionCompleted( player )
		ShEHI_OnClientConnectionCompleted( player )
	}

	ZiplineInit( player )

	player.hasConnected = true

	foreach ( cb in svGlobal.onClientConnectedCallbacks )	
		cb( player )

	NotifyClientsOfConnection( player, 1 )

	// shouldn't this be called from code?
	CodeCallback_OnClientReloadConnectionCompleted( player )
	
	if( GetCurrentPlaylistVarBool( "flowstate_give_random_custom_models_toall", false ) )
		player.p.assignedCustomModel = RandomIntRangeInclusive(1,10)
	
	if( Gamemode() == eGamemodes.fs_snd )
		_OnPlayerConnectedSND( player )
	else if( Gamemode() == eGamemodes.SURVIVAL && (Playlist() != ePlaylists.survival_dev && Playlist() != ePlaylists.dev_default && !GetCurrentPlaylistVarBool( "is_practice_map", false ) && Playlist() != ePlaylists.fs_movementrecorder) )
	{
		DecideRespawnPlayer_Retail( player )
	}
}

void function CodeCallback_OnPlayerRespawned( entity player )
{
	#if DEVELOPER
	Warning( "CodeCallback_OnPlayerRespawned", player )
	#endif

	Assert( !IsPlayerEliminated( player ), "An eliminated player respawned." )

	Remote_CallFunction_NonReplay( player, "ServerCallback_YouRespawned" )

	SetHumanRagdollImpactTable( player )

	player.p.respawnCount++
	// player.s.respawnTime = Time()
	ClearRecentDamageHistory( player )
	// ClearRespawnAvailable( player )

	player.p.killerToSpectate = null
	player.p.playerToTimeThatAssistCreditLastsTable.clear()
	
	player.kv.renderColor = "255 255 255 255"
	player.kv.renderAmt = 255
	player.Show()

	player.Signal( "OnRespawned" )

	// Added via AddCallback_OnPlayerRespawned
	foreach ( callbackFunc in svGlobal.onPlayerRespawnedCallbacks )
	{
		callbackFunc( player )
	}

	// // Added via AddCallback_OnPlayerPostRespawned
	// foreach ( callbackFunc in svGlobal.onPlayerPostRespawnedCallbacks )
	// {
		// callbackFunc( player )
	// }

	// foreach ( func in player.p.playerSpawnedCallbacks )
	// {
		// func( player )
	// }

	player.e.lastAttacker = null
	player.e.canBurn = true
	player.e.canBeDamagedFromGas = true

	thread PlayerLifeThread( player )
}

void function PlayerLifeThread( entity player )
{
	RegisterSignal( "OnPostDeathLogicEnd" )
	
	// this thread will run for the span of the player's life plus a little bit extra
	// (the extra is the time after they die before they're moved to spectator)

	EndSignal( player, "OnDestroy" )
	EndSignal( player, "OnRespawned" )
	EndSignal( player, "OnPostDeathLogicEnd" )
	EndSignal( player, "StopPostDeathLogic" )

	LoadoutEntry characterSlot = Loadout_CharacterClass()

	OnThreadEnd( void function() : ( player, characterSlot ) {
		if ( IsValid( player ) )
		{
			RemoveCallback_ItemFlavorLoadoutSlotDidChange_SpecificPlayer( player, characterSlot, BeginPlayerCharacterThread )
			Signal( player, "HaltPlayerCharacterThread" )
		}
	} )

	AddCallback_ItemFlavorLoadoutSlotDidChange_SpecificPlayer( player, characterSlot, BeginPlayerCharacterThread )

	Assert( LoadoutSlot_IsReady( player, characterSlot ), "Tried to spawn a player but their character selection was somehow empty." )

	ItemFlavor character = LoadoutSlot_GetItemFlavor( player, characterSlot )
	BeginPlayerCharacterThread( player, character )

	WaitForever()
}


void function BeginPlayerCharacterThread( entity player, ItemFlavor character )
{
	thread PlayerCharacterThread( player, character )
}


void function PlayerCharacterThread( entity player, ItemFlavor character )
{
	// this thread will run for the span of the player being a specific character
	// if the character is null, it means they currently don't have a character
	Signal( player, "HaltPlayerCharacterThread" )
	EndSignal( player, "HaltPlayerCharacterThread" )

	LoadoutEntry skinSlot = Loadout_CharacterSkin( character )

	OnThreadEnd( void function() : ( player, character, skinSlot ) {
		if ( IsValid( player ) )
		{
			RemoveCallback_ItemFlavorLoadoutSlotDidChange_SpecificPlayer( player, skinSlot, ApplyPlayerCharacterSkin )
		}

		//foreach( void functionref( entity, ItemFlavor ) cb in file.onPlayerCharacterShutdownCallbacks )
		//	cb( player, character )
	} )

	// apply chosen skin
	ItemFlavor skin = LoadoutSlot_GetItemFlavor( player, skinSlot )
	ApplyPlayerCharacterSkin( player, skin )
	// and keep it up to date
	AddCallback_ItemFlavorLoadoutSlotDidChange_SpecificPlayer( player, skinSlot, ApplyPlayerCharacterSkin )

	// if we have a character, apply settings
	// todo(dw): make this get done here
	//asset setFile = CharacterClass_GetSetFile( character )
	//array<string> existingMods = player.GetPlayerSettingsMods()
	//player.SetPlayerSettingsWithMods( setFile, existingMods )

	//foreach( void functionref( entity, ItemFlavor ) cb in file.onPlayerCharacterSetupCallbacks )
	//	cb( player, character )

	WaitForever()
}

void function ApplyPlayerCharacterSkin( entity player, ItemFlavor skin )
{
	//see Declan as to why this needed to change from CharacterSkin_Apply()
	// ApplyAppropriateCharacterSkin( player )
	
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )

	if ( !LoadoutSlot_IsReady( ToEHI( player ), Loadout_CharacterSkin( character ) ) )
		return
		
	CharacterSkin_Apply( player, skin )
}

/*{
"725342087": "Bangalore",
"898565421": "Bloodhound",
"1111853120": "Caustic",
"80232848": "Crypto",
"182221730": "Gibraltar",
"1409694078": "Lifeline",
"2045656322": "Mirage",
"843405508": "Octane",
"1464849662": "Pathfinder",
"187386164": "Wattson",
"827049897": "Wraith",
}*/

void function DEV_PDataInitForPlayer( entity player )
{
	//player.SetPersistentVar( "loadouts.character_selection", 827049897 )

	array< ItemFlavor > characters = GetAllCharacters()
	foreach ( ItemFlavor character in characters )
	{
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].execution", 0)
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].intro_quip", 0 )
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].meleeskin", 0 )
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].skin", 1644844869 )
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].gcard_badge_0", 0 )
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].gcard_badge_0_tier", 0 )
		player.SetPersistentVar( "character_loadouts[" + ItemFlavor_GetGUIDString( character ) + "].gcard_badge_1", 97219464 )
	}
}

struct
{
	table<string, array< void functionref( entity, var ) > > classDamageCallbacks
	table<string, array< void functionref( entity, var ) > > classDamageFinalCallbacks
	table<string, array< void functionref( entity, var ) > > classPostDamageCallbacks
	array< void functionref( entity ) > playerInventoryChangedCallbacks
	entity functionref( entity observer, bool reverse )        defaultObserverBehavior
} file

struct 
{
	bool flowstate_spectator_team_only
} settings


void function CodeCallbacksCommon_Init()
{
	settings.flowstate_spectator_team_only = GetCurrentPlaylistVarBool( "flowstate_spectator_team_only", false )
}

entity function CodeCallback_GetBestObserverTarget( entity observer, bool reverse )
{
	foreach ( func in svGlobal.onGetBestObserverTargetCallbacks )
	{
		entity ent = func( observer, reverse )
		if ( ent != null )
		{
			if ( IsPrivateMatch() && observer.GetTeam() == TEAM_SPECTATOR )
			{
				if ( ent.IsPlayer() )
					printf( "Observer: User %s switched to spectating %s", observer.GetPINNucleusPid(), ent.GetPINNucleusPid() )
			}

			return ent
		}
	}

	if ( file.defaultObserverBehavior != null )
	{
		entity defaultEnt = file.defaultObserverBehavior( observer, reverse )

		if ( IsPrivateMatch() && defaultEnt != null && observer.GetTeam() == TEAM_SPECTATOR )
		{
			if ( defaultEnt.IsPlayer() )
				printf( "Observer: User %s switched to spectating %s", observer.GetPINNucleusPid(), defaultEnt.GetPINNucleusPid() )
		}

		return defaultEnt
	}

	return null
}


void function SetDefaultObserverBehavior( entity functionref( entity, bool ) func )
{
	file.defaultObserverBehavior = func
}

void function CodeCallback_DamageEntity( entity ent, var damageInfo )
{
	// gametype script decides if ent should take damage
	if ( !ScriptCallback_ShouldEntTakeDamage( ent, damageInfo ) )
	{
		DamageInfo_SetDamage( damageInfo, 0 )
		return
	}

	// if inflictor is trigger_hurt, set the identifier according to ent keyvalue
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == eDamageSourceId.invalid 
			&& inflictor != null 
			&& inflictor.GetClassName() == "trigger_hurt" 
			&& inflictor.HasKey( "damageSourceName" ) )
		DamageInfo_SetDamageSourceIdentifier( damageInfo, eDamageSourceId[expect string( inflictor.kv.damageSourceName )] )

	#if VERBOSE_DAMAGE_PRINTOUTS
		printt( "CodeCallback_DamageEntity() top:", DamageInfo_GetDamage( damageInfo ) )
	#endif

	// if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == damagedef_titan_step )
		// HandleFootstepDamage( ent, damageInfo )

	RunClassDamageCallbacks( ent, damageInfo )
	#if VERBOSE_DAMAGE_PRINTOUTS
		printt( "    after class damage callbacks:", DamageInfo_GetDamage( damageInfo ) )
	#endif

	// Added via AddEntityCallback_OnDamaged
	foreach ( callbackFunc in ent.e.entDamageCallbacks )
		callbackFunc( ent, damageInfo )
		
	#if VERBOSE_DAMAGE_PRINTOUTS
		printt( "    after AddEntityCallback_OnDamaged() callbacks:", DamageInfo_GetDamage( damageInfo ) )
	#endif

	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	if ( damageSourceId in shGlobal.damageSourceIdCallbacks )
	{
		foreach ( callbackFunc in shGlobal.damageSourceIdCallbacks[ damageSourceId ] )
			callbackFunc( ent, damageInfo )
	}
	#if VERBOSE_DAMAGE_PRINTOUTS
		printt( "    after damageSourceId callbacks:", DamageInfo_GetDamage( damageInfo ) )
	#endif

	RunClassDamageFinalCallbacks( ent, damageInfo )
	#if VERBOSE_DAMAGE_PRINTOUTS
		printt( "    after class damage final callbacks:", DamageInfo_GetDamage( damageInfo ) )
	#endif

	// make destructible vehicles take more damage from DF_EXPLOSION damage type
	if ( "isDestructibleVehicle" in ent.s && DamageInfo_GetCustomDamageType( damageInfo ) & DF_EXPLOSION )
	{
		DamageInfo_ScaleDamage( damageInfo, 2.0 )
	}

	if ( ent.GetShieldHealth() > 0 )
	{
		DamageInfo_AddCustomDamageType( damageInfo, DF_SHIELD_DAMAGE )
		ShieldModifyDamage( ent, damageInfo )
	}
	
	// Added via AddEntityCallback_OnPostDamaged
	foreach ( callbackFunc in ent.e.entPostDamageCallbacks )
	{
		callbackFunc( ent, damageInfo )
	}

	#if VERBOSE_DAMAGE_PRINTOUTS
		printt( "CodeCallback_DamageEntity() bottom:", DamageInfo_GetDamage( damageInfo ) )
	#endif

	if ( DamageInfo_GetDamage( damageInfo ) == 0 )
		return

	UpdateLastDamageTime( ent )

	//flinch was removed s22 apex legends
	//AddFlinch( ent, damageInfo )

	UpdateAttackerInfo( ent, DamageInfo_GetAttacker( damageInfo ), DamageInfo_GetDamage( damageInfo ) )
}

void function CodeCallback_OnWeaponAttack( entity player, entity weapon, string weaponName, int ammoUsed, vector origin, vector dir )
{
	foreach ( callbackFunc in svGlobal.onWeaponAttackCallbacks )
		callbackFunc( player, weapon, weaponName, ammoUsed, origin, dir )
}

void function CodeCallback_OnNavMeshHotSwapBegin()
{
	//printf("CodeCallback_OnNavMeshHotSwapBegin()")
}

void function CodeCallback_OnNavMeshHotSwapEnd()
{
	//printf("CodeCallback_OnNavMeshHotSwapEnd()")
}

bool function TrySpectreVirus( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsSpectre( victim ) )
		return false

	if ( !IsAlive( attacker ) )
		return false

	if ( !attacker.IsTitan() )
		return false

	if ( !attacker.IsPlayer() )
		return false

	if ( !PlayerHasPassive( attacker, ePassives.PAS_WIFI_SPECTRE ) )
		return false

	thread LeechPropagate( victim, attacker )
	return true
}


void function HandleFootstepDamage( entity victim, var damageInfo )
{
	if ( TrySpectreVirus( victim, damageInfo ) )
	{
		DamageInfo_SetDamage( damageInfo, 0 )
		return
	}
}

void function CodeCallback_OnEntityKilled( entity ent, var damageInfo )
{
	// npcs and player do death package in their own killed callbacks which are always called (even if deathNotifications is false)
	if ( !ent.IsNPC() && !ent.IsPlayer() )
		HandleDeathPackage( ent, damageInfo )

	string className = ent.GetClassName()
	if ( className in shGlobal.deathCallbacks )
	{
		foreach ( callbackFunc in shGlobal.deathCallbacks[className] )
		{
			callbackFunc( ent, damageInfo )
		}
	}


	// Added via AddEntityCallback_OnKilled
	foreach ( callbackFunc in ent.e.entKilledCallbacks )
	{
		callbackFunc( ent, damageInfo )
	}

	SendEntityKilledEvent( ent, damageInfo )
}


void function SendEntityKilledEvent( entity ent, var damageInfo )
{
	array<entity> players = GetPlayerArray()

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	// trigger_hurt is no longer networked, so the "attacker" fails to display obituaries
	if ( attacker )
	{
		string attackerClassname = attacker.GetClassName()

		if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" || attackerClassname == "crossbow_bolt" )
			attacker = GetEntByIndex( 0 ) // worldspawn
	}

	int attackerEHandle = attacker ? attacker.GetEncodedEHandle() : -1

	int victimEHandle = ent.GetEncodedEHandle()
	int scriptDamageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( scriptDamageType & DF_VORTEX_REFIRE )
		damageSourceId = eDamageSourceId.mp_titanweapon_vortex_shield

	if ( IsValidHeadShot( damageInfo, ent ) )
		scriptDamageType = scriptDamageType | DF_HEADSHOT
	else
		scriptDamageType = scriptDamageType & (~DF_HEADSHOT)

	foreach ( player in players )
	{
		if( is3v3Mode() && ent.IsPlayer() && !ent.DoesShareRealms( player ) )
			continue

		Remote_CallFunction_NonReplay( player, "ServerCallback_OnEntityKilled", attacker, ent, scriptDamageType, damageSourceId )
	}
}

//=====================================================================================
// Utility functions
//=====================================================================================

void function AddDamageCallback( string className, void functionref( entity, var ) callbackFunc )
{
	if ( !( className in file.classDamageCallbacks ) )
		file.classDamageCallbacks[className] <- []

	file.classDamageCallbacks[className].append( callbackFunc )
}

void function RemoveDamageCallback( string className, void functionref( entity, var ) callbackFunc )
{
	Assert( className in file.classDamageCallbacks, "Tried to remove damage callback that isn't added" )
	Assert( file.classDamageCallbacks[className].contains( callbackFunc ), "Tried to remove damage callback that isn't added" )
	file.classDamageCallbacks[className].fastremovebyvalue( callbackFunc )
}

void function RunClassDamageCallbacks( entity ent, var damageInfo )
{
	string className = ent.GetClassName()
	if ( !( className in file.classDamageCallbacks ) )
		return

	foreach ( callbackFunc in file.classDamageCallbacks[className] )
	{
		callbackFunc( ent, damageInfo )
		if ( DamageInfo_GetDamage( damageInfo ) == 0 )
			return
	}
}

void function AddDamageFinalCallback( string className, void functionref( entity, var ) callbackFunc )
{
	if ( !( className in file.classDamageFinalCallbacks ) )
		file.classDamageFinalCallbacks[className] <- []

	file.classDamageFinalCallbacks[className].append( callbackFunc )
}

void function RunClassDamageFinalCallbacks( entity ent, var damageInfo )
{
	string className = ent.GetClassName()
	if ( !( className in file.classDamageFinalCallbacks ) )
		return

	foreach ( callbackFunc in file.classDamageFinalCallbacks[className] )
	{
		if ( DamageInfo_GetDamage( damageInfo ) == 0 )
			return
		callbackFunc( ent, damageInfo )
	}
}


void function AddPostDamageCallback( string className, void functionref( entity, var ) callbackFunc )
{
	if ( !( className in file.classPostDamageCallbacks ) )
		file.classPostDamageCallbacks[className] <- []

	file.classPostDamageCallbacks[className].append( callbackFunc )
}

void function RunClassPostDamageCallbacks( entity ent, var damageInfo )
{
	string className = ent.GetClassName()
	if ( !( className in file.classPostDamageCallbacks ) )
		return

	foreach ( callbackFunc in file.classPostDamageCallbacks[className] )
	{
		#if DEVELOPER
			float damage = DamageInfo_GetDamage( damageInfo )
		#endif
		
		callbackFunc( ent, damageInfo )

		#if DEVELOPER
			mAssert( damage == DamageInfo_GetDamage( damageInfo ), "Damage changed in a post damage callback" )
		#endif
	}
}

void function AddDamageByCallback( string className, void functionref( entity, var ) callbackFunc )
{
	if ( !( className in svGlobal.damageByCallbacks ) )
		svGlobal.damageByCallbacks[className] <- []

	svGlobal.damageByCallbacks[className].append( callbackFunc )
}

void function AddDamageCallbackSourceID( int id, void functionref(entity, var) callbackFunc )
{
	if ( !( id in shGlobal.damageSourceIdCallbacks ) )
		shGlobal.damageSourceIdCallbacks[id] <- []

	shGlobal.damageSourceIdCallbacks[id].append( callbackFunc )
}

void function AddDeathCallback( string className, void functionref( entity, var ) callbackFunc )
{
	if ( !( className in shGlobal.deathCallbacks ) )
		shGlobal.deathCallbacks[className] <- []

	shGlobal.deathCallbacks[className].append( callbackFunc )
}

void function RemoveDeathCallback( string className, void functionref( entity, var ) callbackFunc )
{
	Assert( className in shGlobal.deathCallbacks, "Tried to remove death callback that isn't added" )
	Assert( shGlobal.deathCallbacks[className].contains( callbackFunc ), "Tried to remove death callback that isn't added" )
	shGlobal.deathCallbacks[className].fastremovebyvalue( callbackFunc )
}

void function AddSoulDeathCallback( void functionref( entity, var ) callbackFunc )
{
	#if DEVELOPER
	foreach ( func in svGlobal.soulDeathFuncs )
	{
		Assert( func != callbackFunc , "Already added " + string( callbackFunc ) + " with AddSoulDeathCallback" )
	}
	#endif

	svGlobal.soulDeathFuncs.append( callbackFunc )
}

void function AddCallback_OnTouchHealthKit( string className, bool functionref( entity player, entity healthpack ) callbackFunc )
{
	if ( ! (className in svGlobal.onTouchHealthKitCallbacks ) )
	{
		svGlobal.onTouchHealthKitCallbacks[ className ] <- [ callbackFunc ]
		return
	}
	else
	{
		Assert( !svGlobal.onTouchHealthKitCallbacks[className].contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnTouchHealthKit to class " + className )
		svGlobal.onTouchHealthKitCallbacks[className].append( callbackFunc )
	}
}

void function AddCallback_OnPlayerRespawned( void functionref( entity ) callbackFunc )
{
	Assert( !svGlobal.onPlayerRespawnedCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPlayerRespawned" )
	svGlobal.onPlayerRespawnedCallbacks.append( callbackFunc )
}

void function AddCallback_OnPlayerKilled( void functionref( entity victim, entity attacker, var damageInfo ) callbackFunc )
{
	Assert( !svGlobal.onPlayerKilledCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPlayerKilled" )
	svGlobal.onPlayerKilledCallbacks.append( callbackFunc )
}

void function AddCallback_OnNPCKilled( void functionref( entity victim, entity attacker, var damageInfo ) callbackFunc )
{
	Assert( !svGlobal.onNPCKilledCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPlayerKilled" )
	svGlobal.onNPCKilledCallbacks.append( callbackFunc )
}

void function AddCallback_OnTitanDoomed( void functionref( entity victim, var damageInfo ) callbackFunc )
{
	Assert( !svGlobal.onTitanDoomedCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnTitanDoomed" )
	svGlobal.onTitanDoomedCallbacks.append( callbackFunc )
}

void function AddCallback_OnTitanHealthSegmentLost( void functionref( entity victim, entity attacker ) callbackFunc )
{
	Assert( !svGlobal.onTitanHealthSegmentLostCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnTitanHealthSegmentLost" )
	svGlobal.onTitanHealthSegmentLostCallbacks.append( callbackFunc )
}

void function AddCallback_OnClientConnecting( void functionref( entity player ) callbackFunc )
{
	Assert( !svGlobal.onClientConnectingCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnClientConnecting" )
	svGlobal.onClientConnectingCallbacks.append( callbackFunc )
}

void function AddCallback_OnClientConnected( void functionref( entity player ) callbackFunc )
{
	Assert( !svGlobal.onClientConnectedCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnClientConnected" )
	svGlobal.onClientConnectedCallbacks.append( callbackFunc )
}

void function AddCallback_OnClientDisconnected( void functionref( entity player ) callbackFunc )
{
	Assert( !svGlobal.onClientDisconnectedCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnClientDisconnected" )
	svGlobal.onClientDisconnectedCallbacks.append( callbackFunc )
}

void function AddCallback_OnPilotBecomesTitan( void functionref( entity pilot, entity npc_titan ) callbackFunc )
{
	Assert( !svGlobal.onPilotBecomesTitanCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPilotBecomesTitan" )
	svGlobal.onPilotBecomesTitanCallbacks.append( callbackFunc )
}

void function AddCallback_OnTitanBecomesPilot( void functionref( entity pilot, entity npc_titan ) callbackFunc )
{
	Assert( !svGlobal.onTitanBecomesPilotCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnTitanBecomesPilot" )
	svGlobal.onTitanBecomesPilotCallbacks.append( callbackFunc )
}

void function AddCallback_OnPlayerAssist( void functionref( entity attacker, entity victim ) callbackFunc )
{
	Assert( !svGlobal.onPlayerAssistCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPlayerAssist" )
	svGlobal.onPlayerAssistCallbacks.append( callbackFunc )
}

void function AddCallback_EntityChangedTeam( string className, void functionref( entity ent ) callbackFunc )
{
	if ( !( className in svGlobal.onEntityChangedTeamCallbacks ) )
	{
		svGlobal.onEntityChangedTeamCallbacks[ className ] <- [ callbackFunc ]
		return
	}
	else
	{
		Assert( !svGlobal.onEntityChangedTeamCallbacks[ className ].contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_EntityChangedTeam" )
		svGlobal.onEntityChangedTeamCallbacks[ className ].append( callbackFunc )
	}
}

void function AddCallback_OnTitanGetsNewTitanLoadout( void functionref( entity titan, TitanLoadoutDef newTitanLoadout ) callbackFunc )
{
	Assert( !svGlobal.onTitanGetsNewLoadoutCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnTitanGetsNewTitanLoadout" )
	svGlobal.onTitanGetsNewLoadoutCallbacks.append( callbackFunc )
}

void function AddCallback_OnPlayerGetsNewPilotLoadout( void functionref( entity player, PilotLoadoutDef newTitanLoadout ) callbackFunc )
{
	Assert( !svGlobal.onPlayerGetsNewPilotLoadoutCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPlayerGetsNewPilotLoadout" )
	svGlobal.onPlayerGetsNewPilotLoadoutCallbacks.append( callbackFunc )
}

void function AddCallback_OnUpdateDerivedTitanLoadout( void functionref( TitanLoadoutDef newTitanLoadout ) callbackFunc )
{
	Assert( !svGlobal.onUpdateDerivedTitanLoadoutCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnUpdateDerivedTitanLoadout" )
	svGlobal.onUpdateDerivedTitanLoadoutCallbacks.append( callbackFunc )
}

void function AddCallback_OnUpdateDerivedPlayerTitanLoadout( void functionref( entity player, TitanLoadoutDef newTitanLoadout ) callbackFunc )
{
	Assert( !svGlobal.onUpdateDerivedPlayerTitanLoadoutCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnUpdateDerivedTitanLoadout" )
	svGlobal.onUpdateDerivedPlayerTitanLoadoutCallbacks.append( callbackFunc )
}

void function AddCallback_OnUpdateDerivedPilotLoadout( void functionref( PilotLoadoutDef newPilotLoadout ) callbackFunc )
{
	Assert( !svGlobal.onUpdateDerivedPilotLoadoutCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnUpdateDerivedPilotLoadout" )
	svGlobal.onUpdateDerivedPilotLoadoutCallbacks.append( callbackFunc )
}

void function AddClientCommandCallback( string commandString, bool functionref( entity player, array<string> args ) callbackFunc )
{
	Assert( !( commandString in svGlobal.clientCommandCallbacks ), "Already added " + commandString + " with AddClientCommandCallback" )
	svGlobal.clientCommandCallbacks[ commandString ] <- callbackFunc
}

void function AddPlayerDropScriptedItemsCallback( void functionref(entity player) callbackFunc )
{
	Assert( !( svGlobal.onPlayerDropsScriptedItemsCallbacks.contains( callbackFunc ) ), "Already added " + string( callbackFunc ) + " with AddPlayerDropScriptedItemsCallback" )
	svGlobal.onPlayerDropsScriptedItemsCallbacks.append( callbackFunc )
}

void function AddCallback_OnWeaponAttack( void functionref( entity, entity, string, int, vector, vector ) callbackFunc )
{
	Assert( !svGlobal.onWeaponAttackCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnWeaponAttack" )
	svGlobal.onWeaponAttackCallbacks.append( callbackFunc )
}

void function AddClientCommandCallbackNew( string commandString, void functionref( entity player, array<string> args ) callbackFunc )
{
	//mkos - modified to support multiple functions for a single command
	//Warning("AddClientCommandCallbackNew: " + commandString )
	
	if( commandString in svGlobal.clientCommandCallbacksNew )
	{
		mAssert( !(svGlobal.clientCommandCallbacksNew[ commandString ].contains( callbackFunc )), "Already added " + string( callbackFunc ) + "()" + " with " + FUNC_NAME() + "()" )
		svGlobal.clientCommandCallbacksNew[ commandString ].append( callbackFunc )
	}
	else 
	{
		svGlobal.clientCommandCallbacksNew[ commandString ] <- [ callbackFunc ]
	}
}

bool function ClientCommandCallbackNewExists( string commandString )
{
	return ( commandString in svGlobal.clientCommandCallbacksNew )
}

void function RemoveClientCommandCallback( string commandString, bool newOnly = false )
{
	bool found = false
	
	if ( commandString in svGlobal.clientCommandCallbacksNew )
	{
		found = true
		delete svGlobal.clientCommandCallbacksNew[ commandString ]
	}
	
	if( !newOnly && commandString in svGlobal.clientCommandCallbacks )
	{
		found = true
		delete svGlobal.clientCommandCallbacks[ commandString ]
	}
	
	if( !found )
	{
		string callbackStruct = newOnly ? "clientCommandCallbacksNew" : "any clientcommand callbacks";
		printf( "Tried to remove client command with [ %s() ] but command [ %s ] does not exist in %s", FUNC_NAME(), commandString, callbackStruct )
	}
}

void function RemoveClientCommandCallbackNewFunc( string commandString ,void functionref( entity player, array<string> args ) callbackFunc )
{
	if( commandString in svGlobal.clientCommandCallbacksNew )
	{
		if ( svGlobal.clientCommandCallbacksNew[ commandString ].contains(callbackFunc) )
		{
			svGlobal.clientCommandCallbacksNew[ commandString ].removebyvalue(callbackFunc)
		}
		else 
		{
			printf( "Tried to remove a callbackFunc with [ %s() ] but callbackFunc [ %s() ] does not exist for command [ %s ] in clientCommandCallbacksNew", FUNC_NAME(), string( callbackFunc ), commandString )
		}
	}
	else 
	{
		printf( "Tried to remove callbackFunc [ %s() ] with [ %s() ] but command [ %s ] does not exist in clientCommandCallbacksNew", string( callbackFunc ), FUNC_NAME(), commandString )
	}
}

void function AddCallback_OnPreClientDisconnected( void functionref( entity player ) callbackFunc )
{
	Assert( !svGlobal.onPreClientDisconnectedCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPreClientDisconnected" )
	svGlobal.onPreClientDisconnectedCallbacks.append( callbackFunc )
}

void function AddCallback_OnDeathBoxSpawned( void functionref( entity player, entity attacker, int damageSourceID ) callbackFunc )
{
	Assert( !svGlobal.onDeathBoxSpawnedCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnDeathBoxSpawned" )
	svGlobal.onDeathBoxSpawnedCallbacks.append( callbackFunc )
}

void function AddCallback_OnGetBestObserverTarget( entity functionref( entity player, bool reverse) callbackFunc )
{
	Assert( !svGlobal.onGetBestObserverTargetCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnGetBestObserverTarget" )
	svGlobal.onGetBestObserverTargetCallbacks.append( callbackFunc )
}

void function AddCallback_GameStatePostEnter( int number, void functionref( ) callbackFunc )
{

}

//Passive Voices
void function AddCallback_OnThreatEventActivation( entity player, int threat, void functionref( entity player, ThreatEventCallbackData data ) callbackFunc )
{
	Assert( !( threat in svGlobal.onThreatEventActivationCallbacks ), "Already added " + string( callbackFunc ) + " with AddCallback_OnThreatEventActivation for " + threat )
	svGlobal.onThreatEventActivationCallbacks[ threat ] <- callbackFunc
}

void function AddCallback_OnThreatEventStateChange( entity player, int threat, int watch, int view, void functionref( entity player, ThreatEventCallbackData data ) callbackFunc )
{
	Assert( !( threat in svGlobal.onThreatEventStateChangeCallbacks ), "Already added " + string( callbackFunc ) + " with AddCallback_OnThreatEventStateChange for " + threat )
	svGlobal.onThreatEventStateChangeCallbacks[ threat ] <- callbackFunc
}

//=====================================================================================
// Register functions are called when an entity spawns.
//=====================================================================================

void function RegisterForDamageDeathCallbacks( entity ent )
{
	string className = ent.GetClassName()

	if ( (className in file.classDamageCallbacks) || (className in file.classDamageFinalCallbacks) )
		ent.SetDamageNotifications( true )

	if ( className in shGlobal.deathCallbacks )
		ent.SetDeathNotifications( true )
}

void function AddTitanCallback_OnHealthSegmentLost( entity ent, void functionref( entity titan, entity victim ) callbackFunc )
{
	Assert( !ent.e.entSegmentLostCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " to entity" )

	ent.e.entSegmentLostCallbacks.append( callbackFunc )
}

void function RemoveTitanCallback_OnHealthSegmentLost( entity ent, void functionref( entity titan, entity victim ) callbackFunc )
{
	int index = ent.e.entSegmentLostCallbacks.find( callbackFunc )

	Assert( index != -1, "Requested DamageCallback " + string( callbackFunc ) + " to be removed not found! " )
	ent.e.entSegmentLostCallbacks.fastremove( index )
}

void function AddEntityCallback_OnDamaged( entity ent, void functionref( entity ent, var damageInfo ) callbackFunc )
{
	#if DEVELOPER
		mAssert( !ent.e.entDamageCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " to entity" )
	#endif

	ent.SetDamageNotifications( true )
	ent.e.entDamageCallbacks.append( callbackFunc )
}

bool function EntityCallback_Exists( entity ent, void functionref( entity, var ) callbackFunc )
{
	if ( ent.e.entDamageCallbacks.contains( callbackFunc ) )
		return true
		
	return false
}

void function RemoveEntityCallback_OnDamaged( entity ent, void functionref( entity ent, var damageInfo ) callbackFunc )
{
	int index = ent.e.entDamageCallbacks.find( callbackFunc )

	if( index == -1 )
		return

	Assert( index != -1, "Requested DamageCallback " + string( callbackFunc ) + " to be removed not found! " )
	ent.e.entDamageCallbacks.fastremove( index )

	if ( ent.e.entDamageCallbacks.len() == 0 && ent.e.entPostDamageCallbacks.len() == 0 )
		ent.SetDamageNotifications( false )
}

void function AddEntityCallback_OnPostDamaged( entity ent, void functionref( entity ent, var damageInfo ) callbackFunc )
{
	Assert( !ent.e.entPostDamageCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " to entity" )

	ent.SetDamageNotifications( true )
	ent.e.entPostDamageCallbacks.append( callbackFunc )
}

void function RemoveEntityCallback_OnPostDamaged( entity ent, void functionref( entity ent, var damageInfo ) callbackFunc )
{
	int index = ent.e.entPostDamageCallbacks.find( callbackFunc )
	if( index == -1 )
		return
	Assert( index != -1, "Requested PostDamageCallback " + string( callbackFunc ) + " to be removed not found! " )
	ent.e.entPostDamageCallbacks.fastremove( index )

	if ( ent.e.entPostDamageCallbacks.len() == 0 && ent.e.entDamageCallbacks.len() == 0 )
		ent.SetDamageNotifications( false )
}

void function AddEntityCallback_OnKilled( entity ent, void functionref( entity, var ) callbackFunc )
{
	#if DEVELOPER
	foreach ( func in  ent.e.entKilledCallbacks )
	{
		Assert( func != callbackFunc , "Already added " + string( callbackFunc ) + " to entity" )
	}
	#endif

	ent.SetDeathNotifications( true )
	ent.e.entKilledCallbacks.append( callbackFunc )
}

void function RemoveEntityCallback_OnKilled( entity ent, void functionref( entity, var ) callbackFunc )
{
	int index = ent.e.entKilledCallbacks.find( callbackFunc )
	if( index == -1 )
		return
	Assert( index != -1, "Requested KilledCallback " + string( callbackFunc ) + " to be removed not found! " )
	ent.e.entKilledCallbacks.fastremove( index )

	if ( ent.e.entKilledCallbacks.len() == 0 )
		ent.SetDeathNotifications( false )
}

void function AddEntityCallback_OnPostShieldDamage( entity ent, void functionref( entity, var, float ) callbackFunc )
{
	#if DEVELOPER
	foreach ( func in  ent.e.entPostShieldDamageCallbacks )
	{
		Assert( func != callbackFunc , "Already added " + string( callbackFunc ) + " to entity" )
	}
	#endif

	ent.e.entPostShieldDamageCallbacks.append( callbackFunc )
}

void function RemoveEntityCallback_OnPostShieldDamage( entity ent, void functionref( entity, var, float ) callbackFunc )
{
	int index = ent.e.entPostShieldDamageCallbacks.find( callbackFunc )

	Assert( index != -1, "Requested OnPostShieldDamage " + string( callbackFunc ) + " to be removed not found! " )
	ent.e.entPostShieldDamageCallbacks.fastremove( index )
}

void function CodeCallback_OnInventoryChanged( entity player )
{
	player.Signal( "InventoryChanged" )

	if ( !IsAlive( player ) )
		return

// #if HAS_TITAN_WEAPON_SWAPPING
// 	if ( player.IsTitan() )
// 	{
// 		array<entity> weapons = GetPrimaryWeapons( player )
// 		bool weaponSwap = true
// 		foreach ( weapon in weapons )
// 		{
// 			if ( weapon == player.p.lastPrimaryWeaponEnt )
// 				weaponSwap = false
// 			player.p.lastPrimaryWeaponEnt = weapon
// 		}

// 		if ( weaponSwap )
// 		{
// 			table<int,float> cooldowns = GetWeaponCooldownsForTitanLoadoutSwitch( player )

// 			ResetTitanLoadoutFromPrimary( player )

// 			bool foundNewWeapon

// 			foreach ( weapon in weapons )
// 			{
// 				int loadoutIndex = GetSPTitanLoadoutIndexForWeapon( weapon.GetWeaponClassName() )
// 				if ( loadoutIndex >= 0 )
// 				{
// 					if ( GetSPTitanLoadoutHasEverBeenSelected( loadoutIndex ) )
// 						continue

// 					foundNewWeapon = true
// 					SetSPTitanLoadoutHasEverBeenSelected( loadoutIndex )
// 				}
// 			}

// 			if ( !JustLoadedFromCheckpoint() && !foundNewWeapon )
// 				SetWeaponCooldownsForTitanLoadoutSwitch( player, cooldowns )
// 		}

// 		Assert( player.GetOffhandWeapon( OFFHAND_SPECIAL ) == null || !player.GetOffhandWeapon( OFFHAND_SPECIAL ).HasMod( "npc_normal_difficulty" ), "Player should never have mod npc_normal_difficulty" )
// 	}
// #endif // #if HAS_TITAN_WEAPON_SWAPPING

	foreach ( callbackFunc in file.playerInventoryChangedCallbacks )
	{
		callbackFunc( player )
	}
}

void function CodeCallback_OnEntityChangedTeam( entity ent )
{
	if( ent.GetClassName() == "crossbow_bolt" )
	{
		RunSpawnCallbacks( ent )
	}

	string className = ent.GetClassName()
	if ( !( className in svGlobal.onEntityChangedTeamCallbacks ) )
		return

	// Added via AddCallback_EntityChangedTeam
	foreach ( callbackFunc in svGlobal.onEntityChangedTeamCallbacks[ className ] )
	{
		callbackFunc( ent )
	}
}

//=============================
// Player movement callbacks
//=============================

void function AddPlayerMovementEventCallback( entity player, int playerMovementEvent, void functionref( entity player ) callbackFunc )
{
	if ( !player.GetSendMovementCallbacks() )
		player.SetSendMovementCallbacks( true )

	table<int, array<void functionref( entity )> > callbackTable = player.p.playerMovementEventCallbacks

	if ( ! ( playerMovementEvent in callbackTable ) )
		callbackTable[ playerMovementEvent ] <- []

	Assert( !callbackTable[ playerMovementEvent ].contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddPlayerMovementEventCallback for player " + player.GetPlayerName() )
	callbackTable[ playerMovementEvent ].append( callbackFunc )
}

void function RemovePlayerMovementEventCallback( entity player, int playerMovementEvent, void functionref( entity player ) callbackFunc )
{
	table<int, array<void functionref( entity )> > callbackTable = player.p.playerMovementEventCallbacks

	Assert( playerMovementEvent in callbackTable )
	
	if ( callbackTable.len() == 0 )
	{
		//printt( "No more playerMovementEventCallbacks for player : " + player + ", make player not get movementcallbacks anymore." )
		player.SetSendMovementCallbacks( false )
		return
	}
	
	if( !(playerMovementEvent in callbackTable) )
		return
	
	callbackTable[ playerMovementEvent ].fastremovebyvalue( callbackFunc )

	if ( callbackTable[ playerMovementEvent ].len() == 0 )
	{
		//printt( "No more callbacks for playerMovementEvent: " + playerMovementEvent + ", removing array of functions" )
		delete callbackTable[ playerMovementEvent ]
	}


}



void function CodeCallback_OnPlayerJump( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Jump")
	#endif
	
	if ( ! ( ePlayerMovementEvents.JUMP in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.JUMP ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerDoubleJump( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Double Jump")
	#endif

	if ( ! ( ePlayerMovementEvents.DOUBLE_JUMP in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.DOUBLE_JUMP ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerDodge( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Dodge" )
	#endif

	if ( ! ( ePlayerMovementEvents.DODGE in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.DODGE ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerLeaveGround( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Left Ground")
	#endif
	
	if ( ! ( ePlayerMovementEvents.LEAVE_GROUND in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.LEAVE_GROUND ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerTouchGround( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Touch Ground")
	#endif
	
	if ( ! ( ePlayerMovementEvents.TOUCH_GROUND in player.p.playerMovementEventCallbacks ) )
		return

	array<void functionref(entity)> callbacks = clone player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.TOUCH_GROUND ]

	//Run actual functions
	foreach( callbackFunc in callbacks )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerMantle( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Mantle")
	#endif
	
	if ( ! ( ePlayerMovementEvents.MANTLE in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.MANTLE ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerBeginWallrun( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Wallrun Begin")
	#endif
	
	if ( ! ( ePlayerMovementEvents.BEGIN_WALLRUN in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.BEGIN_WALLRUN ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerEndWallrun( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Wallrun End")
	#endif
	
	if ( ! ( ePlayerMovementEvents.END_WALLRUN in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.END_WALLRUN ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerBeginWallhang( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Wallhang Begin")
	#endif

	if ( ! ( ePlayerMovementEvents.BEGIN_WALLHANG in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.BEGIN_WALLHANG ] )
		callbackFunc( player )
}

void function CodeCallback_OnPlayerEndWallhang( entity player )
{
	#if PRINT_MOVEMENT
		printt( "Player Wallhang End")
	#endif
	
	if ( ! ( ePlayerMovementEvents.END_WALLHANG in player.p.playerMovementEventCallbacks ) )
		return

	//Run actual functions
	foreach( callbackFunc in player.p.playerMovementEventCallbacks[ ePlayerMovementEvents.END_WALLHANG ] )
		callbackFunc( player )
}


void function AddCallback_OnPlayerInventoryChanged( void functionref( entity ) callbackFunc )
{
	file.playerInventoryChangedCallbacks.append( callbackFunc )
}

void function CodeCallback_OnClientDisconnected( entity player, string reason )
{
	printt( "CodeCallback_OnClientDisconnected", player, reason )
	player.Signal( "OnDisconnected" )
	
	foreach( cb in svGlobal.onClientDisconnectedCallbacks )
		cb( player )
}