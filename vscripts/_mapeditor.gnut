untyped

global function ReMap_Init

global function MapEditor_CreateProp
global function MapEditor_SpawnDoor
global function MapEditor_CreateTrigger
global function MapEditor_CreateBubbleShieldWithSettings
global function MapEditor_CreateRespawnableWeaponRack
global function MapEditor_CreateLinkedZipline
global function MapEditor_CreateLootBin
global function MapEditor_CreateJumpPad
global function MapEditor_CreateButton
global function MapEditor_CreateZipline
global function MapEditor_CreateTextInfoPanel
global function MapEditor_CreateFuncWindowHint
global function ReMapCreateJumpTower
global function ReMapCreateRespawnableHeal
global function ReMapCreateSpeedBoost

global function External_ReMapSetOrigin
global function External_ReMapSetAngles
global function External_ReMapSetBool
global function External_ReMapSetFloat
global function External_ReMapSetInt
global function External_ReMapSetVectorArray01
global function External_ReMapSetVectorArray02
global function External_ReMapSetAssetArray01

global function External_ReMapRemoveAllEnts
global function External_ReMapTeleportToMap
global function External_ReMapWritePlayerInfoToFile

global function External_ReMapCreateZiplineWithSettings

global enum eMapEditorDoorType
{
    Single,
    Double,
    Vertical,
    Horizontal
}

global enum eReMapHealType
{
    Heal,
    Shield,
    HealSmall,
    ShieldSmall,
    Both
}

// Remote ent send by ReMap
global array< entity > MapEditorEnts;

// Jump Tower
const asset BALLON_BASE_MDL = $"mdl/props/zipline_balloon/zipline_balloon_base.rmdl"
const asset BALLON_MDL = $"mdl/props/zipline_balloon/zipline_balloon.rmdl"

// Respawnable MedKit
const asset MEDKIT_MDL = $"mdl/weapons_r5/loot/w_loot_wep_iso_health_main_large.rmdl"
const asset MEDKIT_FX = $"P_LL_med_drone_jet_ctr_loop"
const asset MEDKIT_SFX = $"survival_loot_pickup_Medkit_3P"

const asset MEDKIT_SMALL_MDL = $"mdl/weapons_r5/loot/w_loot_wep_iso_health_main_small.rmdl"
const asset MEDKIT_SMALL_SFX = $"survival_loot_pickup_3p_small_health"

const asset BATTERY_MDL = $"mdl/weapons_r5/loot/w_loot_wep_iso_shield_battery_large.rmdl"
const asset BATTERY_SFX = $"survival_loot_pickup_Battery_Shield_3p"

const asset BATTERY_SMALL_MDL = $"mdl/weapons_r5/loot/w_loot_wep_iso_shield_battery_small.rmdl"

const asset PHOENIX_MDL = $"mdl/weapons_r5/loot/w_loot_wep_iso_phoenix_kit_v1.rmdl"

const string HEAL_SFX  = "Lifeline_Drone_Healing_1P"

// Respawnable Boost
const asset BOOST_MDL = $"mdl/fx/plasma_sphere_01.rmdl"
const asset BOOST_CIRCLE = $"mdl/fx/ar_edge_sphere_512.rmdl"
const asset BOOST_SPRINT_FP = $"P_sprint_FP"

const bool IS_FLOWSTATE_SCRIPT = true


void function ReMap_Init()
{
    PrecacheModel( BALLON_BASE_MDL )
    PrecacheModel( BALLON_MDL )

    PrecacheModel( MEDKIT_MDL )
    PrecacheParticleSystem( MEDKIT_FX )
    PrecacheParticleSystem( MEDKIT_SFX )

    PrecacheModel( MEDKIT_SMALL_MDL )
    PrecacheParticleSystem( MEDKIT_SMALL_SFX )

    PrecacheModel( BATTERY_MDL )
    PrecacheParticleSystem( BATTERY_SFX )

    PrecacheModel( BATTERY_SMALL_MDL )

    PrecacheModel( PHOENIX_MDL )

    PrecacheModel( BOOST_MDL )
    PrecacheModel( BOOST_CIRCLE )
    PrecacheParticleSystem( BOOST_SPRINT_FP )

    MapTriggers_Init()
    AddCallback_EntitiesDidLoad( ReMapDidLoad )
}

void function MapTriggers_Init()
{
    if(GameRules_GetGameMode() == "fs_duckhunt")
        return
    
    switch (GetMapName())
    {
        case "mp_rr_aqueduct_night":
        case "mp_rr_aqueduct":
        {
            CreateWallTrigger( <425, -1590, -1689>, 1, 30000 )
            CreateWallTrigger( <732, -4456, 840>, 2 , 6000)
            CreateWallTrigger( <774, -6394, 2067>, 1 )
            break
        }
        case "mp_rr_arena_skygarden":
        {
            CreateWallTrigger( <0, -250, 3490>, 0, 10000 )
            CreateWallTrigger( <0, -250, 3650>, 1, 20000 )
            CreateWallTrigger( <0, -250, 1550>, 1, 40000 )
            break
        }
        case "mp_rr_arena_composite":
        {
            CreateWallTrigger( <5, 2587, -520>, 1, 30000)
            CreateWallTrigger( <5, 5379, 860> , 0 )
            CreateWallTrigger( <5, 5379, 1160> , 1 )
            break
        }
        case "mp_rr_ashs_redemption":
        {
            CreateWallTrigger( <-20857, 5702, -25746> , 0 )
            CreateWallTrigger( <-20857, 5702, -25246> , 1, 30000 )
            CreateWallTrigger( <-20857, 5702, -28500> , 1, 30000 )
            break
        }
        case "mp_rr_party_crasher":
        {
            CreateWallTrigger( <811, 911, 2434>, 0 , 30000 )
            CreateWallTrigger( <811, 911, -537>, 1 , 30000 )
            break
        }
        default:
            break
    }
}

void function ReMapDidLoad()
{

}

entity function CreateWallTrigger( vector origin , int type = 0, float radius = 30000 , float height = 2000, bool debugdraw = false)
{
    // Set up the trigger
    entity trigger = CreateEntity( "trigger_cylinder" )
    trigger.SetRadius( radius )
    trigger.SetAboveHeight( height )
    trigger.SetBelowHeight( 50 )
    trigger.SetOrigin( origin )
    trigger.SetEnterCallback(  WallTriggerEnter )

    switch(type)
    {
        case 1: // kill zone
        trigger.SetScriptName("WallTrigger_Killzone")
        trigger.SetAboveHeight( 350 )
        break
        case 2: // out of bounds
        trigger.SetScriptName("WallTrigger_oob_timer")
        trigger.SetAboveHeight( 2350 )
        break
    }

    if (debugdraw) // draw trigger bounds if needed
    {
        DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, trigger.GetAboveHeight(), 0, 165, 255, true, 9999.9 )
        DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, -trigger.GetBelowHeight(), 255, 90, 0, true, 9999.9 )
    }

    // deploy the trigger
    DispatchSpawn( trigger )

    return trigger
}

void function WallTriggerEnter( entity trigger , entity ent )
{
    if ( IsValid(ent) && ent.IsPlayer() && ent.GetPhysics() != MOVETYPE_NOCLIP) // ensure the entity is valid
    {
        ent.Zipline_Stop()

        switch( trigger.GetScriptName() )
        {
            case "WallTrigger_Killzone":
                ent.TakeDamage(ent.GetMaxHealth() + 1, null, null, { damageSourceId=damagedef_suicide, scriptType=DF_BYPASS_SHIELD })
            break

            case "WallTrigger_oob_timer":
                EntityOutOfBounds( trigger, ent, null, null )
            break

            default:
                vector lookDir = ent.GetSmoothedVelocity()
                vector pushBackVel = lookDir * 2.5

                if( LengthSqr( lookDir ) >= 320000)
                    pushBackVel = lookDir / 1.5

                vector targetDir = ent.GetWorldSpaceCenter() - trigger.GetWorldSpaceCenter()
                if ( DotProduct( lookDir, targetDir ) < 0 )
                    pushBackVel = -pushBackVel

                ent.KnockBack( pushBackVel, 0.3 )
                return
            break
        }

        ent.DisableWeapon()


        StatusEffect_AddEndless( ent, eStatusEffect.hunt_mode_visuals, 100 )
        StatusEffect_AddEndless( ent, eStatusEffect.move_slow, 0.2 )

        thread function() : ( trigger, ent )
        {
            while( IsValid(ent) && trigger.IsTouching( ent ) )
                WaitFrame()

            if( IsValid(ent) )
            {
                EntityBackInBounds( trigger, ent, null, null )
                ent.EnableWeapon()

                StatusEffect_StopAllOfType( ent, eStatusEffect.hunt_mode_visuals)
                StatusEffect_StopAllOfType( ent, eStatusEffect.minimap_jammed)
                StatusEffect_StopAllOfType( ent, eStatusEffect.move_slow)
            }
        }()
    }
}

entity function MapEditor_CreateProp( asset a, vector pos, vector ang, bool mantle = false, float fade = 5000, int realm = -1, float scale = 1, bool addToArray = false )
{
    entity e = CreatePropDynamic( a, pos, ang, SOLID_VPHYSICS, fade )
    e.kv.fadedist = fade
    e.kv.rendermode = 0
    e.kv.renderamt = 1
    e.kv.solid = 6
    e.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER

    if( mantle ) e.AllowMantle()
    
    if (realm > -1)
    {
        e.RemoveFromAllRealms()
        e.AddToRealm( realm )
    }
    
    e.SetScriptName("editor_placed_prop")
    e.e.gameModeId = realm
    e.SetModelScale( scale )

    #if IS_FLOWSTATE_SCRIPT
        e.kv.contents = CONTENTS_PLAYERCLIP | CONTENTS_HITBOX | CONTENTS_OCCLUDESOUND | CONTENTS_BULLETCLIP | CONTENTS_MONSTERCLIP | CONTENTS_SOLID
    
        if( GameRules_GetGameMode() == "fs_duckhunt" )
        {
            if( a == $"mdl/foliage/plant_leafy_02.rmdl" && IsValid( e ) || a == $"mdl/foliage/plant_tropical_green_large_02.rmdl" && IsValid( e ) )
            {
                e.kv.solid = 0
            }
            else e.kv.solid = 6
    
            if( a == $"mdl/imc_base/imc_fan_large_case_01.rmdl" )
                CreateFanPusher( e.GetOrigin() + Vector( 0, 0, 56 ), e.GetAngles() )
    
            if( a == $"mdl/industrial/traffic_cone_01.rmdl" )
            {
                SpawnKillerWalls( e.GetOrigin() )
                e.Destroy()
                return null
            }
    
            if( a == $"mdl/industrial/traffic_tube_01.rmdl" )
            {
                SpawnMovingPlatform( e.GetOrigin() )
                e.Destroy()
                return null		
            }
    
            if( a == $"mdl/industrial/traffic_barrel_01.rmdl" )
            {
                SpawnMovingPlatformWithFanPusher( e.GetOrigin() )
                e.Destroy()
                return null		
            }
        }
    #endif

    if( addToArray ) MapEditorEnts.append( e )
    
    return e
}

array < entity > function MapEditor_SpawnDoor( vector org, vector ang, int type, bool gold = false, bool spawnOpen = false, bool addToArray = false )
{
    array < entity > doorArray = []

    switch( type )
    {
        case eMapEditorDoorType.Single:
            entity door = CreateDoorEntity( "prop_door", $"mdl/door/canyonlands_door_single_02.rmdl", "", org, ang, gold )
            DispatchSpawn( door )

            if ( spawnOpen ) OpenCodeDoorAtSpawn( door )

            doorArray.append( door )
            break;

        case eMapEditorDoorType.Double:
            entity door = CreateDoorEntity( "prop_door", $"mdl/door/canyonlands_door_single_02.rmdl", "", org, ang, gold )
            door.SetOrigin( org + door.GetRightVector() * 60 )
            DispatchSpawn( door )

            entity oppositeDoor = CreateDoorEntity( "prop_door", $"mdl/door/canyonlands_door_single_02.rmdl", "", org, < -ang.x, ang.y + 180, -ang.z >, gold )
            oppositeDoor.SetOrigin( org + oppositeDoor.GetRightVector() * 60 )
            oppositeDoor.LinkToEnt( door )
            DispatchSpawn( oppositeDoor )

            if ( spawnOpen ) OpenCodeDoorAtSpawn( door )

            doorArray.extend( [ door, oppositeDoor ] )
            break;

        case eMapEditorDoorType.Vertical:
            entity door = CreateDoorEntity( "prop_dynamic", $"mdl/door/door_canyonlands_large_01_animated.rmdl", "survival_door_plain", org, ang, false )
            DispatchSpawn( door )

            if ( spawnOpen ) OpenPlainDoorAtSpawn( door )

            doorArray.append( door )
            break;

        case eMapEditorDoorType.Horizontal:
            entity door = CreateDoorEntity( "prop_dynamic", $"mdl/door/door_256x256x8_elevatorstyle02_animated.rmdl", "survival_door_plain", org, ang, false )
            DispatchSpawn( door )

            if ( spawnOpen ) OpenPlainDoorAtSpawn( door )

            doorArray.append( door )
        break;
    }

    if ( addToArray ) MapEditorEnts.extend( doorArray )

    return doorArray
}

entity function CreateDoorEntity( string type, asset model, string scriptName, vector origin, vector angles, bool gold = false )
{
    entity door = CreateEntity( type )
    door.SetOrigin( origin )
    door.SetAngles( angles )
    door.SetValueForModelKey( model )

    if( scriptName != "" )
    {
        door.SetScriptName( scriptName )
        door.kv.solid = 6
    }

    if( gold ) door.SetSkin( 1 )

    return door
}

void function OpenCodeDoorAtSpawn( entity door )
{
    entity fakeUser = CreateEntity( "prop_dynamic" )
    fakeUser.SetOrigin( door.GetOrigin() - door.GetForwardVector() * 100 )

    door.OpenDoor( fakeUser )

    fakeUser.Destroy()
}

void function OpenPlainDoorAtSpawn( entity door )
{
    PlayAnimNoWait( door, "open" )
    door.e.isOpen = true
    GradeFlagsSet( door, eGradeFlags.IS_OPEN )
    door.SetUsePrompts( "#SURVIVAL_CLOSE_DOOR", "#SURVIVAL_CLOSE_DOOR" )
}

entity function MapEditor_CreateTrigger( vector origin, vector angles, float radius, float totalheight, bool debugdraw = false, bool addToArray = false)
{
    // Set up the trigger
    entity trigger = CreateEntity( "trigger_cylinder" )
    trigger.SetRadius( radius )
    trigger.SetAboveHeight( totalheight )
    trigger.SetBelowHeight( totalheight )
    trigger.SetOrigin( origin )
    trigger.SetAngles( angles )

    if (debugdraw) // draw trigger bounds if needed
    {
        DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, totalheight, 0, 165, 255, true, 9999.9 )
        DebugDrawCylinder( trigger.GetOrigin() , < -90, 0, 0 >, radius, -totalheight, 255, 90, 0, true, 9999.9 )
    }

    if( addToArray ) MapEditorEnts.append( trigger )

    return trigger
}

entity function MapEditor_CreateBubbleShieldWithSettings( vector origin, vector angles, float scale, string color, asset collisionModel, bool addToArray = false )
{
    entity bubbleShield = CreateEntity( "prop_dynamic" )
    bubbleShield.SetValueForModelKey( collisionModel ) // TODO: fix this for apex
    bubbleShield.kv.solid = SOLID_VPHYSICS
    bubbleShield.kv.rendercolor = color
    bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
    bubbleShield.SetOrigin( origin )
    bubbleShield.SetAngles( angles )
    bubbleShield.SetModelScale( scale )
    // Blocks bullets, projectiles but not players and not AI
    bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
    DispatchSpawn( bubbleShield )

    EmitSoundOnEntity( bubbleShield, "Gibraltar_BubbleShield_Sustain" )

    if( addToArray ) MapEditorEnts.append( bubbleShield )

    return bubbleShield
}

void function MapEditor_CreateRespawnableWeaponRack(vector pos, vector ang, string weaponName, float spawnTime, bool addToArray = false)
{
    entity rack = CreateWeaponRack(pos, ang, weaponName)
    thread OnPickupFromRackThread(GetWeaponFromRack(rack), weaponName, spawnTime)

    if(addToArray ) MapEditorEnts.append( rack )
}

// When the weapon is grabbed from the rack -> respawn it
void function OnPickupFromRackThread(entity item, string ref, float spawnTime, bool addToArray = false)
{
    entity rack = item.GetParent()
    item.WaitSignal("OnItemPickup")

    wait spawnTime

    entity newWeapon = SpawnWeaponOnRack(rack, ref)
    StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_ITEM_RESPAWN_PARTICLE ), newWeapon.GetOrigin(), newWeapon.GetAngles() )
    thread OnPickupFromRackThread(newWeapon, ref, spawnTime)
}

entity function MapEditor_CreateLootBin( vector origin, vector angles, int skin = 0, bool addToArray = false )
{
    entity lootbin = CreateEntity( "prop_dynamic" )
    lootbin.SetScriptName( LOOT_BIN_SCRIPTNAME )
    lootbin.SetValueForModelKey( LOOT_BIN_MODEL )
    lootbin.SetOrigin( origin )
    lootbin.SetAngles( angles )
    lootbin.kv.solid = SOLID_VPHYSICS

    DispatchSpawn( lootbin )
    lootbin.SetSkin( skin )

    if( addToArray ) MapEditorEnts.append( lootbin )

    return lootbin
}

entity function SetNodeRopeProperties( entity rope )
{
    rope.kv.MoveSpeed = 64
    rope.kv.Slack = 25
    rope.kv.Subdiv = "2"
    rope.kv.Width = "2"
    rope.kv.Type = "0"
    rope.kv.TextureScale = "1"
    rope.kv.PositionInterpolator = 2
    rope.kv.RopeMaterial = "cable/zipline.vmt"
    rope.kv.Zipline = "1"
    rope.kv.ZiplineAutoDetachDistance = "150"
    rope.kv.ZiplineSagEnable = "0"
    rope.kv.ZiplineSagHeight = "50"
    rope.kv.fadedist = 50000

    return rope
}

void function MapEditor_CreateJumpPad( entity jumpPad, bool addToArray = false )
{
    JumpPad_CreatedCallback(jumpPad)

    if( addToArray ) MapEditorEnts.append( jumpPad )
}

void function MapEditor_CreateButton( entity ent, void functionref( entity, entity, int ) callbackFunc, bool addToArray = false )
{
    AddCallback_OnUseEntity( ent, callbackFunc )

    if( addToArray ) MapEditorEnts.append( ent )
}

void function MapEditor_CreateLinkedZipline( array<vector> nodes, bool addToArray = false )
{
    array<entity> ropes = [ SetNodeRopeProperties( CreateEntity( "move_rope" ) ) ]
    ropes[0].SetOrigin( nodes[0] )

    // create child ropes
    for(int i = 1; i < nodes.len(); i++) {
        vector nodepos = nodes[i]
        ropes.append( SetNodeRopeProperties( CreateEntity( "keyframe_rope" )  ) )
        
        ropes[i].SetOrigin( nodepos )
    }

    // link all nodes
    for(int i = 0; i < ropes.len(); i++) {
        if(i + 1 < ropes.len())
            ropes[i].LinkToEnt( ropes[i + 1]  )
    }

    foreach( entity rope in ropes ) {
        DispatchSpawn( rope )

        if( addToArray ) MapEditorEnts.append( rope )
    }
}

void function MapEditor_CreateZipline( vector startPos, vector endPos, bool addToArray = false )
{
    string startpointName = UniqueString( "rope_startpoint" )
    string endpointName = UniqueString( "rope_endpoint" )

    entity rope_start = CreateEntity( "move_rope" )
    SetTargetName( rope_start, startpointName )
    rope_start.kv.NextKey = endpointName
    rope_start.kv.MoveSpeed = 64
    rope_start.kv.Slack = 25
    rope_start.kv.Subdiv = "2"
    rope_start.kv.Width = "2"
    rope_start.kv.Type = "0"
    rope_start.kv.TextureScale = "1"
    rope_start.kv.RopeMaterial = "cable/zipline.vmt"
    rope_start.kv.PositionInterpolator = 2
    rope_start.kv.Zipline = "1"
    rope_start.kv.ZiplineAutoDetachDistance = "150"
    rope_start.kv.ZiplineSagEnable = "0"
    rope_start.kv.ZiplineSagHeight = "50"
    rope_start.SetOrigin( startPos )

    entity rope_end = CreateEntity( "keyframe_rope" )
    SetTargetName( rope_end, endpointName )
    rope_end.kv.MoveSpeed = 64
    rope_end.kv.Slack = 25
    rope_end.kv.Subdiv = "2"
    rope_end.kv.Width = "2"
    rope_end.kv.Type = "0"
    rope_end.kv.TextureScale = "1"
    rope_end.kv.RopeMaterial = "cable/zipline.vmt"
    rope_end.kv.PositionInterpolator = 2
    rope_end.kv.Zipline = "1"
    rope_end.kv.ZiplineAutoDetachDistance = "150"
    rope_end.kv.ZiplineSagEnable = "0"
    rope_end.kv.ZiplineSagHeight = "50"
    rope_end.SetOrigin( endPos )

    DispatchSpawn( rope_start )
    DispatchSpawn( rope_end )

    if( addToArray )
    {
        MapEditorEnts.extend( [ rope_start, rope_end ] )
    }
}

array< array > TextInfoPanelArray

void function MapEditor_CreateTextInfoPanel( string title, string text, vector origin, vector angles, bool showPin, float textScale )
{
    TextInfoPanelArray.append( [ title, text, origin, angles, showPin, textScale ] )

    AddCallback_OnClientConnected( MapEditor_CreateTextInfoPanel_Internal )
}

void function MapEditor_CreateTextInfoPanel_Internal( entity player )
{
    for ( int arrayLen = 0 ; arrayLen < TextInfoPanelArray.len() ; arrayLen++ )
    {
        string sendPanelText
        string title =  expect string( TextInfoPanelArray[arrayLen][0] )
        string text =   expect string( TextInfoPanelArray[arrayLen][1] )
        vector origin = expect vector( TextInfoPanelArray[arrayLen][2] )
        vector angles = expect vector( TextInfoPanelArray[arrayLen][3] )
        bool showPin =  expect bool( TextInfoPanelArray[arrayLen][4] )
        float textScale = expect float( TextInfoPanelArray[arrayLen][5] )
    
        for ( int textType = 0 ; textType < 2 ; textType++ )
        {
            sendPanelText = textType == 0 ? title : text

            for ( int i = 0; i < sendPanelText.len(); i++ )
            {
                Remote_CallFunction_NonReplay( player, "Dev_BuildTextInfoPanel", textType, sendPanelText[i] )
            }
        }

        Remote_CallFunction_NonReplay( player, "Dev_CreateTextInfoPanel", origin.x, origin.y, origin.z, angles.x, angles.y, angles.z, showPin, textScale )
    }
}

entity function MapEditor_CreateFuncWindowHint( vector origin, float halfheight, float halfwidth, vector right, bool addToArray = false )
{
    entity hint = CreateEntity( "func_window_hint" )
    hint.kv.origin = origin.x + " " + origin.y  + " " + origin.z
    hint.kv.halfheight = halfheight
    hint.kv.halfwidth  = halfwidth
    hint.kv.right      = right.x + " " + right.y  + " " + right.z
    DispatchSpawn( hint )

    if( addToArray )
    {
        MapEditorEnts.append( hint )
    }

    return hint
}

void function ReMapCreateJumpTower( vector origin, vector angles, float height, bool addToArray = false )
{
    entity ballon_base = CreateEntity( "prop_dynamic" )
    ballon_base.SetOrigin( origin )
    ballon_base.SetAngles( < 0, angles.y, 0 > )
    ballon_base.SetModelScale( 1 )
    ballon_base.SetValueForModelKey( BALLON_BASE_MDL )
    ballon_base.kv.solid = 6
    ballon_base.AllowMantle()

    entity ballon_top = CreateEntity( "prop_dynamic" )
    ballon_top.SetOrigin( origin + < 0, 0, height > )
    ballon_top.SetAngles( < 0, angles.y, 0 > )
    ballon_top.SetModelScale( 1 )
    ballon_top.SetValueForModelKey( BALLON_MDL )
    ballon_top.kv.solid = 3

    array < entity > ballonArr = [ ballon_base, ballon_top ]

    foreach ( ent in ballonArr )
    {
        ent.kv.fadedist = -1
        ent.kv.renderamt = 255
        ent.kv.rendercolor = "255 255 255"
        ent.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
        ent.SetScriptName( "jump_tower" )

        if( addToArray ) MapEditorEnts.append( ent )

        DispatchSpawn( ent )
    }

    vector zipline_start_origin_offset = PositionOffsetFromEnt( ballon_top, -1.75, -2.75, 0 )
    vector zipline_end_origin_offset = PositionOffsetFromEnt( ballon_base, -1.75, -2.75, 64 )

    MapEditor_CreateZiplineFromUnity( zipline_start_origin_offset, < 0, angles.y, 0 >, zipline_end_origin_offset, < 0, angles.y, 0 >, true, -1, 1, 2, 1, 1, 1, 1, 200, 200, true, 0, false, 0, 0, [], [], [], 0, 0, 0, addToArray )

    entity trigger = MapEditor_CreateTrigger( origin + < 0, 0, height - 20 >, < 0, angles.y, 0 >, 200, 200, false, addToArray )
    trigger.SetEnterCallback( ForcedSkydiveTriggerThink_EnterCallback )

    DispatchSpawn( trigger )
}

// RespawnableHeal was inspired by the script of Zer0Bytes#4428
struct RespawnableHealStruct
{
    entity heal
    entity heal_proxy
    vector spawnPos

    int healType
    float respawnTime = 10.0
    float healTime = 3.0
    int healAmount = 25
    bool progressive = false
    bool addToArray = false
    array< entity > fx
}

array< entity > isHealActive = []
array< entity > isShieldActive = []
array< entity > isPhoenixActive = []

void function ReMapCreateRespawnableHeal( vector spawnPos, int healType, float respawnTime, float healTime, int healAmount, bool progressive, bool addToArray = false )
{
    RespawnableHealStruct instance
    instance.spawnPos = spawnPos
    instance.respawnTime = respawnTime
    instance.healTime = healTime
    instance.healAmount = healAmount
    instance.progressive = progressive
    instance.addToArray = addToArray
    instance.healType = healType

    instance.heal = MapEditor_CreateProp( DetermineHealModel( instance.healType ), instance.spawnPos + < 0, 0, 32 >, ZERO_VECTOR, false, 50000 )
    instance.heal.SetModelScale( 1 )
    instance.heal.kv.renderamt = 255
    instance.heal.kv.rendercolor = "255 255 255 200"
    instance.heal.kv.solid = 0
    instance.heal.NotSolid()
    thread RotateEntity( instance.heal, 7.0 , false )

    for ( int i = 0; i < 4; i++ )
    {
        entity fx = StartParticleEffectInWorld_ReturnEntity( GetParticleSystemIndex( MEDKIT_FX ), instance.heal.GetOrigin(), < 0, 0 +  i * 90, 0 > )
        fx.SetParent( instance.heal )
        instance.fx.append( fx )
    }

    SetSurvivalPropHighlight( instance.heal, DeterminePropHighlight( instance.healType ), false )

    EmitSoundOnEntity( instance.heal, DetermineHealSound( instance.healType ) )

    instance.heal_proxy = CreateEntity( "trigger_cylinder" )
    instance.heal_proxy.SetRadius( 50 )
    instance.heal_proxy.SetAboveHeight( 60 )
    instance.heal_proxy.SetBelowHeight( 0 )
    instance.heal_proxy.SetOrigin( instance.spawnPos )
    DispatchSpawn( instance.heal_proxy )
    instance.heal_proxy.SetParent( instance.heal )
    thread OnTouchHeal( instance )

    if ( addToArray )
    {
        MapEditorEnts.extend( [ instance.heal, instance.heal_proxy ] )

        foreach ( entity fx in instance.fx ) MapEditorEnts.append( fx )
    }
}

void function OnTouchHeal( RespawnableHealStruct instance )
{
    bool active = true
    while ( active )
    {
        if ( !IsValid( instance.heal_proxy ) ) break

        array< entity > touchingEnts = instance.heal_proxy.GetTouchingEntities()

        foreach ( touchingEnt in touchingEnts )
        {
            if ( touchingEnt.IsPlayer() && IsValid( touchingEnt ) && PlayerCanUse_RespawnableHeal( touchingEnt, instance.healType ) )
            {
                DetermineArray( touchingEnt, instance.healType )

                StopSoundOnEntity( touchingEnt, HEAL_SFX )
                StatusEffect_StopAllOfType( touchingEnt, eStatusEffect.drone_healing )
                StatusEffect_AddEndless( touchingEnt, eStatusEffect.drone_healing, 1 )
                EmitSoundOnEntityOnlyToPlayer( touchingEnt, touchingEnt, HEAL_SFX )

                instance.heal.kv.rendercolor = "255 255 255 50"
                for ( int i = 0; i < instance.fx.len(); i++ )
                {
                    if ( IsValid( instance.fx[i] ) ) instance.fx[i].Destroy()
                }
                instance.fx.clear()

                thread DestroyHeal( instance )

                if ( instance.progressive )
                {
                    waitthread OnProgressiveHealPlayer( touchingEnt, instance )
                }
                else
                {
                    wait instance.healTime

                    if ( IsValid( touchingEnt ) )
                    {
                        bool hasShield = EquipmentSlot_GetLootRefForSlot( touchingEnt, "armor" ) != ""

                        switch ( instance.healType )
                        {
                            case eReMapHealType.Heal:
                                touchingEnt.SetHealth( touchingEnt.GetMaxHealth() )
                                break
                            
                            case eReMapHealType.HealSmall:
                                touchingEnt.SetHealth( min( touchingEnt.GetMaxHealth(), touchingEnt.GetHealth() + instance.healAmount ) )
                                break

                            case eReMapHealType.Shield:
                                if ( hasShield ) touchingEnt.SetShieldHealth( touchingEnt.GetShieldHealthMax() )
                                break

                            case eReMapHealType.ShieldSmall:
                                if ( hasShield ) touchingEnt.SetShieldHealth( min( touchingEnt.GetShieldHealthMax(), touchingEnt.GetShieldHealth() + instance.healAmount ) )
                                break

                            case eReMapHealType.Both:
                                touchingEnt.SetHealth( touchingEnt.GetMaxHealth() )
                                if ( hasShield ) touchingEnt.SetShieldHealth( touchingEnt.GetShieldHealthMax() )
                            break
                        }
                    }
                }

                DetermineArray( touchingEnt, instance.healType, true )

                StopSoundOnEntity( touchingEnt, HEAL_SFX )
                StatusEffect_StopAllOfType( touchingEnt, eStatusEffect.drone_healing )
            }
        }
        
        wait 0.01
    }
}

void function DestroyHeal( RespawnableHealStruct instance )
{
    wait instance.healTime

    thread OnHealPickup( instance )

    if ( IsValid( instance.heal_proxy ) ) instance.heal_proxy.Destroy()
}

void function OnProgressiveHealPlayer( entity touchingEnt, RespawnableHealStruct instance )
{
    bool hasLowHealth = touchingEnt.GetHealth() < touchingEnt.GetMaxHealth()
    bool hasLowShield = touchingEnt.GetShieldHealth() < touchingEnt.GetShieldHealthMax()

    int HealthRemaining = touchingEnt.GetMaxHealth() - touchingEnt.GetHealth()
    int SheildRemaining = touchingEnt.GetShieldHealthMax() - touchingEnt.GetShieldHealth()

    int health = touchingEnt.GetHealth()
    int shield = touchingEnt.GetShieldHealth()

    bool isTakingFire = false

    //Heal health first
    if ( hasLowHealth && instance.healType == eReMapHealType.HealSmall || instance.healType == eReMapHealType.Heal || instance.healType == eReMapHealType.Both )
    {
        float healWait = ( instance.healTime / 2 ) / HealthRemaining
        int amount = touchingEnt.GetHealth() + instance.healAmount
        while ( hasLowHealth )
        {
            if ( IsTakingFire( health, touchingEnt.GetHealth() ) || IsTakingFire( shield, touchingEnt.GetShieldHealth() ) )
            {
                isTakingFire = true; break
            }
            else
            {
                health = touchingEnt.GetHealth()
                shield = touchingEnt.GetShieldHealth()
            }

            if ( instance.healType == eReMapHealType.HealSmall )
            {
                hasLowHealth = touchingEnt.GetHealth() < min( touchingEnt.GetMaxHealth(), amount )
            }
            else
            {
                hasLowHealth = touchingEnt.GetHealth() < touchingEnt.GetMaxHealth()
            }

            if ( touchingEnt.GetHealth() + 1 > touchingEnt.GetMaxHealth() )
            {
                touchingEnt.SetHealth( touchingEnt.GetMaxHealth() )
            }
            else touchingEnt.SetHealth( touchingEnt.GetHealth() + 1 )

            wait healWait
        }
    }

    //now gen sheild
    if ( hasLowShield && !isTakingFire && instance.healType == eReMapHealType.ShieldSmall || instance.healType == eReMapHealType.Shield || instance.healType == eReMapHealType.Both )
    {
        float sheildWait = ( instance.healTime / 2 ) / SheildRemaining
        int amount = touchingEnt.GetShieldHealth() + instance.healAmount
        while ( hasLowShield )
        {
            if ( IsTakingFire( shield, touchingEnt.GetShieldHealth() ) )
            {
                isTakingFire = true; break
            }
            else
            {
                shield = touchingEnt.GetShieldHealth()
            }

            if ( instance.healType == eReMapHealType.ShieldSmall )
            {
                hasLowShield = touchingEnt.GetShieldHealth() < min( touchingEnt.GetShieldHealthMax(), amount )
            }
            else
            {
                hasLowShield = touchingEnt.GetShieldHealth() < touchingEnt.GetShieldHealthMax()
            }

            if ( touchingEnt.GetShieldHealth() + 1 > touchingEnt.GetShieldHealthMax() )
            {
                touchingEnt.SetShieldHealth( touchingEnt.GetShieldHealthMax() )
            }
            else touchingEnt.SetShieldHealth( touchingEnt.GetShieldHealth() + 1 )

            wait sheildWait
        }
    }
}

asset function DetermineHealModel( int healType )
{
    switch ( healType )
    {
        case eReMapHealType.HealSmall:   return MEDKIT_SMALL_MDL
        case eReMapHealType.ShieldSmall: return BATTERY_SMALL_MDL
        case eReMapHealType.Heal:        return MEDKIT_MDL
        case eReMapHealType.Shield:      return BATTERY_MDL
        case eReMapHealType.Both:        return PHOENIX_MDL
    }

    return $"mdl/dev/empty.rmdl"
}

asset function DetermineHealSound( int healType )
{
    switch ( healType )
    {
        case eReMapHealType.HealSmall: return MEDKIT_SMALL_SFX
        case eReMapHealType.Heal:      return MEDKIT_SFX

        case eReMapHealType.ShieldSmall:
        case eReMapHealType.Shield:
        case eReMapHealType.Both:      return BATTERY_SFX
    }

    return MEDKIT_SFX
}

string function DeterminePropHighlight( int healType )
{
    switch ( healType )
    {
        case eReMapHealType.HealSmall:
        case eReMapHealType.ShieldSmall:
            return "survival_item_common"

        case eReMapHealType.Heal:
        case eReMapHealType.Shield:
            return "survival_item_rare"

        case eReMapHealType.Both: return "survival_item_epic"
    }

    return "survival_item_common"
}

void function DetermineArray( entity player, int healType, bool remove = false )
{
    switch ( healType )
    {
        case eReMapHealType.HealSmall:
        case eReMapHealType.Heal:
            if ( remove )
            {
                isHealActive.removebyvalue( player )
                ArrayRemoveInvalid( isHealActive )
            }
            else isHealActive.append( player )
            break

        case eReMapHealType.ShieldSmall:
        case eReMapHealType.Shield:
            if ( remove )
            {
                isShieldActive.removebyvalue( player )
                ArrayRemoveInvalid( isShieldActive )
            }
            else isShieldActive.append( player )
            break

        case eReMapHealType.Both:
            if ( remove )
            {
                isPhoenixActive.removebyvalue( player )
                ArrayRemoveInvalid( isPhoenixActive )
            }
            else isPhoenixActive.append( player )
        break
    }
}

bool function PlayerCanUse_RespawnableHeal( entity player, int healType )
{
    switch ( healType )
    {
        case eReMapHealType.Heal:
        case eReMapHealType.HealSmall:
            return player.GetHealth() != player.GetMaxHealth() && !isPhoenixActive.contains( player ) && !isHealActive.contains( player )
        case eReMapHealType.Shield:
        case eReMapHealType.ShieldSmall:
            return player.GetShieldHealth() != player.GetShieldHealthMax() && !isPhoenixActive.contains( player ) && !isShieldActive.contains( player )
        case eReMapHealType.Both:
        return player.GetHealth() != player.GetMaxHealth() || player.GetShieldHealth() != player.GetShieldHealthMax() && !isShieldActive.contains( player )
    }

    return false
}

bool function IsTakingFire( int startingHeal, int currentHeal )
{
    return currentHeal < startingHeal
}

void function OnHealPickup( RespawnableHealStruct instance )
{
    instance.heal_proxy.WaitSignal( "OnDestroy" )
    wait instance.respawnTime
    if ( IsValid( instance.heal ) ) instance.heal.Destroy()
    
    ReMapCreateRespawnableHeal( instance.spawnPos, instance.healType, instance.respawnTime, instance.healTime, instance.healAmount, instance.progressive, instance.addToArray )
}

void function RotateEntity( entity ent, float speed, bool rightside )
{
    vector result
    bool active = true
    while ( active )
    {
        if ( IsValid( ent ) )
        {
            if ( rightside )
            {
               result =  ent.GetAngles() + < 0, -speed, 0 >
            }
            else result = ent.GetAngles()  + < 0, speed, 0 >

            ent.SetAngles( result )
        }
        else
        {
            active = false
            break
        }

        wait 0.01
    }
}

// RespawnableBoost was inspired by the script of Archtux#9300
struct RespawnableBoost
{
    entity boost
    entity boost_proxy
    vector spawnPos

    vector color
    float respawnTime = 5.0
    float strengh = 0.35
    float boostDuration = 3.0
    float fadeTime = 0.5
    bool addToArray = false
}

void function ReMapCreateSpeedBoost( vector spawnPos, vector color, float respawnTime, float strengh, float duration, float fadeTime, bool addToArray = false )
{
    RespawnableBoost instance
    instance.spawnPos = spawnPos
    instance.color = color
    instance.respawnTime = respawnTime
    instance.strengh = strengh
    instance.boostDuration = duration
    instance.fadeTime = fadeTime

    instance.boost = CreateScriptMover( instance.spawnPos, ZERO_VECTOR )

    // Boost
    for ( int j = 0; j < 5; j++ )
    {
        entity boost = CreateEntity( "prop_dynamic" )
        boost.kv.solid = 0
        boost.SetValueForModelKey( BOOST_MDL )
        boost.SetModelScale( 0.5 )
        boost.kv.rendercolor = instance.color.x + " " + instance.color.y + " " + instance.color.z
        boost.kv.fadedist = 20000

        boost.SetOrigin( instance.spawnPos + < 0, 0, 50 > )
        boost.SetAngles( ZERO_VECTOR + j * < 0, 60, 0 > )

        boost.SetParent( instance.boost )

        if ( addToArray ) MapEditorEnts.append( boost )

        DispatchSpawn( boost )
    }

    // Base Circle
    entity circle = CreateEntity( "prop_dynamic" )
    circle.kv.solid = 0
    circle.SetModelScale( 0.1 )
    circle.SetValueForModelKey( BOOST_CIRCLE )
    circle.SetOrigin( instance.spawnPos )
    circle.kv.rendercolor = instance.color.x + " " + instance.color.y + " " + instance.color.z
    circle.kv.fadedist = 20000
    DispatchSpawn( circle )

    circle.SetParent( instance.boost )

    // Trigger
    instance.boost_proxy = CreateEntity( "trigger_cylinder" )
    instance.boost_proxy.SetRadius( 30 )
    instance.boost_proxy.SetAboveHeight( 30 ) // Still not quite a sphere, will see if close enough
    instance.boost_proxy.SetBelowHeight( 30 )
    instance.boost_proxy.SetOrigin( instance.spawnPos + < 0, 0, 50 > )
    instance.boost_proxy.SetAngles( ZERO_VECTOR )
    instance.boost_proxy.SetParent( instance.boost )
    DispatchSpawn( instance.boost_proxy )

    if ( addToArray )
    {
        MapEditorEnts.extend( [ instance.boost, instance.boost_proxy, circle ] )
    }

    thread CreateBoostTrigger( instance )
}


void function CreateBoostTrigger( RespawnableBoost instance )
{
    while ( true )
    {
        if ( !IsValid( instance.boost_proxy ) ) break

        array< entity > touchingEnts = instance.boost_proxy.GetTouchingEntities()

        foreach( touchingEnt in touchingEnts  )
        {
            if ( touchingEnt.IsPlayer() && IsValid( touchingEnt ) )
            {
                StatusEffect_AddTimed( touchingEnt, eStatusEffect.speed_boost, instance.strengh, instance.boostDuration, instance.fadeTime )

                thread PlayFxOnPlayer( touchingEnt, instance.boostDuration )

                if ( IsValid( instance.boost ) ) instance.boost.Destroy()

                wait instance.respawnTime

                thread ReMapCreateSpeedBoost( instance.spawnPos, instance.color, instance.respawnTime, instance.strengh, instance.boostDuration, instance.fadeTime, instance.addToArray )
                break
            }	
        }
        wait 0.1
    }
}

void function PlayFxOnPlayer( entity player, float time )
{
    entity fx = PlayLoopFXOnEntity( BOOST_SPRINT_FP, player )

        wait time

    if ( IsValid( fx ) ) fx.Destroy()
}


//  ██╗   ██╗███╗   ██╗██╗████████╗██╗   ██╗    ██████╗ ███████╗███╗   ███╗ ██████╗ ████████╗███████╗    ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗
//  ██║   ██║████╗  ██║██║╚══██╔══╝╚██╗ ██╔╝    ██╔══██╗██╔════╝████╗ ████║██╔═══██╗╚══██╔══╝██╔════╝    ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║
//  ██║   ██║██╔██╗ ██║██║   ██║    ╚████╔╝     ██████╔╝█████╗  ██╔████╔██║██║   ██║   ██║   █████╗      █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║
//  ██║   ██║██║╚██╗██║██║   ██║     ╚██╔╝      ██╔══██╗██╔══╝  ██║╚██╔╝██║██║   ██║   ██║   ██╔══╝      ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║
//  ╚██████╔╝██║ ╚████║██║   ██║      ██║       ██║  ██║███████╗██║ ╚═╝ ██║╚██████╔╝   ██║   ███████╗    ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║
//   ╚═════╝ ╚═╝  ╚═══╝╚═╝   ╚═╝      ╚═╝       ╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝ ╚═════╝    ╚═╝   ╚══════╝    ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝
vector origin01 = < 0, 0, 0 >
vector origin02 = < 0, 0, 0 >
vector angles01 = < 0, 0, 0 >
vector angles02 = < 0, 0, 0 >
array< vector > arrayVec01 = []
array< vector > arrayVec02 = []

bool bool01 = true
bool bool02 = false
bool bool03 = false

float float01 = -1.0
float float02 = 1.0
float float03 = 2.0
float float04 = 1.0
float float05 = 1.0
float float06 = 150.0
float float07 = 50.0
float float08 = 32.0
float float09 = 60.0

int int01 = 0
int int02 = 1
int int03 = 1
int int04 = 0
int int05 = 0
int int06 = 0

array< asset > arrayAsset01 = []

void function External_ReMapSetOrigin( vector vec01, vector vec02 )
{
    origin01 = vec01
    origin02 = vec02
}

void function External_ReMapSetAngles( vector vec01, vector vec02 )
{
    angles01 = vec01
    angles02 = vec02
}

void function External_ReMapSetBool( array < bool > arr )
{
    if ( arr.len() >= 1 ) bool01 = arr[ 0 ]
    if ( arr.len() >= 2 ) bool02 = arr[ 1 ]
    if ( arr.len() >= 3 ) bool03 = arr[ 2 ]
}

void function External_ReMapSetFloat( array < float > arr )
{
    if ( arr.len() >= 1 ) float01 = arr[ 0 ]
    if ( arr.len() >= 2 ) float02 = arr[ 1 ]
    if ( arr.len() >= 3 ) float03 = arr[ 2 ]
    if ( arr.len() >= 4 ) float04 = arr[ 3 ]
    if ( arr.len() >= 5 ) float05 = arr[ 4 ]
    if ( arr.len() >= 6 ) float06 = arr[ 5 ]
    if ( arr.len() >= 7 ) float07 = arr[ 6 ]
    if ( arr.len() >= 8 ) float08 = arr[ 7 ]
    if ( arr.len() >= 9 ) float09 = arr[ 8 ]
}

void function External_ReMapSetInt( array < int > arr )
{
    if ( arr.len() >= 1 ) int01 = arr[ 0 ]
    if ( arr.len() >= 2 ) int02 = arr[ 1 ]
    if ( arr.len() >= 3 ) int03 = arr[ 2 ]
    if ( arr.len() >= 4 ) int04 = arr[ 3 ]
    if ( arr.len() >= 5 ) int05 = arr[ 4 ]
    if ( arr.len() >= 6 ) int06 = arr[ 5 ]
}

void function External_ReMapSetVectorArray01( array< vector > arr )
{
    arrayVec01 = arr
}

void function External_ReMapSetVectorArray02( array< vector > arr )
{
    arrayVec02 = arr
}

void function External_ReMapSetAssetArray01( array< asset > arr )
{
    arrayAsset01 = arr
}

void function External_ReMapCreateZiplineWithSettings()
{
    MapEditor_CreateZiplineFromUnity( origin01, angles01, origin02, angles02, bool01, float01, float02, float03, float04, float05, int01, int02, float06, float07, bool02, int03, bool03, int04, int05, arrayVec01, arrayVec02, arrayAsset01, float08, float09, int06, true )
}

void function External_ReMapRemoveAllEnts()
{
    foreach( entity ent in MapEditorEnts )
    {
        if ( IsValid( ent ) ) ent.Destroy()
    }     

    MapEditorEnts.clear();
}

void function External_ReMapTeleportToMap()
{
    int origin = arrayVec01.len()
    int angles = arrayVec02.len()

    if ( origin != angles ) return

    foreach ( player in GetPlayerArray() )
    {
        int i = RandomIntRange( 0, origin )

        if ( IsValid( player ) )
        {
            player.SetOrigin( arrayVec01[ i ] )
            player.SetAngles( arrayVec02[ i ] )
            player.SetVelocity( < 0, 0, 0 > )
        }
    }
}

void function External_ReMapWritePlayerInfoToFile()
{
    DevTextBufferClear()

    string file = "scripts/player_info.txt"

    DevTextBufferWrite( "origin = " + GetPlayerArray()[0].GetOrigin().tostring() + "\n" )
    DevTextBufferWrite( "angles = " + GetPlayerArray()[0].GetAngles().tostring() )

    DevP4Checkout( file )
    DevTextBufferDumpToFile( file )
}
