global function ClMinimap_Init

global function ClientCodeCallback_MinimapEntitySpawned

global function Minimap_AddCustomLayer

global function RegisterMinimapPackage

global function Minimap_SetSizeScale
global function Minimap_IsUsingLargeMinimap
global function Minimap_SetBlankBackground
global function Minimap_SetNorthFacing
global function Minimap_UpdateNorthFacingOnSettingChange

global function Minimap_RingPulseAtLocation
global function ServerCallback_RingPulseMinimap

global function Minimap_EnableDraw
global function Minimap_DisableDraw

global function Minimap_UpdateMinimapVisibility
global function Minimap_UpdateShowButtonHint

global function Minimap_CommonAdd
global function Minimap_CommonCleanup
global function Minimap_CommonTrackEntOrigin

global function Minimap_SetDeathFieldRadius

global function Fullmap_AddRui
global function Fullmap_RemoveRui
global function Fullmap_SetVisible
global function Fullmap_IsVisible
global function UpdateFullmapRuiTracks
global function GetFullmapGamestateRui

global function SetMinimapBackgroundTileImage
global function GetMinimapBackgroundTileImage

global function SetMapFeatureItem
global function RemoveMapFeatureItemByName
global function Minimap_EnableDraw_Internal
global function Minimap_DisableDraw_Internal
#if DEVELOPER
global function DumpMinimapHandles
#endif

global struct MapFeature
{
	string titleText
	string descDesc
	asset  icon

	int priority
}

struct {
	var minimap_base
	var minimap_frame
	var minimap_coords
	var minimap_wedges

	int activeMinimapObjectCount

	var minimap_you
	var minimap_jammed_layer

	var minimap_indicator

	#if DEVELOPER
		table<int, entity> minimapHandles
	#endif

	array<var> minimapOtherRuis
	table<entity, var> minimapPlayers
	array<var> fullmapRuis

	float threatMaxDist

	bool  minimapDoBlankBackground = false
	float minimapZoomScale = 1
	float minimapSizeScale = 1

	bool minimapEnabled = true
	bool fullmapVisible = false

	entity hack_playerAngleReplacement
	int    minimapDisableDrawStackCount
	asset  minimapBackgroundTileImage

	var        fullmap_legendRui
	array<var> fullmap_unitframesRui
	var        fullmap_gamestateRui

	array< void functionref( var ) > updateFullmapTracking_Callbacks
	array< void functionref( var ) > onFullmapCreated_Callbacks
	var fullmap_challengeBoxRui

	array<MapFeature> mapFeatureList
} file


struct MinmapPackage
{
	asset                           minimapAsset = $""
	void functionref( entity, var ) initFunction
	asset                           fullmapAsset = $""
	void functionref( entity, var ) fullmapInitFunction
}

table<string, array<MinmapPackage> > minimapAssetMap = {}

const int OF_IS_VISIBLE = 1 << 0
const int OF_TEAM_SAME = 1 << 1
const int OF_TEAM_ENEMY = 1 << 2
const int OF_IN_OUR_PARTY = 1 << 3
const int OF_IS_OWNED_BY_US = 1 << 4
const int OF_IS_PLAYER = 1 << 5
const int OF_IS_NPC = 1 << 6
const int OF_IS_TITAN = 1 << 7
const int OF_ORIENT_UP = 1 << 8
const int OF_NO_TEAM_COLOR = 1 << 9


void function RegisterMinimapPackage( string entityClassname, int customStateIndex, asset minimapAsset, void functionref( entity, var ) initFunction, asset fullmapAsset = $"", void functionref( entity, var ) fullmapInitFunction = null )
{
	if(GetCurrentPlaylistVarBool( "r5reloaded_aimtrainer", false )) return

	Assert( (entityClassname in minimapAssetMap), "minimap is not currently setup to handle this type of entity: " + entityClassname )

	MinmapPackage minimapPackage
	minimapPackage.minimapAsset = minimapAsset
	minimapPackage.initFunction = initFunction
	minimapPackage.fullmapAsset = fullmapAsset
	minimapPackage.fullmapInitFunction = fullmapInitFunction

	switch ( entityClassname )
	{
		case "npc_soldier":
		case "npc_spectre":
		case "npc_stalker":
		case "npc_drone":
		case "npc_frag_drone":
		case "npc_super_spectre":
		case "npc_turret_sentry":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_npc.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_npc.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		case "npc_titan":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_npc_titan.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_npc_titan.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		case "prop_script":
		case "item_flag":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_prop_script.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_prop_script.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		case "info_hardpoint":
			Assert( customStateIndex > 0 && customStateIndex < eMinimapObject_info_hardpoint.COUNT )
			minimapAssetMap[entityClassname].resize( eMinimapObject_info_hardpoint.COUNT )
			minimapAssetMap[entityClassname][customStateIndex] = minimapPackage
			break

		default:
			Assert( false, "minimap is not currently setup to handle this type of entity: " + entityClassname )
	}
}


void function RegisterDefaultMinimapPackage( string entityClassname, asset minimapAsset, void functionref( entity, var ) initFunction, asset fullmapAsset = $"", void functionref( entity, var ) fullmapInitFunction = null )
{
	Assert( !(entityClassname in minimapAssetMap) )

	MinmapPackage minimapPackage
	minimapPackage.minimapAsset = minimapAsset
	minimapPackage.initFunction = initFunction
	minimapPackage.fullmapAsset = fullmapAsset
	minimapPackage.fullmapInitFunction = fullmapInitFunction

	minimapAssetMap[entityClassname] <- [minimapPackage]
}


void function ClMinimap_Init()
{
	RegisterDefaultMinimapPackage( "player", MINIMAP_PLAYER_RUI, MinimapPackage_PlayerInit )
	RegisterDefaultMinimapPackage( "npc_titan", MINIMAP_OBJECT_RUI, MinimapPackage_NPCTitanInit )
	RegisterDefaultMinimapPackage( "npc_soldier", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_spectre", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_stalker", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_super_spectre", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_drone_rocket", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_frag_drone", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_drone", MINIMAP_OBJECT_RUI, MinimapPackage_NPCHumanSizedInit )
	RegisterDefaultMinimapPackage( "npc_dropship", MINIMAP_OBJECT_RUI, MinimapPackage_NPCDropShipInit )
	RegisterDefaultMinimapPackage( "npc_turret_sentry", MINIMAP_OBJECT_RUI, MinimapPackage_NPCSentryTurretInit )
	RegisterDefaultMinimapPackage( "prop_script", $"", MinimapPackage_DummyInit )
	RegisterDefaultMinimapPackage( "item_flag", MINIMAP_OBJECT_RUI, MinimapPackage_DummyInit )
	RegisterDefaultMinimapPackage( "item_bomb", MINIMAP_OBJECT_RUI, MinimapPackage_LTSBomb )
	RegisterDefaultMinimapPackage( "info_hardpoint", $"", MinimapPackage_DummyInit )
	RegisterDefaultMinimapPackage( "item_powerup", MINIMAP_OBJECT_RUI, MinimapPackage_PowerUp )

	RegisterMinimapPackage( "npc_titan", eMinimapObject_npc_titan.AT_BOUNTY_BOSS, MINIMAP_OBJECT_RUI, MinimapPackage_BossTitanInit )

	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.AT_DROPZONE_A, MINIMAP_OBJ_AREA_RUI, MinimapPackage_ATAreaInit )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.AT_DROPZONE_B, MINIMAP_OBJ_AREA_RUI, MinimapPackage_ATAreaInit )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.AT_DROPZONE_C, MINIMAP_OBJ_AREA_RUI, MinimapPackage_ATAreaInit )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.AT_BANK, MINIMAP_OBJECT_RUI, MinimapPackage_ATBank )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.FD_HARVESTER, MINIMAP_OBJ_AREA_RUI, MinimapPackage_FDHarvester )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.FD_LOADOUT_CHEST, MINIMAP_OBJ_AREA_RUI, MinimapPackage_FDLoadoutChest )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.FD_BATTERY_EXCHANGE, MINIMAP_OBJ_AREA_RUI, MinimapPackage_FDBatteryExchange )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.BOOST_STORE, MINIMAP_OBJ_AREA_RUI, MinimapPackage_BoostStore )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.ARC_TRAP, MINIMAP_ARC_TRAP_RUI, MinimapPackage_ArcTrap )

	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.TROPHY_SYSTEM, MINIMAP_OBJ_AREA_RUI, MinimapPackage_TrophySystem, FULLMAP_OBJECT_RUI, MinimapPackage_TrophySystem )


	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.DIRTY_BOMB, MINIMAP_OBJECT_RUI, MinimapPackage_DirtyBomb, FULLMAP_OBJECT_RUI, MinimapPackage_DirtyBomb )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.CRYPTO_DRONE, MINIMAP_OBJECT_RUI, MinimapPackage_CryptoDrone, FULLMAP_OBJECT_RUI, MinimapPackage_CryptoDrone )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.DEPLOYABLE_MEDIC, MINIMAP_OBJECT_RUI, MinimapPackage_DeployableMedic )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.PHASE_GATE, MINIMAP_OBJECT_RUI, MinimapPackage_PhaseGate )

	//RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.FW_CAMP_A, MINIMAP_FW_CAMP_RUI, MinimapPackage_FWCampA )
	//RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.FW_CAMP_B, MINIMAP_FW_CAMP_RUI, MinimapPackage_FWCampB )
	//RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.FW_CAMP_C, MINIMAP_FW_CAMP_RUI, MinimapPackage_FWCampC )

	RegisterMinimapPackage( "info_hardpoint", eMinimapObject_info_hardpoint.HARDPOINT_A, MINIMAP_OBJ_AREA_RUI, MinimapPackage_HardpointA )
	RegisterMinimapPackage( "info_hardpoint", eMinimapObject_info_hardpoint.HARDPOINT_B, MINIMAP_OBJ_AREA_RUI, MinimapPackage_HardpointB )
	RegisterMinimapPackage( "info_hardpoint", eMinimapObject_info_hardpoint.HARDPOINT_C, MINIMAP_OBJ_AREA_RUI, MinimapPackage_HardpointC )

	//if ( IsPlayingDemo() )
	{
		RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SPAWNZONE_IMC, MINIMAP_OBJ_AREA_RUI, MinimapPackage_SpawnZoneAreaInit )
		RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SPAWNZONE_MIL, MINIMAP_OBJ_AREA_RUI, MinimapPackage_SpawnZoneAreaInit )
	}
	//else
	//{
	//	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SPAWNZONE_IMC, $"", MinimapPackage_SpawnZoneAreaInit )
	//	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.SPAWNZONE_MIL, $"", MinimapPackage_SpawnZoneAreaInit )
	//}
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.LTS_SITE_A, MINIMAP_OBJECT_RUI, MinimapPackage_LTSBombSiteA )
	RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.LTS_SITE_B, MINIMAP_OBJECT_RUI, MinimapPackage_LTSBombSiteB )
	/*
	{
		MinmapPackage atAreaPacakage
		atAreaPacakage.minimapAsset = MINIMAP_OBJ_AREA_RUI
		atAreaPacakage.initFunction = MinimapPackage_ATAreaInit
		MinmapPackage spawnZonePacakage
		spawnZonePacakage.minimapAsset = MINIMAP_OBJ_AREA_RUI
		spawnZonePacakage.initFunction = MinimapPackage_SpawnZoneAreaInit
		MinmapPackage fwBuildSitePackage
		fwBuildSitePackage.minimapAsset = MINIMAP_FW_BUILD_SITE_RUI
		fwBuildSitePackage.initFunction = MinimapPackage_FWBuildSite
		MinmapPackage fwCampAPackage
		fwCampAPackage.minimapAsset = MINIMAP_FW_CAMP_RUI
		fwCampAPackage.initFunction = MinimapPackage_FWCampA
		MinmapPackage fwCampBPackage
		fwCampBPackage.minimapAsset = MINIMAP_FW_CAMP_RUI
		fwCampBPackage.initFunction = MinimapPackage_FWCampB
		MinmapPackage fwCampCPackage
		fwCampCPackage.minimapAsset = MINIMAP_FW_CAMP_RUI
		fwCampCPackage.initFunction = MinimapPackage_FWCampC
		minimapAssetMap["prop_script"] <- [blankPackage, atAreaPacakage, atAreaPacakage, atAreaPacakage, spawnZonePacakage, spawnZonePacakage,
											fwCampAPackage, fwCampBPackage, fwCampCPackage,
											fwBuildSitePackage, fwBuildSitePackage, fwBuildSitePackage ]
	}
*/

	AddCreateCallback( "player", OnPlayerCreate )
	AddTargetNameCreateCallback( "deathField", MinimapDeathFieldCreated )
	AddCallback_OnPlayerChangedTeam( Minimap_OnPlayerTeamChanged )
	RegisterSignal( "TeamChanged" )

	float threatMaxDist  = Minimap_GetFloatForKey( "threatMaxDist" )
	float threatDistNear = Minimap_GetFloatForKey( "threatNearDist" )
	float threatDistFar  = Minimap_GetFloatForKey( "threatFarDist" )

	file.threatMaxDist = max( threatMaxDist, 1800 )

	file.minimap_base = CreateMinimapRui( MINIMAP_BASE_RUI, MINIMAP_Z_BASE )
	file.minimap_frame = CreateMinimapRui( MINIMAP_FRAME_RUI, MINIMAP_Z_FRAME )

	RuiSetFloat( file.minimap_base, "minimapSizeScale", file.minimapSizeScale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", file.minimapSizeScale )

	if ( GetCurrentPlaylistVarBool( "beta_watermark", false ) == true )
	{
		file.minimap_coords = CreateMinimapRui( MINIMAP_UID_COORDS_RUI, MINIMAP_Z_BASE + 1000 )
	}

	file.minimap_you = CreateMinimapRui( MINIMAP_YOU_RUI, MINIMAP_Z_YOU )

	RuiSetFloat( file.minimap_you, "minimapSizeScale", file.minimapSizeScale )

	file.minimap_jammed_layer = null

	RegisterSignal( "LoopRadarJammerSounds" )

	AddCinematicEventFlagChangedCallback( CE_FLAG_INTRO, CinematicEventFlagChanged )

	AddFirstPersonSpectateStartedCallback( OnSpectateChanged )
	AddFirstPersonSpectateEndedCallback( OnSpectateChanged )
	AddOnSpectatorTargetChangedCallback( OnSpectateTargetChanged )

	StatusEffect_RegisterEnabledCallback( eStatusEffect.minimap_jammed, MinimapJammed_Enabled )
	StatusEffect_RegisterDisabledCallback( eStatusEffect.minimap_jammed, MinimapJammed_Disabled )

	file.fullmap_legendRui = RuiCreate( $"ui/map_legend.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 )
	InitHUDRui( file.fullmap_legendRui, false )
	Fullmap_AddRui( file.fullmap_legendRui )

	// file.fullmap_challengeBoxRui = RuiCreate( $"ui/minimap_challenge_box.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, RUI_SORT_SCREENFADE - 1 )
	//
	// InitHUDRui( file.fullmap_challengeBoxRui, false )
	// Fullmap_AddRui( file.fullmap_challengeBoxRui )

	// create unitframe ruis for the fullmap screen
	// Taking off one of these to save memory. If we ever need to go above a 3 person team, add it back.
	//file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
	file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
	file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
	file.fullmap_unitframesRui.append( RuiCreate( $"ui/unitframe_survival_v3.rpak", clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 ) )
	foreach( rui in file.fullmap_unitframesRui )
	{
		InitHUDRui( rui, false )
		Fullmap_AddRui( rui )
	}

	asset fullmap_gamestateRuiAsset = GetFullmapGameStateAsset()
	file.fullmap_gamestateRui = RuiCreate( fullmap_gamestateRuiAsset, clGlobal.topoFullscreenFullMap, FULLMAP_RUI_DRAW_LAYER, 20 )
	InitHUDRui( file.fullmap_gamestateRui, false )
	Fullmap_AddRui( file.fullmap_gamestateRui )
	foreach( func in file.onFullmapCreated_Callbacks )
		func( file.fullmap_gamestateRui )
}


void function OnSpectateChanged( entity spectatingPlayer, entity spectatorTarget )
{
}


void function OnSpectateTargetChanged( entity spectatingPlayer, entity oldSpectatorTarget, entity newSpectatorTarget )
{	
	UpdatePlayerRuiTracking( spectatingPlayer )
}


var function CreateMinimapRui( asset ruiAsset, int sortKey = 0 )
{
	var rui = RuiCreate( ruiAsset, clGlobal.topoFullscreenHudPermanent, GetHudDrawGroup(), sortKey )
	InitHUDRui( rui, true )
	return rui
}

#if DEVELOPER
void function DumpMinimapHandles()
{
	int index = 0
	foreach ( handle, ent in file.minimapHandles )
	{
		printt( index, handle, ent )
		++index
	}
}
#endif // DEVELOPER

void function ClientCodeCallback_MinimapEntitySpawned( entity ent )
{
	foreach ( callbackFunc in clGlobal.onMinimapEntSpawnedCallbacks )
		callbackFunc( ent )

	if ( ent == GetLocalViewPlayer() )
		return

	thread AddMinimapObject( ent )
}


void function MinimapDeathFieldCreated( entity ent )
{
	var rui = file.minimap_base
	RuiTrackFloat3( rui, "deathFieldOrigin", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiSetFloat( rui, "radiusScale", SURVIVAL_MINIMAP_RING_SCALE )
	Minimap_SetDeathFieldRadius( SURVIVAL_GetDeathFieldCurrentRadius() )
	RuiSetBool( rui, "drawDeathField", true )
}


void function Minimap_SetDeathFieldRadius( float radius )
{
	RuiSetFloat( file.minimap_base, "deathFieldRadius", radius / SURVIVAL_MINIMAP_RING_SCALE )
}


asset function GetMinimapAsset( string className, int customState )
{
	if ( !(className in minimapAssetMap) )
		return $""

	if ( customState > minimapAssetMap[className].len() - 1 )
		return $""

	return minimapAssetMap[className][customState].minimapAsset
}


asset function GetFullmapAsset( string className, int customState )
{
	if ( !(className in minimapAssetMap) )
		return $""

	if ( customState > minimapAssetMap[className].len() - 1 )
		return $""

	return minimapAssetMap[className][customState].fullmapAsset
}


asset function GetMinimapBackgroundTileImage()
{
	//return $"overviews/mp_rr_canyonlands_64k_x_64k_bg_tile"
	return file.minimapBackgroundTileImage
}


void function SetMinimapBackgroundTileImage( asset image )
{
	file.minimapBackgroundTileImage = image
}


void function AddMinimapObject( entity ent )
//TODO: If we want radar jammer boost to hide friendly players we need to be able to get the rui handles back.
{
	Assert( IsValid( ent ) )

	string className = expect string( ent.GetNetworkedClassName() )
	int customState  = ent.Minimap_GetCustomState()

	asset minimapAsset = GetMinimapAsset( className, customState )
	if ( minimapAsset == $"" )
	{
		return
	}

	#if DEVELOPER
		int eHandle = ent.GetEncodedEHandle()

		{
			array<int> eHandlesToRemove
			foreach ( eHandleIter, entIter in file.minimapHandles )
			{
				if ( !IsValid( entIter ) )
				{
					eHandlesToRemove.append( eHandleIter )
				}
			}

			foreach ( eHandleIter in eHandlesToRemove )
			{
				delete file.minimapHandles[eHandleIter]
			}
		}

		if ( eHandle in file.minimapHandles )
		{
			Assert( IsValid( file.minimapHandles[eHandle] ) ) // Should have been removed in above loop

			Warning( "AddMinimapObject - Duplicate minimap entity: " + ent )
			return
		}

		file.minimapHandles[eHandle] <- ent
	#endif

	entity viewPlayer = GetLocalViewPlayer()

	ent.SetDoDestroyCallback( true )
	ent.EndSignal( "OnDestroy" )

	table<string, var> e

	OnThreadEnd(
		function() : ( e, minimapAsset )
		{
			if ( "rui" in e )
			{
				var rui = e["rui"]
				if ( rui != null )
				{
					RemovePlayerMinimapRui( rui )
					file.minimapOtherRuis.removebyvalue( rui )
					RuiDestroy( rui )
				}
			}
			if ( "rui" in e )
			{
				var rui = e["fullRui"]
				if ( rui != null )
				{
					Fullmap_RemoveRui( rui )
					RuiDestroy( rui )
				}
			}
		}
	)

	while ( IsValid( ent ) )
	{
		if ( !("rui" in e) && IsValid( viewPlayer ) && ShouldCreateRuiForPlayer( ent, viewPlayer ) )
		{
			e["rui"] <- CreateMinimapRuiForEnt( ent, viewPlayer, minimapAsset )
			e["fullRui"] <- CreateFullmapRuiForEnt( ent, viewPlayer )
			break
		}
		waitthread WaitForEntUpdate( ent, viewPlayer )
	}

	WaitForever()
}


void function WaitForEntUpdate( entity ent, entity viewPlayer )
{
	EndSignal( ent, "SettingsChanged", "OnDeath", "TeamChanged" )

	EndSignal( viewPlayer, "SettingsChanged", "OnDeath", "TeamChanged" )

	WaitForever()
}


var function CreateFullmapRuiForEnt( entity ent, entity viewPlayer )
{
	int customState    = ent.Minimap_GetCustomState()
	string className   = expect string( ent.GetNetworkedClassName() )
	asset minimapAsset = GetFullmapAsset( className, customState )

	if ( minimapAsset == $"" )
		return null

	int zOrder = ent.Minimap_GetZOrder()
	var rui    = FullMap_CommonAdd( minimapAsset, zOrder )
	FullMap_CommonTrackEntOrigin( rui, ent, false )

	RuiTrackFloat2( rui, "zoomPos", null, RUI_TRACK_BIG_MAP_ZOOM_ANCHOR )
	RuiTrackFloat( rui, "zoomFactor", null, RUI_TRACK_BIG_MAP_ZOOM_SCALE )

	RuiTrackFloat3( rui, "objectPos", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "objectAngles", ent, RUI_TRACK_EYEANGLES_FOLLOW )
	RuiTrackInt( rui, "objectFlags", ent, RUI_TRACK_MINIMAP_FLAGS )
	RuiTrackInt( rui, "customState", ent, RUI_TRACK_MINIMAP_CUSTOM_STATE )

	RuiSetFloat( rui, "iconBlend", 1.0 )
	RuiSetFloat( rui, "iconPremul", 0.0 )
	RuiSetFloat2( rui, "iconScale", <1.0, 1.0, 0.0> )

	Fullmap_RunInitFunction( ent, rui )

	Fullmap_AddRui( rui )

	return rui
}


var function CreateMinimapRuiForEnt( entity ent, entity viewPlayer, asset minimapAsset )
{
	int zOrder = ent.Minimap_GetZOrder()
	var rui    = CreateMinimapRui( minimapAsset, MINIMAP_Z_BASE + zOrder )

	//RuiTrackGameTime( rui, "lastFireTime", ent, RUI_TRACK_LAST_FIRED_TIME )

	Minimap_RuiSetPlayerData( rui )

	RuiTrackFloat3( rui, "objectPos", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "objectAngles", ent, RUI_TRACK_EYEANGLES_FOLLOW )
	RuiTrackInt( rui, "objectFlags", ent, RUI_TRACK_MINIMAP_FLAGS )
	RuiTrackInt( rui, "customState", ent, RUI_TRACK_MINIMAP_CUSTOM_STATE )
	RuiSetFloat( rui, "displayDist", file.threatMaxDist )
	RuiTrackFloat( rui, "minimapZoomScale", viewPlayer, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( rui, "minimapSizeScale", file.minimapSizeScale )
	RuiSetBool( rui, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )

	Minimap_RunInitFunction( ent, rui )

	file.minimapOtherRuis.append( rui )

	RuiSetVisible( rui, file.minimapEnabled )

	return rui
}


void function Fullmap_RunInitFunction( entity ent, var rui )
{
	string className = expect string( ent.GetNetworkedClassName() )
	int customState  = ent.Minimap_GetCustomState()

	if ( minimapAssetMap[className][customState].fullmapInitFunction != null )
		minimapAssetMap[className][customState].fullmapInitFunction( ent, rui )
}


void function Minimap_RunInitFunction( entity ent, var rui )
{
	string className = expect string( ent.GetNetworkedClassName() )
	int customState  = ent.Minimap_GetCustomState()
	minimapAssetMap[className][customState].initFunction( ent, rui )
}


bool function ShouldCreateRuiForPlayer( entity ent, entity viewPlayer )
{
	foreach ( callbackFunc in clGlobal.onMinimapEntShouldCreateCallbacks )
	{
		if ( !callbackFunc( ent ) )
			return false
	}
	return true
}


var function Minimap_CommonAdd( asset ruiAsset, int zOrder )
{
	entity viewPlayer = GetLocalViewPlayer()
	var rui           = CreateMinimapRui( ruiAsset, MINIMAP_Z_BASE + zOrder )

	Minimap_RuiSetPlayerData( rui )

	RuiSetFloat( rui, "displayDist", file.threatMaxDist )
	RuiTrackFloat( rui, "minimapZoomScale", viewPlayer, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( rui, "minimapSizeScale", file.minimapSizeScale )
	RuiSetBool( rui, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )

	RuiSetFloat3( rui, "objectPos", <0, 0, 0> )
	RuiSetFloat3( rui, "objectAngles", <0, 0, 0> )

	//
	RuiSetVisible( rui, file.minimapEnabled )
	file.minimapOtherRuis.append( rui )
	return rui
}


void function Minimap_CommonCleanup( var rui )
{
	file.minimapOtherRuis.removebyvalue( rui )
	ReleaseHUDRui( rui )
	RuiDestroy( rui )
}


void function Minimap_CommonTrackEntOrigin( var rui, entity ent, bool doTrackAngles )
{
	RuiTrackFloat3( rui, "objectPos", ent, RUI_TRACK_ABSORIGIN_FOLLOW )
	if ( doTrackAngles )
		RuiTrackFloat3( rui, "objectAngles", ent, RUI_TRACK_EYEANGLES_FOLLOW )
}


var function Minimap_RingPulse( float radius, vector color, float pulseDuration, float lifeTime, bool reverse )
{
	var rui = Minimap_CommonAdd( MINIMAP_RING_PULSE_RUI, MINIMAP_Z_OBJECTIVE )

	RuiSetFloat3( rui, "objColor", SrgbToLinear( color ) )
	RuiSetFloat( rui, "objectRadius", radius / file.threatMaxDist )
	RuiSetBool( rui, "scalesWithZoom", false )

	RuiSetGameTime( rui, "startTime", Time() )
	if ( lifeTime > 0 )
		RuiSetFloat( rui, "lifeTime", lifeTime )
	RuiSetFloat( rui, "pulseDuration", pulseDuration )

	RuiSetBool( rui, "reverse", reverse )

	RuiSetImage( rui, "marker", $"" )

	if ( lifeTime > 0 )
		thread Minimap_RingPulseCleanup( rui, lifeTime )

	return rui
}


var function Minimap_RingPulseAtLocation( vector origin, float radius, vector color, float pulseDuration, float lifeTime = -1, bool reverse = false )
{
	var rui = Minimap_RingPulse( radius, color, pulseDuration, lifeTime, reverse )
	RuiSetFloat3( rui, "objectPos", origin )
	RuiSetFloat3( rui, "objectAngles", <0, 0, 0> )
	return rui
}


void function Minimap_RingPulseCleanup( var rui, float lifeTime )
{
	if ( lifeTime > 0 )
		wait lifeTime

	file.minimapOtherRuis.fastremovebyvalue( rui )
	RuiDestroy( rui )
}


var function Minimap_AddCustomLayer( asset ruiAsset, int sortKey = MINIMAP_Z_LAYER )
{
	entity player = GetLocalViewPlayer()

	var rui = CreateMinimapRui( ruiAsset, sortKey )

	RuiTrackFloat3( rui, "playerPos", player, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "playerAngles", player, RUI_TRACK_CAMANGLES_FOLLOW )

	asset mapImage       = Minimap_GetAssetForKey( "minimap" )
	float mapCornerX     = Minimap_GetFloatForKey( "pos_x" )
	float mapCornerY     = Minimap_GetFloatForKey( "pos_y" )
	float displayDist    = Minimap_GetFloatForKey( "displayDist" )
	float threatDistNear = Minimap_GetFloatForKey( "threatNearDist" )
	float threatDistFar  = Minimap_GetFloatForKey( "threatFarDist" )

	float mapScale = Minimap_GetFloatForKey( "scale" )

	RuiSetFloat3( rui, "mapCorner", <mapCornerX, mapCornerY, 0> )
	RuiSetFloat( rui, "displayDist", file.threatMaxDist )
	RuiSetFloat( rui, "mapScale", mapScale )
	RuiTrackFloat( rui, "minimapZoomScale", player, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( rui, "minimapSizeScale", file.minimapSizeScale )

	return rui
}


void function OnPlayerCreate( entity player )
{
	entity viewPlayer = GetLocalViewPlayer()
	if ( IsValid( viewPlayer ) && viewPlayer.GetTeam() == player.GetTeam() )
		UpdateFullmapRuiTracks()

	if ( player != GetLocalClientPlayer() )
		return

	if ( file.minimap_coords != null )
	{
		RuiTrackFloat3( file.minimap_coords, "playerPos", player, RUI_TRACK_ABSORIGIN_FOLLOW )
		string uidString = GetConVarString( "platform_user_id" )
		if ( IsOdd( uidString.len() ) )
			uidString = "0" + uidString
		int uidLength     = uidString.len()
		int uidHalfLength = uidLength / 2
		string uidPart1   = uidString.slice( 0, uidHalfLength )
		string uidPart2   = uidString.slice( uidHalfLength, uidLength )
		Assert( uidPart1.len() == uidPart2.len() )

		string fakeHexUidString = ""
		for ( int i = 0 ; i < uidString.len() ; i++ )
		{
			string n = uidString.slice( i, i + 1 )
			switch( n )
			{
				case "0":
					n = "0"
					break

				case "1":
					n = "1"
					break

				case "2":
					n = "2"
					break

				case "3":
					n = "3"
					break

				case "4":
					n = "a"
					break

				case "5":
					n = "b"
					break

				case "6":
					n = "c"
					break

				case "7":
					n = "d"
					break

				case "8":
					n = "e"
					break

				case "9":
					n = "f"
					break
			}
			fakeHexUidString += n
		}

		RuiSetString( file.minimap_coords, "uid", " " )
		RuiSetInt( file.minimap_coords, "uidPart1", 0 ) // int( uidPart1 )
		RuiSetInt( file.minimap_coords, "uidPart2", 0 ) // int( uidPart2 )
		RuiTrackString( file.minimap_coords, "name", GetLocalClientPlayer(), RUI_TRACK_PLAYER_NAME_STRING )
	}

	asset mapImage       = Minimap_GetAssetForKey( "minimap" )
	float mapCornerX     = Minimap_GetFloatForKey( "pos_x" )
	float mapCornerY     = Minimap_GetFloatForKey( "pos_y" )
	float displayDist    = Minimap_GetFloatForKey( "displayDist" )
	float threatDistNear = Minimap_GetFloatForKey( "threatNearDist" )
	float threatDistFar  = Minimap_GetFloatForKey( "threatFarDist" )

	float mapScale = Minimap_GetFloatForKey( "scale" )

	if ( file.minimapDoBlankBackground )
	{
		RuiSetImage( file.minimap_base, "mapImage", $"" )
	}
	else
	{
		RuiSetImage( file.minimap_base, "mapImage", mapImage )
		RuiSetImage( file.minimap_base, "mapBgTileImage", GetMinimapBackgroundTileImage() )
	}

	RuiSetFloat3( file.minimap_base, "mapCorner", <mapCornerX, mapCornerY, 0> )
	RuiSetFloat( file.minimap_base, "displayDist", file.threatMaxDist )
	RuiSetFloat( file.minimap_base, "mapScale", mapScale )
	RuiSetBool( file.minimap_base, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )
	RuiSetFloat( file.minimap_base, "minimapSizeScale", file.minimapSizeScale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", file.minimapSizeScale )
	RuiSetBool( file.minimap_you, "isNorthFacing", !GetConVarBool( "hud_setting_minimapRotate" ) )

	UpdatePlayerRuiTracking( player )
}


void function Minimap_OnPlayerTeamChanged( entity player, int oldTeam, int newTeam )
{
	if ( oldTeam != newTeam )
		player.Signal( "TeamChanged" )
}

void function UpdatePlayerRuiTracking( entity player )
{
	Assert( player == GetLocalClientPlayer() )

	entity viewPlayer = GetLocalViewPlayer()

	RuiTrackFloat3( file.minimap_base, "playerPos", viewPlayer, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( file.minimap_base, "playerAngles", viewPlayer, RUI_TRACK_CAMANGLES_FOLLOW )
	RuiTrackFloat( file.minimap_base, "minimapZoomScale", player, RUI_TRACK_MINIMAP_ZOOM_SCALE )
	RuiSetFloat( file.minimap_base, "minimapSizeScale", file.minimapSizeScale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", file.minimapSizeScale )

	RuiTrackFloat( file.minimap_you, "minimapZoomScale", viewPlayer, RUI_TRACK_MINIMAP_ZOOM_SCALE )

	RuiTrackInt( file.minimap_you, "objectFlags", viewPlayer, RUI_TRACK_MINIMAP_FLAGS )
	RuiTrackInt( file.minimap_you, "customState", viewPlayer, RUI_TRACK_MINIMAP_CUSTOM_STATE )
	RuiTrackFloat3( file.minimap_you, "playerAngles", viewPlayer, RUI_TRACK_CAMANGLES_FOLLOW )
	//#if MP_PVEMODE // In r5r, MP_PVEMODE part is not compiled and must be commented out
		RuiTrackInt( file.minimap_you, "teamMemberIndex", viewPlayer, RUI_TRACK_PLAYER_TEAM_MEMBER_INDEX )
	//#endif                 

	foreach ( var rui in file.minimapOtherRuis )
	{
		Minimap_RuiSetPlayerData( rui )
	}
}

void function Minimap_SetPlayerColorOverride( entity player, vector color )
{
	var rui = null
	if( player == GetLocalClientPlayer() )
		rui = file.minimap_you
	else if( player in file.minimapPlayers )
		rui = file.minimapPlayers[player]

	if( rui == null )
		return

	RuiSetFloat3( rui, "iconColorOverride", color  )
}


void function MinimapPackage_DummyInit( entity ent, var rui )
{
}


void function MinimapPackage_PlayerInit( entity ent, var rui )
{
	RuiTrackGameTime( rui, "lastFireTime", ent, RUI_TRACK_LAST_FIRED_TIME )
	if ( Is2TeamPvPGame() ) //JFS: Too much work to get FFA to work correctly with Minimap logic, so disabling it for FFA
	{
		RuiTrackFloat( rui, "sonarDetectedFrac", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.sonar_detected )
		RuiTrackFloat( rui, "maphackDetectedFrac", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.maphack_detected )
	}
	//#if MP_PVEMODE // In r5r, MP_PVEMODE part is not compiled and must be commented out
		RuiTrackInt( rui, "teamMemberIndex", ent, RUI_TRACK_PLAYER_TEAM_MEMBER_INDEX )
	//#endif

	RuiSetInt( rui, "squadIDLocalPlayer", GetLocalViewPlayer().GetSquadID() )
	RuiTrackInt( rui, "squadID", ent, RUI_TRACK_SQUADID )

	if ( IsFriendlyTeam( ent.GetTeam(), GetLocalViewPlayer().GetTeam() ) && ent.GetTeam() != GetLocalViewPlayer().GetTeam() )
	{
		RuiSetFloat3( rui, "iconColorOverride", (GetKeyColor( COLORID_FRIENDLY ) / 255.0)  )
		RuiSetBool( rui, "shouldOverrideClampedIcon", true )
		RuiSetFloat2( rui, "iconScaleOverride", <0.65, 0.65, 0.0> )

	}

	if( !(ent in file.minimapPlayers ) )
		file.minimapPlayers[ent] <- rui
}

void function RemovePlayerMinimapRui( var ruiToRemove )
{
	entity keyToRemove = null
	foreach( player, rui in file.minimapPlayers )
	{
		if( rui == ruiToRemove )
		{
			keyToRemove = player
			break
		}
	}

	if( keyToRemove != null )
		delete file.minimapPlayers[ keyToRemove ]
}


void function MinimapPackage_NPCTitanInit( entity ent, var rui )
{
	entity player = GetLocalClientPlayer()

	RuiSetBool( rui, "useTeamColor", false )

	RuiTrackGameTime( rui, "lastFireTime", ent, RUI_TRACK_LAST_FIRED_TIME )
	if ( Is2TeamPvPGame() )  //JFS: Too much work to get FFA to work correctly with Minimap logic, so disabling it for FFA
		RuiTrackFloat( rui, "sonarDetectedFrac", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.sonar_detected )

}
void function MinimapPackage_VehicleInit( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/minimap/compass_icon_small_dot" )

	if ( IsFriendlyTeam( ent.GetTeam(), GetLocalViewPlayer().GetTeam() ) )
		RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/minimap/compass_icon_small_dot" )
	else
		RuiSetImage( rui, "clampedDefaultIcon", $"" )

	RuiSetFloat( rui, "sonarDetectedFrac", 1.0 )
	RuiSetFloat2( rui, "iconScale", <2.0, 2.0, 0.0> )

	if ( ent.VehicleGetPlayerArray().contains( GetLocalViewPlayer() ) )
	{
		RuiSetFloat3( rui, "iconColor", SrgbToLinear( TEAM_COLOR_YOU / 255.0 ) )
		RuiSetBool( rui, "useTeamColor", false )
	}
}


void function MinimapPackage_NPCHumanSizedInit( entity ent, var rui )
{
	entity player = GetLocalClientPlayer()

	RuiSetImage( rui, "defaultIcon", $"rui/hud/minimap/compass_icon_small_dot" )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )

	//if ( ent == GetLocalClientPlayer().GetPetTitan() )
	//{
	//	RuiSetBool( rui, "useTeamColor", false )
	//	RuiSetFloat3( rui, "iconColor", TEAM_COLOR_YOU / 255.0 )
	//}
	RuiTrackGameTime( rui, "lastFireTime", ent, RUI_TRACK_LAST_FIRED_TIME )
	//if ( Is2TeamPvPGame() )  //JFS: Too much work to get FFA to work correctly with Minimap logic, so disabling it for FFA
	//	RuiTrackFloat( rui, "sonarDetectedFrac", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.sonar_detected )
}


void function MinimapPackage_NPCDropShipInit( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/scoreboard/status_evac" )
}


void function MinimapPackage_NPCSentryTurretInit( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"" )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )
}


void function MinimapPackage_BossTitanInit( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/bounty_hunt/bh_titan" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/bounty_hunt/bh_titan" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_BatteryInit( entity ent, var rui )
{
	entity player = GetLocalViewPlayer()
	RuiTrackInt( rui, "batteryCount", player, RUI_TRACK_SCRIPT_NETWORK_VAR_INT, GetNetworkedVariableIndex( "batteryCount" ) )
	RuiSetBool( rui, "useTeamColor", false )
	RuiTrackFloat( rui, "batteryCarried", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.battery_carried )
}


void function MinimapPackage_ATAreaInit( entity ent, var rui )
{
	RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_ATBank( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/bounty_hunt/bh_bank_icon" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/bounty_hunt/bh_bank_icon" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_SpawnZoneAreaInit( entity ent, var rui )
{
	RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
	if ( !IsPlayingDemo() )
	{
		RuiSetImage( rui, "centerImage", $"" ) // hide diamond
		RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/obj_foreground_diamond" )
	}
}


void function MinimapPackage_FWBuildSite( entity ent, var rui )
{
	entity player = GetLocalViewPlayer()
	RuiTrackInt( rui, "batteryCount", player, RUI_TRACK_SCRIPT_NETWORK_VAR_INT, GetNetworkedVariableIndex( "batteryCount" ) )
	//RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_HardpointA( entity ent, var rui )
{
	RuiSetFloat( rui, "objectRadius", 0.001 )
}


void function MinimapPackage_HardpointB( entity ent, var rui )
{
	RuiSetFloat( rui, "objectRadius", 0.001 )
}


void function MinimapPackage_HardpointC( entity ent, var rui )
{
	RuiSetFloat( rui, "objectRadius", 0.001 )
}


void function MinimapPackage_FDHarvester( entity ent, var rui )
{
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/fd/coop_harvester" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/fd/coop_harvester" )
	RuiSetFloat( rui, "objectRadius", 0.01 )
	RuiSetBool( rui, "useOverrideColor", true )
	RuiSetColorAlpha( rui, "overrideColor", <1, 1, 1>, 1.0 )
}


void function MinimapPackage_FDLoadoutChest( entity ent, var rui )
{
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/fd/coop_ammo_locker_icon" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/fd/coop_ammo_locker_icon" )
	RuiSetFloat( rui, "objectRadius", 0.01 )
	RuiSetBool( rui, "useOverrideColor", true )
	RuiSetColorAlpha( rui, "overrideColor", <1, 1, 1>, 1.0 )
}


void function MinimapPackage_FDBatteryExchange( entity ent, var rui )
{
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/bounty_hunt/bh_bank_icon" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/bounty_hunt/bh_bank_icon" )
	RuiSetFloat( rui, "objectRadius", 0.01 )
	RuiSetBool( rui, "useOverrideColor", true )
	RuiSetColorAlpha( rui, "overrideColor", <1, 1, 1>, 1.0 )
}


void function MinimapPackage_BoostStore( entity ent, var rui )
{
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/bounty_hunt/bh_bonus_icon" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/bounty_hunt/bh_bonus_icon" )
	RuiSetFloat( rui, "objectRadius", 0.01 )
	RuiSetBool( rui, "useOverrideColor", true )
	RuiSetColorAlpha( rui, "overrideColor", <1, 1, 1>, 1.0 )
}


void function MinimapPackage_MortarPosition( entity ent, var rui )
{
	RuiSetImage( rui, "bgImage", $"rui/hud/gametype_icons/fd/fd_icon_spectre_mortar_bg" )
	RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/fd/fd_icon_spectre_mortar" )
	RuiSetImage( rui, "clampedImage", $"rui/hud/gametype_icons/fd/fd_icon_spectre_mortar" )
	RuiTrackFloat( rui, "arcPercent", ent, RUI_TRACK_SHIELD_FRACTION )
}


void function MinimapPackage_ArcTrap( entity ent, var rui )
{
	RegisterTeslaTrapMinimapRui( ent, rui )
}


void function MinimapPackage_TrophySystem( entity ent, var rui )
{
	// RuiSetImage( rui, "centerImage", $"rui/hud/gametype_icons/survival/wattson_ult_map_icon" )
	// RuiSetImage( rui, "clampedImage", $"" )
	// RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )

	RuiSetImage( rui, "defaultIcon", $"rui/hud/ultimate_icons/ultimate_wattson_in_world" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/ultimate_icons/ultimate_wattson_in_world" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}


void function MinimapPackage_DirtyBomb( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/tactical_icons/tactical_caustic" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/tactical_icons/tactical_caustic" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}

void function MinimapPackage_CryptoDrone( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/tactical_icons/tactical_crypto" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/tactical_icons/tactical_crypto" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat( rui, "iconBlend", 0.0 )
}

void function MinimapPackage_DeployableMedic( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/deployable_icons/deployable_medic_icon" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/deployable_icons/deployable_medic_icon" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_PhaseGate( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/pilot_loadout/tactical/pilot_tactical_phase_shift" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/pilot_loadout/tactical/pilot_tactical_phase_shift" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_FWCampA( entity ent, var rui )
{
	RuiTrackInt( rui, "alertLevel", null, RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT, GetNetworkedVariableIndex( "fwCampAlertA" ) )
	RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_FWCampB( entity ent, var rui )
{
	RuiTrackInt( rui, "alertLevel", null, RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT, GetNetworkedVariableIndex( "fwCampAlertB" ) )
	RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_FWCampC( entity ent, var rui )
{
	RuiTrackInt( rui, "alertLevel", null, RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT, GetNetworkedVariableIndex( "fwCampAlertC" ) )
	RuiTrackFloat( rui, "objectRadius", ent, RUI_TRACK_MINIMAP_SCALE )
}


void function MinimapPackage_LTSBombSiteA( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_site_a_attacking" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_site_a_attacking" )
}


void function MinimapPackage_LTSBombSiteB( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_site_b_attacking" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_site_b_attacking" )
}


void function MinimapPackage_LTSBomb( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_neutral" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/last_titan_standing/bomb_neutral" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapPackage_FlagInit( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"rui/hud/gametype_icons/ctf/ctf_flag_neutral" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/gametype_icons/ctf/ctf_flag_neutral" )
	RuiSetBool( rui, "useTeamColor", true )
}


void function MinimapPackage_PowerUp( entity ent, var rui )
{
	//Battery spawners are the only power ups in use atm. This would need to be updated if we use them differently.
	RuiSetImage( rui, "defaultIcon", $"rui/hud/battery/battery_capture_friendly" )
	RuiSetImage( rui, "clampedDefaultIcon", $"rui/hud/battery/battery_capture_friendly" )
	RuiSetBool( rui, "useTeamColor", false )
}


void function MinimapJammed_Enabled( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if ( ent != GetLocalClientPlayer() )
		return

	thread LoopRadarJammerSounds( ent )
	thread FadeOutStaticSoundAfterDelay( ent, BURN_METER_RADAR_JAMMER_PULSE_DURATION - BURN_METER_RADAR_JAMMER_EASE_OFF_TIME )

	if ( file.minimap_jammed_layer != null )
		RuiDestroy( file.minimap_jammed_layer )

	file.minimap_jammed_layer = Minimap_AddCustomLayer( MINIMAP_JAMMER_LAYER_RUI, MINIMAP_Z_YOU + 1 )

	if ( file.minimap_jammed_layer != null )
	{
		if ( actuallyChanged )
			RuiSetGameTime( file.minimap_jammed_layer, "startTime", Time() )

		RuiTrackFloat( file.minimap_jammed_layer, "minimapZoomScale", ent, RUI_TRACK_MINIMAP_ZOOM_SCALE )
		RuiSetFloat( file.minimap_jammed_layer, "minimapSizeScale", file.minimapSizeScale )
		RuiTrackFloat( file.minimap_jammed_layer, "scriptAlphaVar", ent, RUI_TRACK_STATUS_EFFECT_SEVERITY, statusEffect )
	}
}


void function MinimapJammed_Disabled( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if ( ent != GetLocalClientPlayer() )
		return

	clGlobal.levelEnt.Signal( "LoopRadarJammerSounds" )

	if ( file.minimap_jammed_layer != null )
	{
		RuiDestroy( file.minimap_jammed_layer )
		file.minimap_jammed_layer = null
	}
}


void function LoopRadarJammerSounds( entity ent )
{
	clGlobal.levelEnt.Signal( "LoopRadarJammerSounds" )
	clGlobal.levelEnt.EndSignal( "LoopRadarJammerSounds" )
	ent.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( ent )
		{
			StopSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_RedTextBeep_1P" )
		}
	)

	float currentTime         = Time()
	float fractionalComponent = currentTime - floor( currentTime )
	float timeToWait
	if ( fractionalComponent <= 0.5 )
		timeToWait = 0.5 - fractionalComponent
	else
		timeToWait = 1.5 - fractionalComponent

	wait timeToWait //Red text flashes in with regards to game time, so we need to wait till the appropriate time (0.5) to play the next sound

	while ( true )
	{
		if ( IsValid( ent ) )
			EmitSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_RedTextBeep_1P" )

		wait 1.0 //This is dependent on the rui logic, and will need to be changed if the rui logic changes
	}
}


void function FadeOutStaticSoundAfterDelay( entity ent, float delay )
{
	EmitSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_Signal_Static_1P" )

	ent.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( ent )
		{
			clGlobal.levelEnt.Signal( "LoopRadarJammerSounds" ) //stop red text beeping sounds
			if ( IsValid( ent ) )
				StopSoundOnEntity( ent, "HUD_Boost_Card_Radar_Jammer_Signal_Static_1P" )
		}
	)
	wait delay
}


void function Minimap_SetBlankBackground( bool doBlank )
{
	file.minimapDoBlankBackground = doBlank
}


void function Minimap_SetSizeScale( float scale )
{
	if(GetCurrentPlaylistVarBool( "r5reloaded_aimtrainer", false )) return

	file.minimapSizeScale = scale

	RuiSetFloat( file.minimap_base, "minimapSizeScale", scale )
	RuiSetFloat( file.minimap_frame, "minimapSizeScale", scale )
	RuiSetFloat( file.minimap_you, "minimapSizeScale", scale )
	if ( file.minimap_coords != null )
		RuiSetFloat( file.minimap_coords, "minimapSizeScale", scale )
	
	try{
		foreach ( var rui in file.minimapOtherRuis )
		{
			RuiSetFloat( rui, "minimapSizeScale", scale )
		}

		var gameStateRui = ClGameState_GetRui()
		if ( gameStateRui )
			RuiSetFloat( gameStateRui, "minimapSizeScale", scale )
	}catch(e420){}
}


bool function Minimap_IsUsingLargeMinimap()
{
	return file.minimapSizeScale > 1.0
}


void function ServerCallback_RingPulseMinimap( vector origin, float radius, float duration, int pulseCount, vector color, bool reverse )
{
	float pulseDuration = duration / pulseCount
	float lifeTime      = duration

	Minimap_RingPulseAtLocation( origin, radius, color, pulseDuration, lifeTime, reverse )
}


void function CinematicEventFlagChanged( entity player )
{
	Minimap_UpdateMinimapVisibility( player )
}


bool function MiniMapIsDisabled()
{
	if ( GetCurrentPlaylistVarBool( "disable_minimap", false ) )
		return true
	return false
}


void function Minimap_UpdateMinimapVisibility( entity player )
{
	if ( !IsValid( player ) )
	{
		Minimap_DisableDraw_Internal()
		return
	}

	bool isVisible = true

	int ceFlags = player.GetCinematicEventFlags()
	if ( ceFlags & CE_FLAG_INTRO )
		isVisible = false
	                                                    
	  	                 

	if ( MiniMapIsDisabled() )
		isVisible = false

	if ( GetGameState() == eGameState.WaitingForPlayers || GetGameState() == eGameState.PickLoadout )
		isVisible = false

	if ( file.minimapDisableDrawStackCount > 0 )
		isVisible = false

	if ( isVisible )
		Minimap_EnableDraw_Internal()
	else
		Minimap_DisableDraw_Internal()
}


void function Minimap_DisableDraw()
{
	file.minimapDisableDrawStackCount++
	Minimap_UpdateMinimapVisibility( GetLocalViewPlayer() )
}


void function Minimap_EnableDraw()
{
	file.minimapDisableDrawStackCount--
	Assert( file.minimapDisableDrawStackCount >= 0, "Called Minimap_EnableDraw() but minimap wasn't disabled!" )

	Minimap_UpdateMinimapVisibility( GetLocalViewPlayer() )
}


void function Minimap_DisableDraw_Internal()
{
	if(GetCurrentPlaylistVarBool( "r5reloaded_aimtrainer", false )) return

	file.minimapEnabled = false

	RuiSetVisible( file.minimap_base, false )
	RuiSetVisible( file.minimap_frame, false )
	RuiSetVisible( file.minimap_you, false )

	foreach ( var rui in file.minimapOtherRuis )
	{
		try
		{
			RuiSetVisible( rui, false )
		}catch(e420)
		{
			file.minimapOtherRuis.removebyvalue(rui)
		}
	}
}


void function Minimap_EnableDraw_Internal()
{
	if(GetCurrentPlaylistVarBool( "r5reloaded_aimtrainer", false )) return

	file.minimapEnabled = true

	RuiSetVisible( file.minimap_base, true )
	RuiSetVisible( file.minimap_frame, true )
	RuiSetVisible( file.minimap_you, true )

	foreach ( var rui in file.minimapOtherRuis )
	{
		RuiSetVisible( rui, true )
	}
}


void function Minimap_SetNorthFacing( bool northFacing )
{
	RuiSetBool( file.minimap_base, "isNorthFacing", northFacing )
	RuiSetBool( file.minimap_you, "isNorthFacing", northFacing )

	foreach ( var rui in file.minimapOtherRuis )
	{
		RuiSetBool( rui, "isNorthFacing", northFacing )
	}
}


void function Minimap_UpdateShowButtonHint()
{
	if ( file.minimap_base != null )
		RuiSetBool( file.minimap_base, "showButtonHints", ShouldShowButtonHints() )
}


void function Minimap_RuiSetPlayerData( var rui )
{
	entity viewPlayer = GetLocalViewPlayer()
	if ( IsValid( file.hack_playerAngleReplacement ) )
		viewPlayer = file.hack_playerAngleReplacement

	RuiTrackFloat3( rui, "playerPos", viewPlayer, RUI_TRACK_ABSORIGIN_FOLLOW )
	RuiTrackFloat3( rui, "playerAngles", viewPlayer, RUI_TRACK_CAMANGLES_FOLLOW )
}


void function Fullmap_AddRui( var rui )
{
	file.fullmapRuis.append( rui )
	RuiSetVisible( rui, Fullmap_IsVisible() )
}


void function Fullmap_RemoveRui( var rui )
{
	file.fullmapRuis.removebyvalue( rui )
}


void function Fullmap_SetVisible( bool state )
{
	FullMap_UpdateTopologies()
	UpdateSurveyBeaconHint() // TODO: meh
	UpdateMapFeatures()
	UpdateCameraVisibility()

	Fullmap_SetVisible_MapOnly( state )

	FullMap_UpdateAimPos()

}

void function Fullmap_SetVisible_MapOnly( bool state )
{
	foreach ( rui in file.fullmapRuis )
	{
		RuiSetVisible( rui, state )
	}
	file.fullmapVisible = state

}

bool function Fullmap_IsVisible()
{
	return file.fullmapVisible
}





void function UpdateFullmapRuiTracks()
{
	if ( IsLobby() )
		return

	entity viewPlayer = GetLocalViewPlayer()
	entity clientPlayer = GetLocalClientPlayer()
	if ( !IsValid( viewPlayer ) )
		return

	if ( file.fullmap_unitframesRui.len() == 0 )
	{
		Warning( FUNC_NAME() + " - fullmap_unitframesRui is empty." )
		return
	}

	                                               

	var viewPlayerRui = file.fullmap_unitframesRui[0]
	thread SetUnitFrameDataFromOwner( viewPlayerRui, viewPlayer, true )
	UpdateEquipmentSlot( viewPlayer, viewPlayerRui )

	RuiSetInt( viewPlayerRui, "frameSlot", -1 )

                    
                                                                                                                                                           
       

	if ( IsValid( clientPlayer ) )
	{
		int observerMode = clientPlayer.GetObserverMode()
		if ( clientPlayer.GetTeam() == TEAM_SPECTATOR && ( observerMode == OBS_MODE_ROAMING || observerMode == OBS_MODE_CHASE ) )
		{
			RuiSetBool( viewPlayerRui, "isVisible", false )
		}
                 
		else
		{
			RuiSetBool( viewPlayerRui, "isVisible", !IsFallLTM() )
		}
      
	}

	for ( int i = 1; i < file.fullmap_unitframesRui.len(); i++ )
	{
		var rui = file.fullmap_unitframesRui[i]
		RuiSetBool( rui, "isVisible", false )    // hide if no matching player

		int slotIndex     = i - 1
		entity teamMember = UnitFrame_GetOwnerByIndex( slotIndex )
		if ( !IsValid( teamMember ) )
		{
			if ( teamMember != null )
			{
				// disconnected
				RuiSetBool( rui, "isVisible", true )
				RuiSetBool( rui, "disconnected", true )
				RuiSetFloat( rui, "reviveEndTime", 0.0 )
				RuiSetFloat( rui, "bleedoutEndTime", 0.0 )
				RuiSetBool( rui, "isJumpmaster", false )
				RuiSetInt( rui, "frameSlot", slotIndex )
			}
			continue
		}

		thread SetUnitFrameDataFromOwner( rui, teamMember, true )
		UpdateEquipmentSlot( teamMember, rui )

		RuiSetInt( rui, "frameSlot", slotIndex )

		RuiSetBool( rui, "isVisible", !IsFallLTM() )
	}

	// set gamestate rui tracks
	UpdateCommonScoreRuiTracking( file.fullmap_gamestateRui, viewPlayer )
	ScorebarInitTracking( viewPlayer, file.fullmap_gamestateRui )
	SetCommonScoreRUIVars( file.fullmap_gamestateRui )

	bool gamestateIsPlaying = GamePlaying()
	RuiSetBool( file.fullmap_gamestateRui, "gamestateIsPlaying", gamestateIsPlaying )

	UISize screenSize        = GetScreenSize()
	float clampedAspectRatio = GetNearestAspectRatio( screenSize.width, screenSize.height )
	bool isAspectRatio16x10  = clampedAspectRatio == 1.6
	// RuiSetBool( file.fullmap_challengeBoxRui, "isAspectRatio16x10", isAspectRatio16x10 )

	// if ( IsLocalClientEHIValid() ) // TODO:
	// 	UpdateChallengeBoxRows( 5, file.fullmap_challengeBoxRui )

	RuiTrackBool( file.fullmap_legendRui, "pingEnabled", viewPlayer, RUI_TRACK_SCRIPT_NETWORK_VAR_BOOL, GetNetworkedVariableIndex( "pingEnabled" ) )

	// set circle data
	int roundNumber = SURVIVAL_GetCurrentDeathFieldStage() + 1
	if ( roundNumber < 1 )
		return

	float circleStartTime = GetGlobalNetTime( "nextCircleStartTime" )
	RuiSetGameTime( file.fullmap_gamestateRui, "circleStartTime", circleStartTime )

	float circleCloseTime = GetGlobalNetTime( "circleCloseTime" )
	RuiSetGameTime( file.fullmap_gamestateRui, "circleCloseTime", circleCloseTime )

	RuiSetInt( file.fullmap_gamestateRui, "roundNumber", roundNumber )

	string roundString = Localize( "#SURVIVAL_CIRCLE_STATUS_ROUND_CLOSING", roundNumber )
	if ( SURVIVAL_IsFinalDeathFieldStage() )
		roundString = Localize( "#SURVIVAL_CIRCLE_STATUS_ROUND_CLOSING_FINAL" )
	RuiSetString( file.fullmap_gamestateRui, "roundClosingString", roundString )


	int currentDeathFieldStage = SURVIVAL_GetCurrentDeathFieldStage()
	if ( currentDeathFieldStage > -1 )
	{
		DeathFieldStageData data = GetDeathFieldStage( currentDeathFieldStage )
		float currentRadius      = SURVIVAL_GetDeathFieldCurrentRadius()
		float endRadius          = data.endRadius

		RuiSetFloat( file.fullmap_gamestateRui, "deathfieldStartRadius", currentRadius )
		RuiSetFloat( file.fullmap_gamestateRui, "deathfieldEndRadius", endRadius )
	}

	RuiTrackFloat3( file.fullmap_gamestateRui, "playerOrigin", viewPlayer, RUI_TRACK_ABSORIGIN_FOLLOW )

	//#if MP_PVEMODE // In r5r, MP_PVEMODE part is not compiled and must be commented out
		RuiTrackInt( file.fullmap_gamestateRui, "teamMemberIndex", viewPlayer, RUI_TRACK_PLAYER_TEAM_MEMBER_INDEX )
	//#endif

	foreach( func in file.updateFullmapTracking_Callbacks )
		func( file.fullmap_gamestateRui )
}


void function UpdateEquipmentSlot( entity player, var rui )
{
	foreach ( equipSlot, es in EquipmentSlot_GetAllEquipmentSlots() )
	{
		if ( es.trackingNetInt != "" )
		{
			LootData data = EquipmentSlot_GetEquippedLootDataForSlot( player, equipSlot )
			int tier      = data.tier
			asset hudIcon = tier > 0 ? data.hudIcon : es.emptyImage

			if(equipSlot == "armor" && player.GetShieldHealthMax() > 100)
					RuiSetInt( rui, es.unitFrameTierVar, 5 )
				else
					RuiSetInt( rui, es.unitFrameTierVar, tier )
			RuiSetImage( rui, es.unitFrameImageVar, hudIcon )
		}
	}
}


var function GetFullmapGamestateRui()
{
	return file.fullmap_gamestateRui
}


void function Fullmap_AddCallback_UpdateTracking( void functionref( var ) func )
{
	file.updateFullmapTracking_Callbacks.append( func )
}


void function Fullmap_AddCallback_OnFullmapCreated( void functionref( var ) func )
{
	file.onFullmapCreated_Callbacks.append( func )
}


void function RemoveMapFeatureItemByName( string titleText )
{
	foreach ( mapFeature in file.mapFeatureList )
	{
		if ( mapFeature.titleText != titleText )
			continue

		file.mapFeatureList.fastremovebyvalue( mapFeature )
		return
	}
}


MapFeature function SetMapFeatureItem( int priority, string titleText, string descText, asset icon )
{
	MapFeature mapFeature

	mapFeature.priority = priority
	mapFeature.titleText = titleText
	mapFeature.descDesc = descText
	mapFeature.icon = icon

	// prevent dupes, allow reprioritization
	RemoveMapFeatureItemByName( titleText )

	file.mapFeatureList.append( mapFeature )
	file.mapFeatureList.sort( int function( MapFeature a, MapFeature b )
	{
		if ( a.priority > b.priority )
			return -1
		if ( b.priority > a.priority )
			return 1

		return 0
	} )

	UpdateMapFeatures()

	return mapFeature
}


const int MAX_MAP_FEATURES = 5
void function UpdateMapFeatures()
{
	if ( GameRules_GetGameMode() != SURVIVAL )
		return
	
	if ( file.fullmap_legendRui == null )
		return

	for ( int index = 0; index < MAX_MAP_FEATURES; index++ )
	{
		string featurePostfix = string( index + 1 )
		MapFeature mapFeature

		if ( index < file.mapFeatureList.len() )
			mapFeature = file.mapFeatureList[index]

		RuiSetString( file.fullmap_legendRui, "itemTitle" + featurePostfix, mapFeature.titleText )
		RuiSetString( file.fullmap_legendRui, "itemDesc" + featurePostfix, mapFeature.descDesc )
		RuiSetImage( file.fullmap_legendRui, "itemIcon" + featurePostfix, mapFeature.icon )
	}
}


void function Minimap_UpdateNorthFacingOnSettingChange()
{
	if ( file.minimap_base && file.minimap_you )
		Minimap_SetNorthFacing( !GetConVarBool( "hud_setting_minimapRotate" ) )
}