/*
Todo:
-Make clients see the picking player skin, not their own skin
-Don't interrupt ready-up anims unless we have to (it's your turn to pick, or the next player locked in)
*/

#if SERVER
const bool DEBUG_LOCK_STEP_PICK = true //Todo: switch off in print/debug nuke before release
#endif
#if CLIENT
const bool DEBUG_CHARACTER_SELECT = false
#endif

const asset BACKGROUND_SMOKE_MODEL = $"mdl/levels_terrain/mp_lobby/mp_character_select_smoke.rmdl" // 1.2
const asset BACKGROUND_GEO_MODEL = $"mdl/rocks/desertlands_victory_platform.rmdl"
const asset BACKGROUND_GEO_MODEL_KC = $"mdl/rocks/victory_platform.rmdl"
const asset BACKGROUND_GEO_MODEL_LEGACY   = $"mdl/levels_terrain/mp_lobby/mp_character_select_geo.rmdl"

#if SERVER
global function AssignLockStepOrder
global function CharacterSelect_AssignCharacter
#endif

#if UI
global function UI_InitCharacterSelectNewMenu
global function UI_RunCharacterSelect
global function UI_RunCharacterSelect_AimTrainer
global function UI_CloseCharacterSelect
global function ClientToUI_UpdateSquadMute
#endif

#if CLIENT
global function OpenCharacterSelectNewMenu
global function OpenCharacterSelectAimTrainer
global function DoSquadCardsPresentation
global function DoAnimatedSquadCardsPresentation
global function DoChampionSquadCardsPresentation
global function DoAnimatedChampionSquadCardsPresentation
global function _OpenCharacterSelectNewMenu
global function _OpenCharacterSelectNewMenu_AimTrainer
global function CloseCharacterSelectNewMenu
global function CloseCharacterSelectNewMenu_AimTrainer
global function OnCharacterSelectNewMenuClosed_RemoveCallbacks
global function UpdateMenuElementHandles
global function Client_TryUnlockCharacter
global function ServerCallback_CharacterLockRejected
global function OnLoadoutButton_RightClick
global function UpdateCharacterDetailsMenu
global function GetOtherTeammates
global function SquadMuteLegendSelectEnabled

global function AddCallback_OnCharacterSelectMenuOpened
global function AddCallback_OnCharacterSelectMenuClosed
global function AddCallback_CharacterSelectMenu_OnCharacterFocused
global function AddCallback_CharacterSelectMenu_OnCharacterLocked

global function CharacterSelect_SetMenuState

const string CAMERA_ENT_NAME = "target_char_sel_camera_new"
const string CHARACTER_ENT_NAME = "target_char_sel_pilot_new"
const string BACKGROUND_ENT_NAME = "target_char_sel_bg_new"
const string LIGHT_KEY_NAME = "char_sel_light_key"
const string LIGHT_FILL_NAME = "char_sel_light_fill"
const string LIGHT_RIML_NAME = "char_sel_light_rim_l"
const string LIGHT_RIMR_NAME = "char_sel_light_rim_r"

const CAMERA_FOV = 50
const CAMERA_FOV_LEGACY = 35.5
const CAMERA_TRANSITION_DURATION = 0.25
const MAIN_DOF_NEAR_START = 7.5
const MAIN_DOF_NEAR_END = 7.7
const MAIN_DOF_FAR_START = 225.0
const MAIN_DOF_FAR_END = 450.0
const RUI_NAME_PLATE_WIDTH = 262
const RUI_NAME_PLATE_HEIGHT = 110
const COLOR_CORRECTION = "materials/correction/menu.raw_hdr"
const int NUM_CHARACTER_SELECT_BUTTONS = 30
const int MAX_TEAM_FOCUS_INDEX = 3
const float READY_ANIM_MIN_DURATION = 4.0
const int CHAMPION_SQAUD_SMOKE_SKIN_INDEX = 9
const int CHAMPION_SQAUD_BACKGROUND_SKIN_INDEX = 9


global enum eNewCharacterSelectMenuState
{
	COUNTDOWN,
	PICKING,
	LOCKED,
}

#endif

#if SERVER || CLIENT
global function CharacterSelectNewMenu_Init
#endif

#if UI
global function Gamemode1v1_CloseLegendMenu

struct FileForeverStruct
{
	var menu
}
FileForeverStruct& fileForever
#endif

struct FileLevelStruct
{
	bool isBrowseMode = false
	float isBrowseModeStartTime

	#if SERVER || CLIENT
		bool menuEntsExist = false
	#endif

	#if SERVER
		bool assignedLockStepOrder = false
	#endif

	#if CLIENT
		bool lightEntsExist = false

		bool detailsPanelVisible = false

		var        menu
		var        whiteFlash
		var        portraitsPanel
		var        detailsPanel
		var        detailsRui
		var        buttonHintPanel
		var        buttonHintRui
		array<var> characterButtons
		array<var> characterButtonRuis
		int        colorCorrection

		int localClientLockstepIndex

		entity camera
		entity characterModel
		entity characterNode
		entity characterNodeMover
		entity keyLight
		entity fillLight
		entity rimLightL
		entity rimLightR
		bool dontdestroy
		entity backgroundModelSmoke
		entity backgroundModelGeo

		var                              backgroundRuiTopo
		var                              backgroundRui
		var                              countdownRui
		array<var>                       ruiPlayerBarRuis
		array<var>                       gCardRuiHandles
		array<NestedGladiatorCardHandle> nestedGladiatorCardHandles

		table<int, ItemFlavor> buttonIndexCharacterMap
		array<int>             buttonIndexUsed
		array<int>             lockedButtonIndexies

		ItemFlavor ornull desiredCharacterOrNull = null
		//ItemFlavor ornull lastLockedCharacterOrNull = null
		entity            lastLockedPlayer
		int               desiredMenuState = eNewCharacterSelectMenuState.PICKING
		table             signalDummy
		float             lockSequenceAnimTime = 0.0

		table<int, string> connectedPlayerNames

		table<var, bool> buttonEventHandlersAdded_Click
		table<var, bool> buttonEventHandlersAdded_Focus

		bool menuEntsReady = false

		int championEHI = -1
		int championSquad1EHI = -1
		int championSquad2EHI = -1

		bool isUpdatePlayerModelRunning = false
	#endif
}
FileLevelStruct& fileLevel

struct SquadIntroCameraPackage
{
	vector camera_offset_start
	vector camera_offset_end
	vector camera_focus_offset
	float camera_fov
}

struct {
	array< void functionref() > Callbacks_OnCharacterMenuOpened
	array< void functionref() > Callbacks_OnCharacterMenuClosed
	array< void functionref(ItemFlavor) > Callbacks_OnCharacterFocused
	array< void functionref(ItemFlavor) > Callbacks_OnCharacterLocked

	array<entity> cleanupEnts
	array<var> overHeadRuis
} file

//  ██╗███╗   ██╗██╗████████╗
//  ██║████╗  ██║██║╚══██╔══╝
//  ██║██╔██╗ ██║██║   ██║
//  ██║██║╚██╗██║██║   ██║
//  ██║██║ ╚████║██║   ██║
//  ╚═╝╚═╝  ╚═══╝╚═╝   ╚═╝

#if UI
void function UI_InitCharacterSelectNewMenu( var newMenuArg )
{
	fileForever.menu = GetMenu( "CharacterSelectMenuNew" )

	AddMenuEventHandler( fileForever.menu, eUIEvent.MENU_NAVIGATE_BACK, UI_OnCharacterSelectMenu_NavBack )

	AddMenuFooterOption( fileForever.menu, RIGHT, BUTTON_X, true, "", "", UI_OnLoadoutButton_RightClick ) //
	AddMenuFooterOption( fileForever.menu, RIGHT, MOUSE_RIGHT, true, "", "", UI_OnLoadoutButton_RightClick ) //

	AddMenuFooterOption( fileForever.menu, RIGHT, BUTTON_Y, true, "", "", UI_OnToggleMuteButtonClick, UI_ShouldShowToggleMuteFooter ) //
	AddMenuFooterOption( fileForever.menu, RIGHT, KEY_F, true, "", "", UI_OnToggleMuteButtonClick, UI_ShouldShowToggleMuteFooter ) //

	AddMenuEventHandler( fileForever.menu, eUIEvent.MENU_CLOSE, void function() {
		RunClientScript( "OnCharacterSelectNewMenuClosed_RemoveCallbacks" )
	} )

	#if PC_PROG
		AddMenuFooterOption( fileForever.menu, RIGHT, KEY_ENTER, true, "", "", UI_OnLoadoutButton_Enter )
	#endif
}

bool function UI_ShouldShowToggleMuteFooter()
{
	return IsFullyConnected() ? SquadMuteLegendSelectEnabled() : false
}

void function UI_OnLoadoutButton_Enter( var button )
{
	if(fileLevel.isBrowseMode) return
		
	var chatbox = Hud_GetChild( fileForever.menu, "LobbyChatBox" )

	if ( !HudChat_HasAnyMessageModeStoppedRecently() )
		Hud_StartMessageMode( chatbox )

	Hud_SetVisible( chatbox, true )
}

void function UI_OnLoadoutButton_RightClick( var button )
{
	if ( CanRunClientScript() )
		RunClientScript( "OnLoadoutButton_RightClick" )
}


void function UI_OnToggleMuteButtonClick( var button )
{
	if ( CanRunClientScript() )
		RunClientScript( "UIToClient_ToggleMute" )
}

void function ClientToUI_UpdateSquadMute( bool muteState )
{

}
#endif

#if SERVER || CLIENT
void function CharacterSelectNewMenu_Init()
{
	if (FS_ShouldShowCustomCharacterSelect())
	{
		if ( MapName() == eMaps.mp_rr_desertlands_64k_x_64k || MapName() == eMaps.mp_rr_desertlands_64k_x_64k_nx || MapName() == eMaps.mp_rr_desertlands_holiday )
		{
			PrecacheModel( BACKGROUND_GEO_MODEL )
		}
		else if( MapName() == eMaps.mp_rr_canyonlands_mu1 || MapName() == eMaps.mp_rr_canyonlands_mu1_night || MapName() == eMaps.mp_rr_canyonlands_64k_x_64k || MapName() == eMaps.mp_rr_canyonlands_staging )
		{
			PrecacheModel( BACKGROUND_GEO_MODEL_KC)
		}
	} else {
		PrecacheModel( BACKGROUND_GEO_MODEL_LEGACY)
	}
	PrecacheModel( BACKGROUND_SMOKE_MODEL )

	#if SERVER
		AddCallback_OnClientConnected( CharacterSelect_OnClientConnected )
		AddClientCommandCallback( "UpdateCharacterSelectFocus", ClientCommand_UpdateCharacterSelectFocus )
		AddClientCommandCallback( "Sur_UpdateCharacterLock", ClientCommand_UpdateCharacterLock )
	#endif

	#if CLIENT
		RegisterSignal( "UpdateScene" )
		RegisterSignal( "UpdatingModel" )
		RegisterSignal( "PlayerModelUpdated" )
		RegisterSignal( "UpdatingAnim" )
		RegisterSignal( "CharacterSelectClosing" )
		RegisterSignal( "LocalPlayerPickingSounds" )
		RegisterSignal( "CloseCharacterSelectMenuAtTime" )

		RegisterNetworkedVariableChangeCallback_int( "characterSelectLockstepIndex", OnLockStepPickIndexChanged )
		RegisterNetworkedVariableChangeCallback_time( "characterSelectLockstepStartTime", OnLockStepPickStartTimeChanged )
		RegisterNetworkedVariableChangeCallback_bool( "hasLockedInCharacter", OnPlayerUpdatedCharacterLock )
		RegisterNetworkedVariableChangeCallback_int( "characterSelectLockstepPlayerIndex", OnLockStepPlayerIndexChanged )
		RegisterNetworkedVariableChangeCallback_int( "characterSelectFocusIndex", OnPlayerUpdatedCharacterFocus )

		AddCallback_FullUpdate( Client_FullUpdate )
		AddCallback_UIScriptReset( Client_UIScriptReset )
		if ( SquadMuteLegendSelectEnabled() )
			AddCallback_OnSquadMuteChanged( Client_MuteChanged )

		fileLevel.colorCorrection = ColorCorrection_Register( COLOR_CORRECTION )
	#endif
}
#endif


//	 ██████╗ ██████╗ ███████╗███╗   ██╗     ██████╗██╗      ██████╗ ███████╗███████╗
//	██╔═══██╗██╔══██╗██╔════╝████╗  ██║    ██╔════╝██║     ██╔═══██╗██╔════╝██╔════╝
//	██║   ██║██████╔╝█████╗  ██╔██╗ ██║    ██║     ██║     ██║   ██║███████╗█████╗
//	██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║    ██║     ██║     ██║   ██║╚════██║██╔══╝
//	╚██████╔╝██║     ███████╗██║ ╚████║    ╚██████╗███████╗╚██████╔╝███████║███████╗
//	 ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝     ╚═════╝╚══════╝ ╚═════╝ ╚══════╝╚══════╝

#if CLIENT
void function OpenCharacterSelectNewMenu( bool isBrowseMode = false )
{
	fileLevel.isBrowseMode = isBrowseMode
	fileLevel.isBrowseModeStartTime = Time()

	fileLevel.menuEntsExist = DoMenuEntsExist()
	fileLevel.lightEntsExist = DoMenuLightsExist()
	fileLevel.detailsPanelVisible = isBrowseMode

	NotifyCharacterSelectBeginEnd( true )
	RunUIScript( "UI_RunCharacterSelect", fileLevel.isBrowseMode, fileLevel.menuEntsExist )

	foreach ( func in file.Callbacks_OnCharacterMenuOpened )
		func()
}

void function OpenCharacterSelectAimTrainer( bool isBrowseMode = false )
{
	fileLevel.isBrowseMode = isBrowseMode
	fileLevel.isBrowseModeStartTime = Time()

	fileLevel.menuEntsExist = true
	fileLevel.lightEntsExist = DoMenuLightsExist()
	fileLevel.detailsPanelVisible = isBrowseMode

	RunUIScript( "UI_RunCharacterSelect_AimTrainer", fileLevel.isBrowseMode, fileLevel.menuEntsExist )
	
	foreach ( func in file.Callbacks_OnCharacterMenuOpened )
		func()
}
#endif

#if UI
void function UI_RunCharacterSelect_AimTrainer( bool isBrowseMode, bool menuEntsExist )
{
	CloseAllMenus()

	fileLevel.isBrowseMode = isBrowseMode
	fileLevel.isBrowseModeStartTime = Time()
	
	if ( !CanRunClientScript() )
		return

	RunClientScript( "_OpenCharacterSelectNewMenu_AimTrainer", fileForever.menu )
	SetBlurEnabled( false )
	FlashGameWindow()
	AdvanceMenu( fileForever.menu )
}
#endif

#if CLIENT
void function _OpenCharacterSelectNewMenu_AimTrainer( var menu )
{
	UpdateMenuElementHandles_AimTrainer( menu )

	// thread FlashScreenWhite()
	// thread DoIntroAimTrainer()
	
	fileLevel.localClientLockstepIndex = GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )

	CreateCharacterSelectClientEnts()
	UpdateCamera()

	fileLevel.menuEntsReady = true

	UpdateMenuButtons()

	thread UpdateSceneThink_AimTrainer()
	
	fileLevel.desiredCharacterOrNull = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterClass() )
	SetMenuState( eNewCharacterSelectMenuState.LOCKED )
	
	if ( fileLevel.isBrowseMode )
	{
		ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterClass() )
		int buttonIndex = GetButtonIndexForCharacter( character )
		if ( buttonIndex >= 0)
		{
			EmitSoundOnEntity( GetLocalClientPlayer(), "ui_menu_focus_legendselectscreen" )
			UpdateForFocusOnButtonIndex( buttonIndex )
		}
	}
	{
		if ( Gamemode() == eGamemodes.WINTEREXPRESS )
		{
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterClass(), OnTeammateLoadoutSelectionChanged, false )
			foreach( ItemFlavor character in GetAllCharacters() )
			{
				LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
				AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( skinSlot, OnTeammateLoadoutSelectionChanged, false )
			}
		}
	}
}

void function DoIntroAimTrainer()
{
	wait ScreenCoverTransition( Time() + 1 )	
}

void function AddCallback_OnCharacterSelectMenuOpened( void functionref() callbackFunc )
{
	file.Callbacks_OnCharacterMenuOpened.append( callbackFunc )
}

void function AddCallback_CharacterSelectMenu_OnCharacterFocused( void functionref(ItemFlavor) callbackFunc )
{
	file.Callbacks_OnCharacterFocused.append( callbackFunc )
}

void function AddCallback_CharacterSelectMenu_OnCharacterLocked( void functionref(ItemFlavor) callbackFunc )
{
	file.Callbacks_OnCharacterLocked.append( callbackFunc )
}

void function AddCallback_OnCharacterSelectMenuClosed( void functionref() callbackFunc )
{
	file.Callbacks_OnCharacterMenuClosed.append( callbackFunc )
}

void function PanAwayCharacterSelect()
{
	RunUIScript( "UI_CloseCharacterSelect" )

	fileLevel.nestedGladiatorCardHandles.clear()
	fileLevel.gCardRuiHandles.clear()

	RuiSetFloat( fileLevel.backgroundRui, "gcardsStartTime", Time() )
	fileLevel.detailsPanelVisible = false
	UpdateButtonStates()

	float outroSceneChangeDuration = CharSelect_GetOutroSceneChangeDuration()
	fileLevel.characterNodeMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", fileLevel.camera.GetOrigin(), fileLevel.camera.GetAngles() )
	fileLevel.characterNode.SetParent( fileLevel.characterNodeMover, "", true )
	fileLevel.characterNodeMover.NonPhysicsRotateTo( fileLevel.characterNodeMover.GetAngles() + <0, 135, 0>, outroSceneChangeDuration, 1.0, 1.0 )

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_LegendPanLeft" )

	wait (outroSceneChangeDuration / 3.0)

	if( IsValid( fileLevel.characterModel ) ) //Temp hack, why pan away stopped working? Cafe
		fileLevel.characterModel.Hide()

	NotifyCharacterSelectBeginEnd( false )
}

void function Client_MuteChanged()
{
	UpdateButtonStates()
}

void function DoSquadCardsPresentation()
{
	foreach( func in file.Callbacks_OnCharacterMenuClosed )
		func()

	#if DEVELOPER
		printt( "CHARACTER SELECT: DoSquadCardsPresentation" )
	#endif

	if ( !IsValid( fileLevel.camera ) )
		return

	// Pan away character select menu and model
	waitthread PanAwayCharacterSelect()

	array<float> offsets = [-1.0, 0.0, 1.0]
	if ( MAX_TEAM_PLAYERS == 1 )
		offsets = [0.0]
	if ( MAX_TEAM_PLAYERS == 2 )
		offsets = [-0.5, 0.5]

	array<entity> teammates = GetPlayerSquad()
	ArrayRemoveInvalid( teammates )
	foreach( entity teammate in teammates )
	{
		int index = teammate.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )
		if ( index < 0 )
			continue

		if ( index >= offsets.len() )
			break

		// Gladiator Card
		var gladCardsRui = CreateFullscreenRui( $"ui/round_end_squad_member_gcard.rpak", -100 )
		fileLevel.gCardRuiHandles.append( gladCardsRui )
		NestedGladiatorCardHandle nestedGCHandle = CreateNestedGladiatorCard( gladCardsRui, "card", eGladCardDisplaySituation.GAME_INTRO_MY_SQUAD_ANIMATED, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( nestedGCHandle, ToEHI( teammate ), null, eGladCardLifestateOverride.ALIVE )
		RuiSetFloat( gladCardsRui, "offset", offsets[index] )
		fileLevel.nestedGladiatorCardHandles.append( nestedGCHandle )

		// Name
		var playerStatsRui = CreateFullscreenPostFXRui( $"ui/round_end_squad_member_stats.rpak", 2 )
		fileLevel.gCardRuiHandles.append( playerStatsRui )
		RuiSetFloat( playerStatsRui, "offset", offsets[index] )
		RuiSetBool( playerStatsRui, "showStats", false )
		RuiSetString( playerStatsRui, "playerName", teammate.GetPlayerName() )
		RuiSetFloat( playerStatsRui, "playerNameFontScale", 2.0 )
		RuiTrackInt( playerStatsRui, "micStatus", teammate, RUI_TRACK_MIC_STATUS )


		if ( teammate == GetLocalViewPlayer() )
		{
			LoadoutEntry characterSlot = Loadout_CharacterClass()
			ItemFlavor character       = LoadoutSlot_GetItemFlavor( ToEHI( teammate ), characterSlot )
			SetChromaCharacter( character )
		}
	}

	// Border around screen
	var borderRui = CreateFullscreenPostFXRui( $"ui/round_end_squads_border.rpak", 3 )
	RuiSetInt( borderRui, "placementNum", -1 )
	RuiSetInt( borderRui, "placementOutOf", -1 )
	RuiSetInt( borderRui, "squadKills", -1 )
	if ( IsSoloMode() )
		RuiSetString( borderRui, "headerText", "#SOLO_HEADER_YOU_SELECTION" )
	else
		RuiSetString( borderRui, "headerText", "#SQUAD_HEADER_YOUR_SQUAD" )

	for ( int index = 0 ; index < 4 ; index++ )
	{
		if ( index < teammates.len() )
		{
			RuiSetString( borderRui, "playerName" + (index + 1), teammates[index].GetPlayerName() )
			RuiTrackInt( borderRui, "playerMic" + (index + 1), teammates[index], RUI_TRACK_MIC_STATUS )
			RuiSetBool( borderRui, "playerAvailable" + (index + 1), true )
		}
		else
		{
			RuiSetString( borderRui, "playerName" + (index + 1), "" )
			RuiSetInt( borderRui, "playerMic" + (index + 1), -1 )
			RuiSetBool( borderRui, "playerAvailable" + (index + 1), false )
		}
	}

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Appear" )

	fileLevel.gCardRuiHandles.append( borderRui )
}

// Animated Team Introduction
//
void function DoAnimatedSquadCardsPresentation()
{
	foreach( func in file.Callbacks_OnCharacterMenuClosed )
		func()

	#if DEVELOPER
		printt( "CHARACTER SELECT: DoAnimatedSquadCardsPresentation" )
	#endif

	if ( !IsValid( fileLevel.camera ) )
		return

	waitthread function() : ()
	{
		RunUIScript( "UI_CloseCharacterSelect" )

		fileLevel.nestedGladiatorCardHandles.clear()
		fileLevel.gCardRuiHandles.clear()

		RuiSetFloat( fileLevel.backgroundRui, "gcardsStartTime", Time() )
		fileLevel.detailsPanelVisible = false
		UpdateButtonStates()

		float outroSceneChangeDuration = CharSelect_GetOutroSceneChangeDuration()

		EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_LegendPanLeft" )

		wait (outroSceneChangeDuration / 3.0)

		NotifyCharacterSelectBeginEnd( false )
	}()

	thread IntroSquadSequence( GetLocalClientPlayer().GetTeam() )

	// Border around screen
	var borderRui = CreateFullscreenPostFXRui( $"ui/round_end_squads_border.rpak", 3 )
	RuiSetInt( borderRui, "placementNum", -1 )
	RuiSetInt( borderRui, "placementOutOf", -1 )
	RuiSetInt( borderRui, "squadKills", -1 )
	if ( IsSoloMode() )
		RuiSetString( borderRui, "headerText", "#SOLO_HEADER_YOU_SELECTION" )
	else
		RuiSetString( borderRui, "headerText", "#SQUAD_HEADER_YOUR_SQUAD" )

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Appear" )

	fileLevel.gCardRuiHandles.append( borderRui )
}

void function IntroSquadSequence( int team, bool animOnlyChampion = false, float camera_move_duration = 3.0 )
{
	DestorySquadIntroRuisAndEnts()

	int gameState = GetGameState()

	vector squadIntroSequencePosition = < 0, 0, 10000 >
	vector squadIntroSequenceAngles = < 0, 0, 0 >
	
	entity clientPlayer = GetLocalClientPlayer()

	asset defaultModel                = GetGlobalSettingsAsset( DEFAULT_PILOT_SETTINGS, "bodyModel" )
	LoadoutEntry loadoutSlotCharacter = Loadout_CharacterClass()
	vector characterAngles            = < squadIntroSequenceAngles.x / 2.0, squadIntroSequenceAngles.y, squadIntroSequenceAngles.z >

	VictoryPlatformModelData victoryPlatformModelData = GetVictorySequencePlatformModel()
	entity platformModel
	int maxPlayersToShow = -1
	if ( victoryPlatformModelData.isSet )
	{
		platformModel = CreateClientSidePropDynamic( squadIntroSequencePosition + victoryPlatformModelData.originOffset, victoryPlatformModelData.modelAngles, victoryPlatformModelData.modelAsset )

		file.cleanupEnts.append( platformModel )
		int playersOnPodium = 0

		array<entity> teamPlayers = GetPlayerArrayOfTeam( team )
		if( animOnlyChampion ) // To make the center
		{
			array<entity> teamMates = GetPlayerArrayOfTeam( team )
			entity champion = GetEntityFromEncodedEHandle( GetGlobalNetInt( "championEEH" ) )
			teamMates.fastremovebyvalue( champion )

			teamPlayers = [ champion ]
			foreach( player in teamMates )
				teamPlayers.append( player )
		}

		foreach( int i, entity player in teamPlayers )
		{
			if ( maxPlayersToShow > 0 && i > maxPlayersToShow )
				break

			string playerName = ""
			if ( EHIHasValidScriptStruct( player.GetEncodedEHandle() ) )
				playerName = EHI_GetName( player.GetEncodedEHandle() )

			if ( !LoadoutSlot_IsReady( player.GetEncodedEHandle(), loadoutSlotCharacter ) )
				continue

			ItemFlavor character = LoadoutSlot_GetItemFlavor( player.GetEncodedEHandle(), loadoutSlotCharacter )

			if ( !LoadoutSlot_IsReady( player.GetEncodedEHandle(), Loadout_CharacterSkin( character ) ) )
				continue

			ItemFlavor characterSkin = LoadoutSlot_GetItemFlavor( player.GetEncodedEHandle(), Loadout_CharacterSkin( character ) )

			vector pos = GetSquadIntroSquadFormationPosition( squadIntroSequencePosition, squadIntroSequenceAngles, i )

			entity characterNode = CreateScriptRef( pos, characterAngles )
			characterNode.SetParent( platformModel, "", true )
			entity characterModel = CreateClientSidePropDynamic( pos, characterAngles, defaultModel )
			SetForceDrawWhileParented( characterModel, true )
			characterModel.MakeSafeForUIScriptHack()
			CharacterSkin_Apply( characterModel, characterSkin )
			file.cleanupEnts.append( characterModel )

			characterModel.SetParent( characterNode, "", false )
			string victoryAnim = "ACT_MP_MENU_LOBBY_SELECT_IDLE"
			if( player == GetEntityFromEncodedEHandle( GetGlobalNetInt( "championEEH" ) ) && animOnlyChampion )
				victoryAnim = "ACT_MP_MENU_READYUP_INTRO"

			characterModel.Anim_Play( victoryAnim )
			characterModel.Anim_EnableUseAnimatedRefAttachmentInsteadOfRootMotion()

			bool createOverheadRui = true

			int offset = 78

			entity overheadEnt = CreateClientSidePropDynamic( pos + (AnglesToUp( squadIntroSequenceAngles ) * offset), <0, 0, 0>, $"mdl/dev/empty_model.rmdl" )
			overheadEnt.Hide()
			var overheadRui = RuiCreate( $"ui/winning_squad_member_overhead_name.rpak", clGlobal.topoFullScreen, RUI_DRAW_HUD, 0 )
			RuiSetString( overheadRui, "playerName", playerName )
			RuiTrackFloat3( overheadRui, "position", overheadEnt, RUI_TRACK_ABSORIGIN_FOLLOW )
			file.overHeadRuis.append( overheadRui )

			playersOnPodium++
		}

		SquadIntroCameraPackage squadIntroCameraPackage = GetSquadIntroCameraPackage()

		vector camera_offset_start = squadIntroCameraPackage.camera_offset_start
		vector camera_offset_end   = squadIntroCameraPackage.camera_offset_end
		vector camera_focus_offset = squadIntroCameraPackage.camera_focus_offset
		float camera_fov           = squadIntroCameraPackage.camera_fov

		vector camera_start_pos = OffsetPointRelativeToVector( squadIntroSequencePosition, camera_offset_start, AnglesToForward( squadIntroSequenceAngles ) )
		vector camera_end_pos   = OffsetPointRelativeToVector( squadIntroSequencePosition, camera_offset_end, AnglesToForward( squadIntroSequenceAngles ) )
		vector camera_focus_pos = OffsetPointRelativeToVector( squadIntroSequencePosition, camera_focus_offset, AnglesToForward( squadIntroSequenceAngles ) )

		vector camera_start_angles = VectorToAngles( camera_focus_pos - camera_start_pos )
		vector camera_end_angles   = VectorToAngles( camera_focus_pos - camera_end_pos )

		entity cameraMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", camera_start_pos, camera_start_angles )
		fileLevel.camera.SetParent( cameraMover, "", false )

		cameraMover.NonPhysicsMoveTo( camera_end_pos, camera_move_duration, 0.0, camera_move_duration / 2.0 )
		cameraMover.NonPhysicsRotateTo( camera_end_angles, camera_move_duration, 0.0, camera_move_duration / 2.0 )
		file.cleanupEnts.append( cameraMover )
	}
}

void function DestorySquadIntroRuisAndEnts()
{
	foreach( rui in file.overHeadRuis )
	{
		RuiDestroyIfAlive( rui )
	}
		
	foreach( entity ent in file.cleanupEnts )
	{
		if( IsValid( ent ) )
			ent.Destroy()
	}
}

SquadIntroCameraPackage function GetSquadIntroCameraPackage()
{
	SquadIntroCameraPackage squadIntroCameraPackage

	squadIntroCameraPackage.camera_offset_start = <0, 320, 68>
	squadIntroCameraPackage.camera_offset_end = <0, 200, 48>
	squadIntroCameraPackage.camera_focus_offset = <0, 0, 36>
	squadIntroCameraPackage.camera_fov = 35.5

	return squadIntroCameraPackage
}

vector function GetSquadIntroSquadFormationPosition( vector mainPosition, vector angles, int index )
{
	if ( index == 0 )
		return mainPosition - <0, 0, 8>

	float offset_side = 48.0
	float offset_back = -28.0

	int countBack = (index + 1) / 2
	vector offset = < offset_side, offset_back, 0 > * countBack

	if ( index % 2 == 0 )
		offset.x *= -1

	vector point = OffsetPointRelativeToVector( mainPosition, offset, AnglesToForward( angles ) )
	return point - <0, 0, 8>
}

void function DoAnimatedChampionSquadCardsPresentation()
{
	#if DEVELOPER
		printt( "CHARACTER SELECT: DoAnimatedChampionSquadCardsPresentation" )
	#endif

	string voLine               = GetAnyDialogueAliasFromName( PickCommentaryLineFromBucket( eSurvivalCommentaryBucket.INTRO_CHAMPION_CARD ) )
	float fadeToBlackDuration   = 0.5
	float fadeFromBlackDuration = 0.5
	float blackDuration         = max( GetSoundDuration( voLine ) * 0.5, 2.0 )

	// Announcer VO
	EmitSoundOnEntity( GetLocalClientPlayer(), voLine )

	{
		int championEHI       = GetGlobalNetInt( "championEEH" )
		int championSquad1EHI = GetGlobalNetInt( "championSquad1EEH" )
		int championSquad2EHI = GetGlobalNetInt( "championSquad2EEH" )

		int me = GetLocalViewPlayer().GetEncodedEHandle()
		if ( me == championEHI || me == championSquad1EHI || me == championSquad2EHI )
			Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_BLEND, {[0.0] = <1, .75, 0>, [1.0] = <.75, .3, 0>}, 2.0 ) //
		else
			Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_BLEND, {[0.0] = <0, 0, 0>, [1.0] = <.5, .5, .5>}, 2.0 ) //
	}

	// Fade to black and change the scene to black smoke
	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Disappear" )
	ScreenFade( GetLocalClientPlayer(), 0, 0, 0, 255, fadeToBlackDuration, blackDuration, FFADE_OUT | FFADE_PURGE )
	wait fadeToBlackDuration
	SetCharacterSelectSceneForChampionSquad()
	DestorySquadIntroRuisAndEnts()
	wait blackDuration
	ScreenFade( GetLocalClientPlayer(), 0, 0, 0, 255, fadeFromBlackDuration, 0.0, FFADE_IN | FFADE_PURGE )

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Appear" )

	// Show cards
	var rui = CreateFullscreenRui( $"ui/gladiator_card_intro_screen.rpak", RUI_SORT_SCREENFADE - 1 )
	string topHeader
	if ( IsSoloMode() )
		topHeader = "#GLADIATOR_CARD_INTRO_CHAMPION_SOLO"
	else
		topHeader = "#GLADIATOR_CARD_INTRO_CHAMPION_SQUAD"


	RuiSetString( rui, "topHeader", topHeader )
	RuiSetGameTime( rui, "transitionInAt", Time() )
	RuiSetGameTime( rui, "transitionOutAt", GetGlobalNetTime( "pickLoadoutGamestateEndTime" ) )
	RuiSetFloat( rui, "xpBonusAmount", XpEventTypeData_GetAmount( XP_TYPE.KILL_CHAMPION_MEMBER ) )
	RuiSetBool( rui, "isDuoMode", GetExpectedSquadSize( GetLocalClientPlayer() ) == 2 )

	RuiSetBool( rui, "showBottomText", !IsRankedGame() )

	int championEEH = GetGlobalNetInt( "championEEH" )
	
	thread IntroSquadSequence( GetEntityFromEncodedEHandle( championEEH ).GetTeam(), true )

	OnThreadEnd(
		void function() : ( rui )
		{
			RuiDestroyIfAlive( rui )
			DestorySquadIntroRuisAndEnts()
			EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Disappear" )

			Chroma_EndCharacterSelect()
		}
	)

	PlayCharacterReadyUpLine( LoadoutSlot_GetItemFlavor( ToEHI( GetEntityFromEncodedEHandle( championEEH ) ), Loadout_CharacterClass() ) )

	wait 1.5

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_BannerChampion" )

	while( Time() < GetGlobalNetTime( "pickLoadoutGamestateEndTime" ) )
		WaitFrame()
}
//
// End

void function DoChampionSquadCardsPresentation()
{
	#if DEVELOPER
		printt( "CHARACTER SELECT: DoChampionSquadCardsPresentation" )
	#endif

	PauseMainDialogueQueue()

	string voLine               = GetAnyDialogueAliasFromName( PickCommentaryLineFromBucket( eSurvivalCommentaryBucket.INTRO_CHAMPION_CARD ) )
	float fadeToBlackDuration   = 0.5
	float fadeFromBlackDuration = 0.5
	float blackDuration         = max( GetSoundDuration( voLine ) * 0.5, 2.0 )

	// Announcer VO
	EmitSoundOnEntity( GetLocalClientPlayer(), voLine )

	{
		int championEHI       = GetGlobalNetInt( "championEEH" )
		int championSquad1EHI = GetGlobalNetInt( "championSquad1EEH" )
		int championSquad2EHI = GetGlobalNetInt( "championSquad2EEH" )

		int me = GetLocalViewPlayer().GetEncodedEHandle()
		if ( me == championEHI || me == championSquad1EHI || me == championSquad2EHI )
			Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_BLEND, {[0.0] = <1, .75, 0>, [1.0] = <.75, .3, 0>}, 2.0 ) //
		else
			Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_BLEND, {[0.0] = <0, 0, 0>, [1.0] = <.5, .5, .5>}, 2.0 ) //
	}

	// Fade to black and change the scene to black smoke
	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Disappear" )
	ScreenFade( GetLocalClientPlayer(), 0, 0, 0, 255, fadeToBlackDuration, blackDuration, FFADE_OUT | FFADE_PURGE )
	wait fadeToBlackDuration
	SetCharacterSelectSceneForChampionSquad()
	wait blackDuration
	ScreenFade( GetLocalClientPlayer(), 0, 0, 0, 255, fadeFromBlackDuration, 0.0, FFADE_IN | FFADE_PURGE )

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Appear" )

	// Show cards
	var rui = CreateFullscreenRui( $"ui/gladiator_card_intro_screen.rpak", RUI_SORT_SCREENFADE - 1 )
	string topHeader
	if ( IsSoloMode() )
		topHeader = "#GLADIATOR_CARD_INTRO_CHAMPION_SOLO"
	else
		topHeader = "#GLADIATOR_CARD_INTRO_CHAMPION_SQUAD"

	float stopShowingCardAt
	
	if( Gamemode() == eGamemodes.fs_dm )
		stopShowingCardAt = GetGlobalNetTime( "championDisplayEndTime" )
	else stopShowingCardAt = GetGlobalNetTime( "pickLoadoutGamestateEndTime" )
		
		

	RuiSetString( rui, "topHeader", topHeader )
	RuiSetGameTime( rui, "transitionInAt", Time() )
	RuiSetGameTime( rui, "transitionOutAt", stopShowingCardAt )
	RuiSetFloat( rui, "xpBonusAmount", 420 ) //XpEventTypeData_GetAmount( XP_TYPE.KILL_CHAMPION_MEMBER )
	RuiSetBool( rui, "isDuoMode", GetExpectedSquadSize( GetLocalClientPlayer() ) == 2 )

	array<entity> teammates = GetPlayerSquad()
	ArrayRemoveInvalid( teammates )
	for ( int index = 0 ; index < 4 ; index++ )
	{
		if ( index < teammates.len() )
		{
			RuiSetString( rui, "playerName" + (index + 1), teammates[index].GetPlayerName() )
			RuiTrackInt( rui, "playerMic" + (index + 1), teammates[index], RUI_TRACK_MIC_STATUS )
			RuiSetBool( rui, "playerAvailable" + (index + 1), true )
		}
		else
		{
			RuiSetString( rui, "playerName" + (index + 1), "" )
			RuiSetInt( rui, "playerMic" + (index + 1), -1 )
			RuiSetBool( rui, "playerAvailable" + (index + 1), false )
		}
	}

	RuiSetBool( rui, "showBottomText", !IsRankedGame() )

	array<NestedGladiatorCardHandle> nestedGCHandles

	int championEHI = GetGlobalNetInt( "championEEH" )
	int championSquad1EHI = GetGlobalNetInt( "championSquad1EEH" )
	int championSquad2EHI = GetGlobalNetInt( "championSquad2EEH" )

	if ( championSquad1EHI != EHI_null && !g_bSinglePlayerChampion() )
	{
		NestedGladiatorCardHandle handle = CreateNestedGladiatorCard( rui, "cardBoxLeft", eGladCardDisplaySituation.GAME_INTRO_CHAMPION_SQUAD_STILL, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( handle, championSquad1EHI, Time(), eGladCardLifestateOverride.ALIVE )
		nestedGCHandles.append( handle )
	}
	if ( championEHI != EHI_null )
	{
		NestedGladiatorCardHandle handle = CreateNestedGladiatorCard( rui, "cardBoxMiddle", eGladCardDisplaySituation.GAME_INTRO_CHAMPION_SQUAD_ANIMATED, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( handle, championEHI, Time() + 0.2, eGladCardLifestateOverride.ALIVE )
		nestedGCHandles.append( handle )
	}
	if ( championSquad2EHI != EHI_null && !g_bSinglePlayerChampion() )
	{
		NestedGladiatorCardHandle handle = CreateNestedGladiatorCard( rui, "cardBoxRight", eGladCardDisplaySituation.GAME_INTRO_CHAMPION_SQUAD_STILL, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( handle, championSquad2EHI, Time() + 0.4, eGladCardLifestateOverride.ALIVE )
		nestedGCHandles.append( handle )
	}

	OnThreadEnd
	(
		void function() : ( rui, nestedGCHandles )
		{		
			ResumeMainDialogueQueue()
			foreach ( NestedGladiatorCardHandle ngch in nestedGCHandles )
				CleanupNestedGladiatorCard( ngch )
			RuiDestroyIfAlive( rui )
			EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Disappear" )

			Chroma_EndCharacterSelect()
		}
	)

	if ( ShouldPlayIntroQuip() )
	{
		thread PlayIntroQuipThread( GetLocalClientPlayer(), championEHI )
	}

	wait 1.5

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_BannerChampion" )
	
	
	string timeToWait = Gamemode() == eGamemodes.fs_dm ? "championDisplayEndTime" : "pickLoadoutGamestateEndTime"
	{
		while( Time() < GetGlobalNetTime( timeToWait ) )
			WaitFrame()
	}
}

bool function ShouldPlayIntroQuip()
{
	if ( IsFallLTM() )
		return false

	return true
}
#endif

#if UI
void function UI_RunCharacterSelect( bool isBrowseMode, bool menuEntsExist )
{
	CloseAllMenus()

	fileLevel.isBrowseMode = isBrowseMode
	fileLevel.isBrowseModeStartTime = Time()

	if ( !CanRunClientScript() )
		return

	if ( !menuEntsExist )
		SetBlurEnabled( true )

	RunClientScript( "_OpenCharacterSelectNewMenu", fileForever.menu )

	FlashGameWindow()
	AdvanceMenu( fileForever.menu )
}
#endif

#if CLIENT
void function _OpenCharacterSelectNewMenu( var menu )
{
	RemoveCallback_OnPlayerDisconnected( OnPlayerDisconnected )
	AddCallback_OnPlayerDisconnected( OnPlayerDisconnected )

	RemoveDestroyCallback( "player", OnPlayerDestroyed )
	AddDestroyCallback( "player", OnPlayerDestroyed )

	UpdateMenuElementHandles( menu )

	if ( !fileLevel.isBrowseMode )
	{
		thread FlashScreenWhite()
		if( Playlist() != ePlaylists.fs_scenarios  )
		{
			float gameStartTime = GetGlobalNetTime( "pickLoadoutGamestateEndTime" )
			Assert( gameStartTime > -1 )
			thread CloseCharacterSelectMenuAtTime( gameStartTime )
		}
	}

	if ( !fileLevel.menuEntsExist )
		printt( "CHARACTER SELECT MAP INSTANCE NOT IN THIS BSP" )

	fileLevel.localClientLockstepIndex = GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )

	CreateCharacterSelectClientEnts()
	UpdateCamera()
	if ( !fileLevel.isBrowseMode )
		FooterRui()

	fileLevel.menuEntsReady = true

	UpdateMenuButtons()
	thread UpdateSceneThink()

	#if DEBUG_CHARACTER_SELECT
		thread DebugMenuThink()
	#endif

	if ( !fileLevel.isBrowseMode )
	{
		Assert( fileLevel.localClientLockstepIndex >= 0 )

		foreach( entity player in GetPlayerSquad() )
		{
			// Assert that we all have picking order assigned and no duplicates
			int teammatePickingIndex = player.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )
			if ( teammatePickingIndex >= 0 && player != GetLocalClientPlayer() )
				Assert( teammatePickingIndex != fileLevel.localClientLockstepIndex )
		}

		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterClass(), OnTeammateLoadoutSelectionChanged, false )
		foreach( ItemFlavor character in GetAllCharacters() )
		{
			LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( skinSlot, OnTeammateLoadoutSelectionChanged, false )
		}
	}

	if ( fileLevel.isBrowseMode )
	{
		ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterClass() )
		int buttonIndex = GetButtonIndexForCharacter( character )
		if ( buttonIndex >= 0)
		{
			EmitSoundOnEntity( GetLocalClientPlayer(), "ui_menu_focus_legendselectscreen" )
			UpdateForFocusOnButtonIndex( buttonIndex )
		}
	}
}

void function UpdateMenuElementHandles( var menu )
{
	fileLevel.menu = menu
	fileLevel.whiteFlash = Hud_GetChild( menu, "WhiteFlash" )
	fileLevel.portraitsPanel = Hud_GetChild( menu, "PortraitsPanel" )
	fileLevel.detailsPanel = Hud_GetChild( menu, "DetailsRuiPanel" )
	fileLevel.buttonHintPanel = Hud_GetChild( menu, "ButtonHintRuiPanel" )

	fileLevel.characterButtons = []
	fileLevel.characterButtonRuis = []
	fileLevel.detailsRui = Hud_GetRui( fileLevel.detailsPanel )
	fileLevel.buttonHintRui = Hud_GetRui( fileLevel.buttonHintPanel )

	for ( int i = 0; i < NUM_CHARACTER_SELECT_BUTTONS; i++ )
	{
		// Get the button
		var button = Hud_GetChild( fileLevel.portraitsPanel, "Button" + i )
		fileLevel.characterButtons.append( button )

		var buttonRui = Hud_GetRui( button )
		fileLevel.characterButtonRuis.append( buttonRui )

		// Add button callbacks
		if ( button in fileLevel.buttonEventHandlersAdded_Click )
		{
			Hud_RemoveEventHandler( button, UIE_CLICK, OnLoadoutButton_Activate )
			delete fileLevel.buttonEventHandlersAdded_Click[ button ]
		}
		Hud_AddEventHandler( button, UIE_CLICK, OnLoadoutButton_Activate )
		fileLevel.buttonEventHandlersAdded_Click[ button ] <- true

		if ( button in fileLevel.buttonEventHandlersAdded_Focus )
		{
			Hud_RemoveEventHandler( button, UIE_GET_FOCUS, OnLoadoutButton_Focused )
			delete fileLevel.buttonEventHandlersAdded_Focus[ button ]
		}
		Hud_AddEventHandler( button, UIE_GET_FOCUS, OnLoadoutButton_Focused )
		fileLevel.buttonEventHandlersAdded_Focus[ button ] <- true

		//Hud_RemoveEventHandler( button, UIE_LOSE_FOCUS, OnLoadoutButton_LostFocus )

		//Hud_AddEventHandler( button, UIE_LOSE_FOCUS, OnLoadoutButton_LostFocus )

		Hud_SetVisible( button, false )
	}
}

void function UpdateMenuElementHandles_AimTrainer( var menu )
{
	fileLevel.menu = menu
	fileLevel.whiteFlash = Hud_GetChild( menu, "WhiteFlash" )
	fileLevel.portraitsPanel = Hud_GetChild( menu, "PortraitsPanel" )
	fileLevel.detailsPanel = Hud_GetChild( menu, "DetailsRuiPanel" )
	fileLevel.buttonHintPanel = Hud_GetChild( menu, "ButtonHintRuiPanel" )

	fileLevel.characterButtons = []
	fileLevel.characterButtonRuis = []
	fileLevel.detailsRui = Hud_GetRui( fileLevel.detailsPanel )
	fileLevel.buttonHintRui = Hud_GetRui( fileLevel.buttonHintPanel )

	for ( int i = 0; i < NUM_CHARACTER_SELECT_BUTTONS; i++ )
	{
		// Get the button
		var button = Hud_GetChild( fileLevel.portraitsPanel, "Button" + i )
		fileLevel.characterButtons.append( button )

		var buttonRui = Hud_GetRui( button )
		fileLevel.characterButtonRuis.append( buttonRui )

		// Add button callbacks
		if ( button in fileLevel.buttonEventHandlersAdded_Click )
		{
			Hud_RemoveEventHandler( button, UIE_CLICK, OnLoadoutButton_Activate_AimTrainer )
			delete fileLevel.buttonEventHandlersAdded_Click[ button ]
		}
		Hud_AddEventHandler( button, UIE_CLICK, OnLoadoutButton_Activate_AimTrainer )
		fileLevel.buttonEventHandlersAdded_Click[ button ] <- true

		if ( button in fileLevel.buttonEventHandlersAdded_Focus )
		{
			Hud_RemoveEventHandler( button, UIE_GET_FOCUS, OnLoadoutButton_Focused_AimTrainer )
			delete fileLevel.buttonEventHandlersAdded_Focus[ button ]
		}
		Hud_AddEventHandler( button, UIE_GET_FOCUS, OnLoadoutButton_Focused_AimTrainer )
		fileLevel.buttonEventHandlersAdded_Focus[ button ] <- true

		//Hud_RemoveEventHandler( button, UIE_LOSE_FOCUS, OnLoadoutButton_LostFocus )

		//Hud_AddEventHandler( button, UIE_LOSE_FOCUS, OnLoadoutButton_LostFocus )

		Hud_SetVisible( button, false )
	}
}

void function UpdateMenuButtons()
{
	array<ItemFlavor> shippingCharacters
	array<ItemFlavor> devCharacters
	array<ItemFlavor> lockedCharacters
	array<ItemFlavor> disabledCharacters
	array<ItemFlavor> allCharacters

	foreach( ItemFlavor itemFlav in GetAllCharacters() )
	{
		if ( !ItemFlavor_ShouldBeVisible( itemFlav, null, GetConVarInt( "mtx_svEdition" ) ) )
			continue

		bool isAvailable = IsItemFlavorUnlockedForLoadoutSlot( LocalClientEHI(), Loadout_CharacterClass(), itemFlav, true )
		bool isOwned     = GRX_IsItemOwnedByPlayer_AllowOutOfDateData( itemFlav, GetLocalClientPlayer() )

		int playlistOpinion = ItemFlavor_GetPlaylistOpinion( itemFlav )
		bool opinionLock = playlistOpinion == eItemFlavorPlaylistOpinion.LOCKED

		if ( !isAvailable && !opinionLock )
		{
			disabledCharacters.append( itemFlav )
		}
		else
		{
			if ( !isOwned || opinionLock )
				lockedCharacters.append( itemFlav )
			else
				shippingCharacters.append( itemFlav )
		}
	}
	allCharacters.extend( shippingCharacters )
	allCharacters.extend( lockedCharacters )
	allCharacters.extend( disabledCharacters )

	Assert( allCharacters.len() < NUM_CHARACTER_SELECT_BUTTONS, "Character select doesn't have enough character buttons. Has " + NUM_CHARACTER_SELECT_BUTTONS + " but needs " + allCharacters.len() )
	fileLevel.buttonIndexUsed.clear()

	table<int, ItemFlavor> mappingTable = GetCharacterButtonMapping( allCharacters, NUM_CHARACTER_SELECT_BUTTONS )
	foreach( int buttonIndex, ItemFlavor itemFlav in mappingTable )
	{
		var button    = fileLevel.characterButtons[buttonIndex]
		var buttonRui = fileLevel.characterButtonRuis[buttonIndex]

		if ( lockedCharacters.contains( itemFlav ) )
			fileLevel.lockedButtonIndexies.append( buttonIndex )

		//
		fileLevel.buttonIndexCharacterMap[ buttonIndex ] <- itemFlav
		fileLevel.buttonIndexUsed.append( buttonIndex )

		//
		RuiSetImage( buttonRui, "portraitImage", CharacterClass_GetGalleryPortrait( itemFlav ) )
		RuiSetImage( buttonRui, "portraitBackground", CharacterClass_GetGalleryPortraitBackground( itemFlav ) )
		RuiSetString( buttonRui, "portraitName", Localize( ItemFlavor_GetLongName( itemFlav ) ) )
		RuiSetImage( buttonRui, "roleImage", CharacterClass_GetCharacterRoleImage( itemFlav ) )
	}

	array<int> rowSizes = GetCharacterButtonRowSizes( allCharacters.len() )
	array< array<var> > buttonRows

	int buttonIndex = 0
	foreach ( rowSize in rowSizes )
	{
		array<var> buttons
		int last = buttonIndex + rowSize

		while ( buttonIndex < last )
		{
			buttons.append( fileLevel.characterButtons[buttonIndex] )
			buttonIndex++
		}

		buttonRows.append( buttons )
	}
	LayoutCharacterButtons( buttonRows )
	UpdateButtonStates()
}
#endif //CLIENT

#if UI
void function Gamemode1v1_CloseLegendMenu()
{
	UI_OnCharacterSelectMenu_NavBack()
}

void function UI_OnCharacterSelectMenu_NavBack()
{
	// Don't close the menu during loadout selection
	if ( fileLevel.isBrowseMode )
	{
		CloseAllMenus()
		RunClientScript("CloseCharacterSelectNewMenu_AimTrainer" )
		
		if( ISAIMTRAINER )
		{
			RunClientScript("ServerCallback_OpenFRChallengesSettings")
			RunClientScript("ServerCallback_CoolCameraOnMenu")
		}
		
		return
	} 
	else 
		RunClientScript( "Client_TryUnlockCharacter" )
}

void function UI_CloseCharacterSelect()
{
	SetBlurEnabled( false )
	if ( GetActiveMenu() == fileForever.menu )
		CloseAllMenus() //CloseActiveMenu()
	else if ( IsMenuInMenuStack( fileForever.menu ) )
		RemoveFromMenuStack( fileForever.menu )
}
#endif //UI

#if CLIENT

const float CHARACTER_SELECT_FADE_HOLD_TIME = 1.0

void function CloseCharacterSelectMenuAtTime( float closeTimeStamp )
{
	Signal( GetLocalClientPlayer(), "CloseCharacterSelectMenuAtTime" )
	EndSignal( GetLocalClientPlayer(), "CloseCharacterSelectMenuAtTime" )

	while ( Time() < closeTimeStamp - SCREEN_COVER_TRANSITION_OUT_DURATION - 0.1 )
		WaitFrame()

	wait Playlist() == ePlaylists.fs_scenarios ? CHARACTER_SELECT_CLOSE_TRANSITION_DURATION : ScreenCoverTransition( Time() + CHARACTER_SELECT_CLOSE_TRANSITION_DURATION )

	CloseCharacterSelectNewMenu()

	FlashGameWindow()
}

void function CloseCharacterSelectNewMenu()
{
	Signal( fileLevel.signalDummy, "CharacterSelectClosing" )

	RunUIScript( "UI_CloseCharacterSelect" )

	foreach( func in file.Callbacks_OnCharacterMenuClosed )
		func()

	RemoveCallback_OnPlayerDisconnected( OnPlayerDisconnected )
	RemoveDestroyCallback( "player", OnPlayerDestroyed )

	// Reset camera, DOF, color correction, and fog
	if ( IsValid( fileLevel.camera ) )
	{
		if (FS_ShouldShowCustomCharacterSelect())
		{
			fileLevel.camera.SetFOV( CAMERA_FOV )
		} else 
		{
			fileLevel.camera.SetFOV( CAMERA_FOV_LEGACY )
		}
	}
	GetLocalClientPlayer().ClearMenuCameraEntity()
	DoF_SetNearDepthToDefault()
	DoF_SetFarDepthToDefault()
	DoFSetDilateInfocus( false )
	ColorCorrection_SetWeight( fileLevel.colorCorrection, 0.0 )
	ColorCorrection_SetExclusive( fileLevel.colorCorrection, false )
	SetMapSetting_FogEnabled( true )

	// Delete menu entities
	DeleteMenuEntities()

	if ( fileLevel.lightEntsExist )
	{
		fileLevel.keyLight.SetTweakLightRealtimeShadows( false )
		fileLevel.keyLight.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.fillLight.SetTweakLightRealtimeShadows( false )
		fileLevel.fillLight.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.rimLightL.SetTweakLightRealtimeShadows( false )
		fileLevel.rimLightL.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.rimLightR.SetTweakLightRealtimeShadows( false )
		fileLevel.rimLightR.SetTweakLightUpdateShadowsEveryFrame( false )
	}

	fileLevel.menuEntsReady = false

	OnCharacterSelectNewMenuClosed_RemoveCallbacks()
}

void function CloseCharacterSelectNewMenu_AimTrainer()
{
	Signal( fileLevel.signalDummy, "CharacterSelectClosing" )

	RunUIScript( "UI_CloseCharacterSelect" )

	// foreach( func in file.Callbacks_OnCharacterMenuClosed )
		// func()

	// Reset camera, DOF, color correction, and fog
	if ( IsValid( fileLevel.camera ) )
	{
		if (FS_ShouldShowCustomCharacterSelect())
		{
			fileLevel.camera.SetFOV( CAMERA_FOV )
		} else
		{
			fileLevel.camera.SetFOV( CAMERA_FOV_LEGACY )
		}
	}
	GetLocalClientPlayer().ClearMenuCameraEntity()
	DoF_SetNearDepthToDefault()
	DoF_SetFarDepthToDefault()
	DoFSetDilateInfocus( false )
	ColorCorrection_SetWeight( fileLevel.colorCorrection, 0.0 )
	ColorCorrection_SetExclusive( fileLevel.colorCorrection, false )
	SetMapSetting_FogEnabled( true )

	// Delete menu entities
	DeleteMenuEntities()

	if ( fileLevel.lightEntsExist )
	{
		fileLevel.keyLight.SetTweakLightRealtimeShadows( false )
		fileLevel.keyLight.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.fillLight.SetTweakLightRealtimeShadows( false )
		fileLevel.fillLight.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.rimLightL.SetTweakLightRealtimeShadows( false )
		fileLevel.rimLightL.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.rimLightR.SetTweakLightRealtimeShadows( false )
		fileLevel.rimLightR.SetTweakLightUpdateShadowsEveryFrame( false )
	}

	fileLevel.menuEntsReady = false

	OnCharacterSelectNewMenuClosed_RemoveCallbacks()
}
void function OnCharacterSelectNewMenuClosed_RemoveCallbacks()
{
	RemoveCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterClass(), OnTeammateLoadoutSelectionChanged, false )
	foreach( ItemFlavor character in GetAllCharacters() )
	{
		LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
		RemoveCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( skinSlot, OnTeammateLoadoutSelectionChanged, false )
	}
}

LocPair function FS_ReturnRandomCameraPosForMap()
{
	array<LocPair> locs
	
	switch(MapName())
	{
		case eMaps.mp_rr_desertlands_holiday:
		case eMaps.mp_rr_desertlands_64k_x_64k:
		case eMaps.mp_rr_desertlands_64k_x_64k_nx:
		locs.append( NewCameraPair( <-24658.5098, -20805.4355, -4072.05835>, <0, -61.8279648, 0> ) )
		locs.append( NewCameraPair( <-13089.8877, 29345.084, -3618.15674>, <0, -50.455925, 0> ) )
		locs.append( NewCameraPair( <-26440.9238, 8800.14844, -2643.43994>, <0, 138.625336, 0> ) )
		locs.append( NewCameraPair( <20361.3906, 2127.68311, -4068.20752>, <0, 8.24257946, 0> ) )
		locs.append( NewCameraPair( <5565.78125, -23571.5742, -3481.78052>, <0, 43.9160843, 0> ) )
		break
		
		case eMaps.mp_rr_canyonlands_mu2:
		case eMaps.mp_rr_canyonlands_mu1:
		case eMaps.mp_rr_canyonlands_mu1_night:
		case eMaps.mp_rr_canyonlands_64k_x_64k:
		case eMaps.mp_rr_canyonlands_staging:
		locs.append( NewCameraPair( <-7570, -29658, 18553>, <32, 69, 0> ) )
		break
		
	}
	
	if( locs.len() == 0 )
	{
		LocPair loc
		return loc
	}
	
	return locs.getrandom()
}

LocPair function NewCameraPair(vector origin, vector angles)
{
	LocPair locPair
	locPair.origin = origin
	locPair.angles = angles

	return locPair
}

void function CreateCharacterSelectClientEnts()
{
	if (FS_ShouldShowCustomCharacterSelect())
	{ 
		if ( !fileLevel.menuEntsExist )
			return
		
		entity targetCamera
		vector cameraOrigin
		vector cameraAngles
		entity targetPilot

		targetCamera = GetEntByScriptName( CAMERA_ENT_NAME )
		LocPair cameracool = FS_ReturnRandomCameraPosForMap()
		fileLevel.camera = CreateClientSidePointCamera( cameracool.origin, cameracool.angles, 100 )
		targetPilot = GetEntByScriptName( CHARACTER_ENT_NAME )
		fileLevel.characterNode = CreateScriptRef( targetPilot.GetOrigin(), targetPilot.GetAngles() )
		asset defaultModel = GetGlobalSettingsAsset( DEFAULT_PILOT_SETTINGS, "bodyModel" )
		CreateNewCharacterModel( defaultModel )

		fileLevel.dontdestroy = false

		if ( DoMenuLightsExist() )
		{
			fileLevel.keyLight = GetEntByScriptName( LIGHT_KEY_NAME )
			fileLevel.keyLight.SetTweakLightRealtimeShadows( true )
			fileLevel.keyLight.SetTweakLightUpdateShadowsEveryFrame( true )

			fileLevel.fillLight = GetEntByScriptName( LIGHT_FILL_NAME )
			fileLevel.fillLight.SetTweakLightRealtimeShadows( true )
			fileLevel.fillLight.SetTweakLightUpdateShadowsEveryFrame( true )

			fileLevel.rimLightL = GetEntByScriptName( LIGHT_RIML_NAME )
			fileLevel.rimLightL.SetTweakLightRealtimeShadows( true )
			fileLevel.rimLightL.SetTweakLightUpdateShadowsEveryFrame( true )

			fileLevel.rimLightR = GetEntByScriptName( LIGHT_RIMR_NAME )
			fileLevel.rimLightR.SetTweakLightRealtimeShadows( true )
			fileLevel.rimLightR.SetTweakLightUpdateShadowsEveryFrame( true )
		}

		// In-World RUI for name

			vector backgroundRuiOrigin = cameraOrigin + (targetCamera.GetForwardVector() * 200)
			vector backgroundRuiAngles = targetPilot.GetAngles()
			fileLevel.backgroundRuiTopo = CreateRUITopology_Worldspace( backgroundRuiOrigin, backgroundRuiAngles * -1, RUI_NAME_PLATE_WIDTH, RUI_NAME_PLATE_HEIGHT )
			fileLevel.backgroundRui = RuiCreate( $"ui/character_select_name_plate_new.rpak", fileLevel.backgroundRuiTopo, RUI_DRAW_WORLD, 0 )
			Chroma_BeginCharacterSelect()
			vector r5reloadedOrigin
			
			if ( MapName() == eMaps.mp_rr_desertlands_64k_x_64k || MapName() == eMaps.mp_rr_desertlands_64k_x_64k_nx  || MapName() == eMaps.mp_rr_olympus_mu1 || MapName() == eMaps.mp_rr_desertlands_holiday )
			{
			r5reloadedOrigin = fileLevel.camera.GetOrigin() + fileLevel.camera.GetForwardVector() * 120 + fileLevel.camera.GetRightVector() * 40
			}
			else if( MapName() == eMaps.mp_rr_canyonlands_mu2 || MapName() == eMaps.mp_rr_canyonlands_mu1 || MapName() == eMaps.mp_rr_canyonlands_mu1_night || MapName() == eMaps.mp_rr_canyonlands_64k_x_64k || MapName() == eMaps.mp_rr_canyonlands_staging )
			{
			r5reloadedOrigin = fileLevel.camera.GetOrigin() + fileLevel.camera.GetForwardVector() * 120 - fileLevel.camera.GetRightVector() * 40
			}
			
		if ( !fileLevel.isBrowseMode )
		{
			var countdownRuiTopo = CreateRUITopology_Worldspace( fileLevel.camera.GetOrigin() + fileLevel.camera.GetForwardVector() * 110 - fileLevel.camera.GetRightVector() * 40 - fileLevel.camera.GetUpVector() * 25 , fileLevel.camera.GetAngles() + <0, 0, 0>, RUI_NAME_PLATE_WIDTH, RUI_NAME_PLATE_HEIGHT )
			fileLevel.countdownRui = RuiCreate( $"ui/character_select_name_plate_new.rpak", countdownRuiTopo, RUI_DRAW_WORLD, 0 )
			RuiSetString( fileLevel.countdownRui, "nameString", "FLOWSTATE" )
			RuiSetString( fileLevel.countdownRui, "footnoteString", "POWERED BY R5RELOADED" )
			thread CountdownTimerSounds()
		}
	} else 
	{
		if ( !fileLevel.menuEntsExist )
			return

		entity targetCamera = GetEntByScriptName( CAMERA_ENT_NAME )
		vector cameraOrigin = targetCamera.GetOrigin()

		entity targetPilot = GetEntByScriptName( CHARACTER_ENT_NAME )

		fileLevel.camera = CreateClientSidePointCamera( cameraOrigin, targetCamera.GetAngles(), CAMERA_FOV_LEGACY )

		fileLevel.characterNode = CreateScriptRef( targetPilot.GetOrigin(), targetPilot.GetAngles() )

		asset defaultModel = GetGlobalSettingsAsset( DEFAULT_PILOT_SETTINGS, "bodyModel" )
		CreateNewCharacterModel( defaultModel )

		if ( DoesBackgroundEntExist() )
		{
			// Temp until maps are recompiled

			entity targetBackground = GetEntByScriptName( BACKGROUND_ENT_NAME )

			fileLevel.backgroundModelGeo = CreateClientSidePropDynamic( targetBackground.GetOrigin() - <0, 0, 24>, targetBackground.GetAngles(), BACKGROUND_GEO_MODEL_LEGACY )
			fileLevel.backgroundModelGeo.kv.solid = 0
			fileLevel.backgroundModelGeo.kv.disableshadows = 1
			fileLevel.backgroundModelGeo.kv.fadedist = -1
			fileLevel.backgroundModelGeo.MakeSafeForUIScriptHack()

			fileLevel.backgroundModelSmoke = CreateClientSidePropDynamic( targetBackground.GetOrigin() - <0, 0, 24>, targetBackground.GetAngles(), BACKGROUND_SMOKE_MODEL )
			fileLevel.backgroundModelSmoke.kv.solid = 0
			fileLevel.backgroundModelSmoke.kv.disableshadows = 1
			fileLevel.backgroundModelSmoke.kv.fadedist = -1
			fileLevel.backgroundModelSmoke.MakeSafeForUIScriptHack()
		}

		if ( DoMenuLightsExist() )
		{
			fileLevel.keyLight = GetEntByScriptName( LIGHT_KEY_NAME )
			fileLevel.keyLight.SetTweakLightRealtimeShadows( true )
			fileLevel.keyLight.SetTweakLightUpdateShadowsEveryFrame( true )

			fileLevel.fillLight = GetEntByScriptName( LIGHT_FILL_NAME )
			fileLevel.fillLight.SetTweakLightRealtimeShadows( true )
			fileLevel.fillLight.SetTweakLightUpdateShadowsEveryFrame( true )

			fileLevel.rimLightL = GetEntByScriptName( LIGHT_RIML_NAME )
			fileLevel.rimLightL.SetTweakLightRealtimeShadows( true )
			fileLevel.rimLightL.SetTweakLightUpdateShadowsEveryFrame( true )

			fileLevel.rimLightR = GetEntByScriptName( LIGHT_RIMR_NAME )
			fileLevel.rimLightR.SetTweakLightRealtimeShadows( true )
			fileLevel.rimLightR.SetTweakLightUpdateShadowsEveryFrame( true )
		}

		// In-World RUI for name
		vector backgroundRuiOrigin = cameraOrigin + (targetCamera.GetForwardVector() * 200)
		vector backgroundRuiAngles = targetPilot.GetAngles()

		fileLevel.backgroundRuiTopo = CreateRUITopology_Worldspace( backgroundRuiOrigin, backgroundRuiAngles * -1, RUI_NAME_PLATE_WIDTH, RUI_NAME_PLATE_HEIGHT )
		fileLevel.backgroundRui = RuiCreate( $"ui/character_select_name_plate_new.rpak", fileLevel.backgroundRuiTopo, RUI_DRAW_WORLD, 0 )

		Chroma_BeginCharacterSelect()

		if( Playlist() == ePlaylists.fs_scenarios )
		{
			RuiSetString( fileLevel.backgroundRui, "nameString", "FLOWSTATE" )
			RuiSetString( fileLevel.backgroundRui, "footnoteString", "POWERED BY R5RELOADED" )
	
			fileLevel.countdownRui = CreateFullscreenRui( $"ui/character_select_timer_new.rpak" )
			RuiSetResolutionToScreenSize( fileLevel.countdownRui )

			RuiSetInt( fileLevel.countdownRui, "yourPick", fileLevel.localClientLockstepIndex + 1 )
			thread CountdownTimerSounds()
			return
		}

		if ( !fileLevel.isBrowseMode )
		{
			fileLevel.countdownRui = CreateFullscreenRui( $"ui/character_select_timer_new.rpak" )
			RuiSetResolutionToScreenSize( fileLevel.countdownRui )
			float pickStartTime = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetTime( "pickLoadoutGamestateStartTime" ) : GetGlobalNetTime( "pickLoadoutGamestateStartTime" )
			Assert( pickStartTime > -1 )
			RuiSetGameTime( fileLevel.countdownRui, "countdownEndTime", pickStartTime )
			RuiSetInt( fileLevel.countdownRui, "yourPick", fileLevel.localClientLockstepIndex + 1 )
			thread CountdownTimerSounds()
		}	
	}
}

void function CountdownTimerSounds()
{
	entity player = GetLocalClientPlayer()
	EndSignal( player, "OnDestroy" )

	wait max( 0.0, SCREEN_COVER_TRANSITION_IN_DURATION + SCREEN_COVER_TRANSITION_OUT_DURATION - 1.0 )

	float pickStartTime = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetTime( "pickLoadoutGamestateStartTime" ) : GetGlobalNetTime( "pickLoadoutGamestateStartTime" )
	float timeRemaining = pickStartTime - Time()

	if ( timeRemaining <= 1.0 )
		return

	wait max( 0.0, timeRemaining % 1.0 )
	wait 0.5

	while( Time() < pickStartTime )
	{
		timeRemaining = pickStartTime - Time()
		EmitSoundOnEntity( player, "UI_Survival_Intro_PreLegendSelect_Countdown" )
		wait 1.0
	}
	Flowstate_ForceRemoveAllObituaries()
}


void function UpdateCamera()
{
	entity player = GetLocalClientPlayer()

	ColorCorrection_SetExclusive( fileLevel.colorCorrection, true )
	ColorCorrection_SetWeight( fileLevel.colorCorrection, 1.0 )
	SetMapSetting_FogEnabled( false )

	if ( fileLevel.menuEntsExist )
	{
		player.SetMenuCameraEntity( fileLevel.camera )
		if (FS_ShouldShowCustomCharacterSelect())
		{
			fileLevel.camera.SetTargetFOV( CAMERA_FOV, true, EASING_CUBIC_INOUT, CAMERA_TRANSITION_DURATION )
		} else {
			fileLevel.camera.SetTargetFOV( CAMERA_FOV_LEGACY, true, EASING_CUBIC_INOUT, CAMERA_TRANSITION_DURATION )
			DoF_SetNearDepthToDefault()
			DoF_SetFarDepthToDefault()
		}
	}
}

void function FooterRui()
{
	int NUM_PLAYERS = MAX_TEAM_PLAYERS

	if( Playlist() == ePlaylists.fs_scenarios )
		NUM_PLAYERS = GetCurrentPlaylistVarInt( "fs_scenarios_playersPerTeam", 3 )

	float startTime = Time()

	for ( int i = 0 ; i < NUM_PLAYERS ; i++ )
	{
		var rui = CreateFullscreenRui( $"ui/character_select_footer_bars.rpak", 300 )

		UISize screenSize = GetScreenSize()
		float aspectRatio = float( screenSize.width ) / float( screenSize.height )
		RuiSetResolution( rui, 1080.0 * aspectRatio, 1080.0 )

		RuiSetInt( rui, "numPlayers", NUM_PLAYERS )
		RuiSetInt( rui, "playerIndex", i )
		RuiSetBool( rui, "lockedCharacter", false )
		RuiSetBool( rui, "isSelecting", false )
		RuiSetBool( rui, "statusTextVisible", true )
		RuiSetBool( rui, "isDisconnected", false )
		RuiSetString( rui, "playerName", "" )
		RuiSetBool( rui, "isJumpmaster", false )

		UISize virtualSize = GetScreenSize()//GetCurrentVirtualScreenSize( false )
		RuiSetFloat2( rui, "virtualRes", <1080.0 * aspectRatio, 1080.0, 0> )

		entity ornull playerForSlot = GetTeammateForPickingIndex( i )
		if ( playerForSlot != null )
		{
			entity player = expect entity( playerForSlot )
			Assert( IsValid( player ) )
			RuiSetInt( rui, "playerTeamColorIndex", player.GetTeamMemberIndex() )
		}

		fileLevel.ruiPlayerBarRuis.append( rui )
	}
}

void function DeleteMenuEntities()
{
	if ( IsValid( fileLevel.camera ) )
		fileLevel.camera.Destroy()
	if ( IsValid( fileLevel.characterModel ) )
		fileLevel.characterModel.Destroy()
	if ( IsValid( fileLevel.characterNode ) )
		fileLevel.characterNode.Destroy()
	if ( IsValid( fileLevel.characterNodeMover ) )
		fileLevel.characterNodeMover.Destroy()
	if ( IsValid( fileLevel.backgroundModelSmoke ) )
		fileLevel.backgroundModelSmoke.Destroy()
	if ( IsValid( fileLevel.backgroundModelGeo ) )
		fileLevel.backgroundModelGeo.Destroy()

	// Fullscreen Ruis
	foreach( var rui in fileLevel.ruiPlayerBarRuis )
		RuiDestroyIfAlive( rui )
	fileLevel.ruiPlayerBarRuis = []

	// In-World RUI
	if ( fileLevel.backgroundRui != null )
	{
		RuiDestroyIfAlive( fileLevel.backgroundRui )
		fileLevel.backgroundRui = null
	}
	if ( fileLevel.backgroundRuiTopo != null )
	{
		RuiTopology_Destroy( fileLevel.backgroundRuiTopo )
		fileLevel.backgroundRuiTopo = null
	}
	if ( fileLevel.countdownRui != null )
	{
		RuiDestroyIfAlive( fileLevel.countdownRui )
		fileLevel.countdownRui = null
	}

	foreach( var rui in fileLevel.gCardRuiHandles )
		RuiDestroyIfAlive( rui )

	foreach( NestedGladiatorCardHandle handle in fileLevel.nestedGladiatorCardHandles )
		CleanupNestedGladiatorCard( handle, true )
	fileLevel.nestedGladiatorCardHandles.clear()

	// Effects
	//if ( EffectDoesExist( fileLevel.smokeFXHandle ) )
	//	EffectStop( fileLevel.smokeFXHandle, true, false )
}

void function Client_FullUpdate()
{
	//printt( "#################" )
	//printt( "Client_FullUpdate" )
	//printt( "#################" )

	thread FixMenuCamera()
}

void function FixMenuCamera()
{
	// We shouldn't have to do a wait R5DEV-53800
	wait 0.1
	entity localClientPlayer = GetLocalClientPlayer()
	if ( fileLevel.menuEntsExist && IsValid( localClientPlayer ) && IsValid( fileLevel.camera ) )
		localClientPlayer.SetMenuCameraEntity( fileLevel.camera )
}

void function Client_UIScriptReset()
{
	printt( "###############" )
	printt( "UI Script Reset" )
	printt( "###############" )

	if ( GetGameState() == eGameState.PickLoadout  || GetCurrentPlaylistVarBool( "character_reselect_enabled", false ))
		thread ReloadMenu()
}

void function ReloadMenu()
{
	WaitFrame()

	if ( GetGameState() != eGameState.PickLoadout || GetCurrentPlaylistVarBool( "character_reselect_enabled", false ))
		return

	CloseCharacterSelectNewMenu()
	WaitFrame()

	if ( GetGameState() != eGameState.PickLoadout || GetCurrentPlaylistVarBool( "character_reselect_enabled", false ))
		return

	OpenCharacterSelectNewMenu()
}

#endif //CLIENT


//	██████╗ ██╗   ██╗████████╗████████╗ ██████╗ ███╗   ██╗     █████╗  ██████╗████████╗██╗ ██████╗ ███╗   ██╗
//	██╔══██╗██║   ██║╚══██╔══╝╚══██╔══╝██╔═══██╗████╗  ██║    ██╔══██╗██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║
//	██████╔╝██║   ██║   ██║      ██║   ██║   ██║██╔██╗ ██║    ███████║██║        ██║   ██║██║   ██║██╔██╗ ██║
//	██╔══██╗██║   ██║   ██║      ██║   ██║   ██║██║╚██╗██║    ██╔══██║██║        ██║   ██║██║   ██║██║╚██╗██║
//	██████╔╝╚██████╔╝   ██║      ██║   ╚██████╔╝██║ ╚████║    ██║  ██║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║
//	╚═════╝  ╚═════╝    ╚═╝      ╚═╝    ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝

#if CLIENT
void function UpdateForFocusOnButtonIndex( int buttonIndex )
{
	ItemFlavor itemFlav = fileLevel.buttonIndexCharacterMap[buttonIndex]

	UpdateCharacterDetailsMenu( fileLevel.detailsRui, itemFlav, false )
	Hud_SetVisible( fileLevel.detailsPanel, fileLevel.detailsPanelVisible )

	// Update our selection to other players if we haven't gotten turn yet, or during our turn
	if ( !fileLevel.isBrowseMode && !GetLocalClientPlayer().GetPlayerNetBool( "hasLockedInCharacter" ) )
		GetLocalClientPlayer().ClientCommand( "UpdateCharacterSelectFocus " + ItemFlavor_GetGUID( itemFlav ) )

	int stepIndex = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )
	// We aren't in browse mode and it's not our turn to pick
	if ( !fileLevel.isBrowseMode && stepIndex != fileLevel.localClientLockstepIndex )
		return

	// If we have a character locked in we don't update the model
	if ( GetLocalClientPlayer().GetPlayerNetBool( "hasLockedInCharacter" ) )
		return

	foreach( func in file.Callbacks_OnCharacterFocused )
		func( itemFlav )

	// Update Scene
	fileLevel.desiredCharacterOrNull = itemFlav
	Signal( fileLevel.signalDummy, "UpdateScene" )
	
	// todo: reimplement character select models:
	// this displays nothing.
	// but like, using actual stgs for actual characters causes even more issues
	// (bodyModel not found)

	// CreateNewCharacterModel(GetGlobalSettingsAsset( DEFAULT_PILOT_SETTINGS, "bodyModel" ))


	
	// Request Loadout. In browse mode we dont change loadout on focus, only activate
	//if ( !fileLevel.isBrowseMode )
	//	RequestSetLoadoutSlot( LocalClientEHI(), Loadout_CharacterClass(), itemFlav )

	//UpdateButtonStates()
}

void function OnLoadoutButton_Focused( var button )
{
	if ( fileLevel.isBrowseMode && ((Time() - fileLevel.isBrowseModeStartTime) < 0.1) )
		return

	int index = fileLevel.characterButtons.find( button )
	UpdateForFocusOnButtonIndex( index )
}

void function OnLoadoutButton_Focused_AimTrainer( var button )
{
	if ( fileLevel.isBrowseMode && ((Time() - fileLevel.isBrowseModeStartTime) < 0.1) )
		return

	int index = fileLevel.characterButtons.find( button )
	UpdateForFocusOnButtonIndex( index )
}

void function DoBrowseModeCharacterSelectEffects()
{
	//
	//ScreenFlash( 0.0, 0.0, 0.0, 0.25, 2.0 )
	ScreenFade( GetLocalViewPlayer(), 0, 0, 0, 255, 2.0, 0.25, FFADE_IN | FFADE_PURGE ) // idk why but ScreenFlash doesn't work here, so using ScreenFade

	//
	thread function() : ()
	{
		wait(0.25)
		entity player = GetLocalViewPlayer()
		if ( IsAlive( player ) )
			PlayClientDialogueOnEntity( GetAnyAliasIdForName( "bc_returnFromRespawn" ), 0, player )
	}()
}

void function OnLoadoutButton_Activate_AimTrainer( var button )
{
	printt( "cafe was here")
	int buttonIndex      = fileLevel.characterButtons.find( button )
	ItemFlavor character = fileLevel.buttonIndexCharacterMap[ buttonIndex ]

	if( Gamemode() == eGamemodes.WINTEREXPRESS )
	{
		if ( fileLevel.isBrowseMode )
		{
			entity player = GetLocalClientPlayer()
			ItemFlavor currentCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
			if ( character == currentCharacter )
			{
				EmitSoundOnEntity( player, "ui_menu_back" )
				CloseCharacterSelectNewMenu()
				return
			}
		}

		// Someone already locked this character
		entity ornull playerWithThisCharacterLocked = GetPlayerWithLockedCharacter( character, GetPlayerSquad() )
		if ( playerWithThisCharacterLocked != null )
			return

	}

	// // Request this character
	RequestSetItemFlavorLoadoutSlot( LocalClientEHI(), Loadout_CharacterClass(), character )

	// Close the menu if we are in browse mode
	// if ( fileLevel.isBrowseMode )
	// {
		// printt(FUNC_NAME() + " isBrowseMode")
		// CloseCharacterSelectNewMenu()
		// DoBrowseModeCharacterSelectEffects()
		// return
	// }

	// Tell the server you want to lock this class
	LockCharacter()

	foreach( func in file.Callbacks_OnCharacterLocked )
		func( character )

	// Update Scene
	fileLevel.desiredCharacterOrNull = character
	SetMenuState( eNewCharacterSelectMenuState.LOCKED )
	
}

void function OnLoadoutButton_Activate( var button )
{
	if ( Hud_IsLocked( button ) )
		return

	int stepIndex = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )
	// We aren't in browse mode and it's not our turn to pick
	if ( !fileLevel.isBrowseMode && stepIndex != fileLevel.localClientLockstepIndex )
		return

	// We already have a character locked
	if ( GetLocalClientPlayer().GetPlayerNetBool( "hasLockedInCharacter" ) )
		return

	int buttonIndex      = fileLevel.characterButtons.find( button )
	ItemFlavor character = fileLevel.buttonIndexCharacterMap[ buttonIndex ]

	if ( fileLevel.isBrowseMode )
	{
		entity player = GetLocalClientPlayer()
		ItemFlavor currentCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
		if ( character == currentCharacter )
		{
			EmitSoundOnEntity( player, "ui_menu_back" )
			CloseCharacterSelectNewMenu()
			return
		}
	}

	// Someone already locked this character
	entity ornull playerWithThisCharacterLocked = GetPlayerWithLockedCharacter( character, GetPlayerSquad() )
	if ( playerWithThisCharacterLocked != null )
		return

	// Request this character
	RequestSetItemFlavorLoadoutSlot( LocalClientEHI(), Loadout_CharacterClass(), character )

	// Close the menu if we are in browse mode
	if ( fileLevel.isBrowseMode )
	{
		printt(FUNC_NAME() + " isBrowseMode")
		CloseCharacterSelectNewMenu()
		DoBrowseModeCharacterSelectEffects()
		return
	}

	// Tell the server you want to lock this class
	LockCharacter()

	foreach( func in file.Callbacks_OnCharacterLocked )
		func( character )

	// Update Scene
	fileLevel.desiredCharacterOrNull = character
	SetMenuState( eNewCharacterSelectMenuState.LOCKED )
}

void function LockCharacter()
{
	entity localClientPlayer = GetLocalClientPlayer()
	if ( !IsValid( localClientPlayer ) )
		return

	EmitSoundOnEntity( localClientPlayer, "UI_Survival_Intro_LegendSelect" )
	thread FlashScreenWhite( 0.1, 0.3 )

	if(!fileLevel.isBrowseMode)
	{
		localClientPlayer.ClientCommand( "Sur_UpdateCharacterLock 1" )
		if( Playlist() != ePlaylists.fs_scenarios )
			localClientPlayer.ClientCommand( "Sur_MakeEligibleForJumpMaster" )
	}
}

void function Client_TryUnlockCharacter()
{
	// Don't have a character locked in to unlock
	if ( !GetLocalClientPlayer().GetPlayerNetBool( "hasLockedInCharacter" ) )
		return

	int stepIndex = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )
	// It's not our turn, can't unlock
	if ( stepIndex != fileLevel.localClientLockstepIndex )
		return

	// Too late to unlock, character selection is ending
	float timeRemaining = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetTime( "characterSelectLockstepEndTime" ) : GetGlobalNetTime( "characterSelectLockstepEndTime" )
	if ( timeRemaining <= 0.0 ) // may want to make this like 1 second, but pro players may be able to swap characters very quickly close to 0.0 so lets try it out
		return

	UnlockCharacter()
}

void function UnlockCharacter()
{
	GetLocalClientPlayer().ClientCommand( "Sur_UpdateCharacterLock 0" )
	StopSoundOnEntity( GetLocalClientPlayer(), "UI_InGame_FD_TitanSelected" )
	SetMenuState( eNewCharacterSelectMenuState.PICKING )
}

void function OnLoadoutButton_RightClick()
{
	if ( fileLevel.isBrowseMode )
	{
		UpdateButtonStates()
		return
	}
	
	int stepIndex = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )
	if ( stepIndex < 0 )
		return

	if ( Playlist() != ePlaylists.fs_scenarios && Time() >= GetGlobalNetTime( "squadPresentationStartTime" ) + 1.0 )
		return

	if ( !fileLevel.detailsPanelVisible )
		EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Menu_Legend_Details" )
	fileLevel.detailsPanelVisible = !fileLevel.detailsPanelVisible
	UpdateButtonStates()
}
#endif //CLIENT


//	██╗███╗   ██╗ ██████╗ ██████╗ ███╗   ███╗███╗   ███╗██╗███╗   ██╗ ██████╗
//	██║████╗  ██║██╔════╝██╔═══██╗████╗ ████║████╗ ████║██║████╗  ██║██╔════╝
//	██║██╔██╗ ██║██║     ██║   ██║██╔████╔██║██╔████╔██║██║██╔██╗ ██║██║  ███╗
//	██║██║╚██╗██║██║     ██║   ██║██║╚██╔╝██║██║╚██╔╝██║██║██║╚██╗██║██║   ██║
//	██║██║ ╚████║╚██████╗╚██████╔╝██║ ╚═╝ ██║██║ ╚═╝ ██║██║██║ ╚████║╚██████╔╝
//	╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝

#if CLIENT

void function OnPlayerDestroyed( entity player )
{
	thread PlayerLeftTeam()
}

void function OnPlayerDisconnected( entity player )
{
	thread PlayerLeftTeam()
}

void function PlayerLeftTeam()
{
	WaitFrame()
	if ( IsConnected() && GetLocalClientPlayer() != null )
		UpdateButtonStates()
}

void function OnLockStepPickIndexChanged( entity player, int old, int new, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if( Playlist() == ePlaylists.fs_scenarios && player != GetLocalClientPlayer() )
		return

	int lockstepIndex = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )

	if ( lockstepIndex == fileLevel.localClientLockstepIndex )
	{
		thread LocalPlayerPickingSounds()
		FlashGameWindow()
	}

	entity ornull pickingPlayer = GetTeammateForPickingIndex( lockstepIndex )
	if ( pickingPlayer != null )
	{
		expect entity( pickingPlayer )
		LoadoutEntry characterSlot = Loadout_CharacterClass()
		EHI pickingPlayerEHI       = ToEHI( pickingPlayer )
		if ( LoadoutSlot_IsReady( pickingPlayerEHI, characterSlot ) )
		{
			ItemFlavor character = LoadoutSlot_GetItemFlavor( pickingPlayerEHI, characterSlot )
			fileLevel.desiredCharacterOrNull = character
		}
	}

	SetMenuState( eNewCharacterSelectMenuState.PICKING )

	UpdateButtonStates()
}

void function OnLockStepPickStartTimeChanged( entity player, float old, float new, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if( Playlist() == ePlaylists.fs_scenarios && player != GetLocalClientPlayer() )
		return

	UpdateButtonStates()
}

void function OnPlayerUpdatedCharacterLock( entity player, bool wasLocked, bool isLocked, bool actuallyChanged )
{
	if ( !fileLevel.menuEntsReady )
		return

	if ( !actuallyChanged )
		return

	if ( !IsValid( player ) )
		return

	entity localPlayer = GetLocalClientPlayer()
	if ( !IsValid( localPlayer ) )
		return

	EHI playerEHI     = ToEHI( player )
	int lockstepIndex = player.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )
	if ( lockstepIndex < 0 )
		return

	if ( player.GetTeam() != localPlayer.GetTeam() )
	{
		UpdateButtonStates()
		return
	}

	if ( isLocked )
	{
		// Player locked a character

		// Get locked character
		LoadoutEntry characterSlot = Loadout_CharacterClass()
		if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
			return
		ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )

		bool doFlash = player != localPlayer
		//if ( fileLevel.lastLockedCharacterOrNull == fileLevel.desiredCharacterOrNull && fileLevel.lastLockedPlayer == player )
		//	doFlash = false
		if ( doFlash )
		{
			// Only do flash and sound for new locks. If it's the same lock as before, for the same player, we don't do it again. This prevents griefing.
			EmitSoundOnEntity( localPlayer, "UI_InGame_FD_TitanSelected" )
			thread FlashScreenWhite( 0.1, 0.3 )
		}

		// Update Scene
		fileLevel.desiredCharacterOrNull = character
		//fileLevel.lastLockedCharacterOrNull = character
		fileLevel.lastLockedPlayer = player
		SetMenuState( eNewCharacterSelectMenuState.LOCKED )
	}
	else
	{
		// Player unlocked their character

		// Update Scene
		fileLevel.desiredCharacterOrNull = null
		SetMenuState( eNewCharacterSelectMenuState.PICKING )
	}

	// Update Button States
	UpdateButtonStates()
}

void function OnPlayerUpdatedCharacterFocus( entity player, int oldFocusIndex, int newFocusIndex, bool actuallyChanged )
{
	if ( !fileLevel.menuEntsReady )
		return

	if ( !actuallyChanged )
		return

	if ( !IsValid( player ) )
		return

	entity localPlayer = GetLocalClientPlayer()
	if ( !IsValid( localPlayer ) )
		return

	// Not a teammate so ignore it
	if ( player.GetTeam() != localPlayer.GetTeam() )
		return

	// Don't do anything if it's me, I'm handled right away on client in the button focus callback
	if ( player == localPlayer )
		return

	// Update Button States
	UpdateButtonStates()

	// If this focus change was from the active picking player we need to update the scene too

	entity ornull playerForSlot = GetTeammateForPickingIndex( Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" ) )
	if ( playerForSlot == null || expect entity( playerForSlot )  != player )
		return

	/*
	// Get character
	EHI playerEHI = ToEHI( player )
	LoadoutEntry characterSlot = Loadout_CharacterClass()
	if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
		return
	ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
	// Get skin
	LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
	if ( !LoadoutSlot_IsReady( playerEHI, skinSlot ) )
		return
	//ItemFlavor skin = LoadoutSlot_GetItemFlavor( playerEHI, skinSlot )
	*/

	if ( !IsValidItemFlavorGUID( newFocusIndex ) )
		return

	ItemFlavor character = GetItemFlavorByGUID( newFocusIndex )

	// Update Scene
	fileLevel.desiredCharacterOrNull = character
	Signal( fileLevel.signalDummy, "UpdateScene" )
}

void function OnLockStepPlayerIndexChanged( entity player, int oldValue, int newValue, bool actuallyChanged )
{
	if ( !actuallyChanged )
		return

	if ( player == GetLocalClientPlayer() )
	{
		if ( fileLevel.countdownRui != null )
			RuiSetInt( fileLevel.countdownRui, "yourPick", newValue + 1 )
	}

	// Update Button States
	UpdateButtonStates()
}

void function OnTeammateLoadoutSelectionChanged( EHI playerEHI, ItemFlavor unused )
{
	// Don't do anything if it's me, I'm handled right away on client in the button focus callback
	if ( playerEHI == LocalClientEHI() )
		return

	// If not on my team we don't do anything
	entity player = FromEHI( playerEHI )
	if ( player == null || !IsValid( player ) )
		return

	entity localClientPlayer = GetLocalClientPlayer()
	if ( !IsValid( localClientPlayer ) )
		return

	if ( player.GetTeam() != localClientPlayer.GetTeam() )
		return

	// The picking player and the local player might be out of sync, so only allow the change if we think it's their turn
	entity ornull playerForSlot = GetTeammateForPickingIndex( Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" ) )
	if ( playerForSlot == null || ToEHI( expect entity( playerForSlot ) ) != playerEHI )
		return

	// Get character
	LoadoutEntry characterSlot = Loadout_CharacterClass()
	if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
		return
	ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )

	// Get skin
	LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
	if ( !LoadoutSlot_IsReady( playerEHI, skinSlot ) )
		return
	//ItemFlavor skin = LoadoutSlot_GetItemFlavor( playerEHI, skinSlot )

	// Update Scene
	fileLevel.desiredCharacterOrNull = character
	Signal( fileLevel.signalDummy, "UpdateScene" )

	// Update Button States
	UpdateButtonStates()
}

void function ServerCallback_CharacterLockRejected()
{
	UnlockCharacter()
	EmitSoundOnEntity( GetLocalClientPlayer(), "ui_ingame_fd_armoryclose" )
}
#endif //CLIENT


//	██╗   ██╗██████╗ ██████╗  █████╗ ████████╗███████╗    ███████╗ ██████╗███████╗███╗   ██╗███████╗
//	██║   ██║██╔══██╗██╔══██╗██╔══██╗╚══██╔══╝██╔════╝    ██╔════╝██╔════╝██╔════╝████╗  ██║██╔════╝
//	██║   ██║██████╔╝██║  ██║███████║   ██║   █████╗      ███████╗██║     █████╗  ██╔██╗ ██║█████╗
//	██║   ██║██╔═══╝ ██║  ██║██╔══██║   ██║   ██╔══╝      ╚════██║██║     ██╔══╝  ██║╚██╗██║██╔══╝
//	╚██████╔╝██║     ██████╔╝██║  ██║   ██║   ███████╗    ███████║╚██████╗███████╗██║ ╚████║███████╗
//	 ╚═════╝ ╚═╝     ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚══════╝    ╚══════╝ ╚═════╝╚══════╝╚═╝  ╚═══╝╚══════╝

#if CLIENT

void function UpdateButtonStates()
{
	if ( !fileLevel.menuEntsReady )
		return

	Assert( fileLevel.characterButtons.len() == fileLevel.characterButtonRuis.len() )

	entity localPlayer    = GetLocalClientPlayer()
	array<entity> players = GetPlayerSquad()

	int currentLockStepIndex = Playlist() == ePlaylists.fs_scenarios ? localPlayer.GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )
	float selectStartTime = Playlist() == ePlaylists.fs_scenarios ? localPlayer.GetPlayerNetTime( "characterSelectLockstepStartTime" ) : GetGlobalNetTime( "characterSelectLockstepStartTime" )
	float selectEndTime = Playlist() == ePlaylists.fs_scenarios ? localPlayer.GetPlayerNetTime( "characterSelectLockstepEndTime" ) : GetGlobalNetTime( "characterSelectLockstepEndTime" )
	bool localPlayerIsLockedIn = localPlayer.GetPlayerNetBool( "hasLockedInCharacter" )

	for ( int i = 0 ; i < fileLevel.characterButtons.len() ; i++ )
	{
		var button = fileLevel.characterButtons[i]

		// menu was closed or ui reset happened
		if ( !IsValid( button ) )
			return

		if ( (!fileLevel.isBrowseMode && (currentLockStepIndex < 0 || currentLockStepIndex >= MAX_TEAM_PLAYERS)) || !fileLevel.buttonIndexUsed.contains( i ) )
		{
			// Lockstep index is -1, meaning the countdown is showing, so hide all buttons
			// OR
			// Lockstep index is = MAX_TEAM_PLAYERS, meaning all players have got their turn, but we want to leave the buttons visible
			// Button not used, make sure it's hidden and disabled

			if ( currentLockStepIndex < 0 || Playlist() != ePlaylists.fs_scenarios && Time() >= GetGlobalNetTime( "squadPresentationStartTime" ) )
				Hud_SetVisible( button, false )

			Hud_SetEnabled( button, false )

			continue
		}

		var buttonRui        = fileLevel.characterButtonRuis[i]
		ItemFlavor character = fileLevel.buttonIndexCharacterMap[ i ]

		// Button is used. Set defaults
		Hud_SetVisible( button, true )
		Hud_SetLocked( button, false )
		Hud_SetEnabled( button, true )
		RuiSetBool( buttonRui, "isFakeDisabled", false )
		RuiSetBool( buttonRui, "isSelecting", currentLockStepIndex == localPlayer.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" ) )

		RuiSetInt( buttonRui, "teamSelectedIndex", -1 )
		RuiSetInt( buttonRui, "teamSelectedTeamColorIndex", -1 )

		for ( int k = 0 ; k < MAX_TEAM_FOCUS_INDEX ; k++ )
			RuiSetBool( buttonRui, "teamFocused" + k, false )

		if ( IsValid( localPlayer ) )
		{
			RuiSetInt( buttonRui, "localPlayerLockstepIndex", localPlayer.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" ) )
			RuiSetInt( buttonRui, "localPlayerTeamColorIndex", localPlayer.GetTeamMemberIndex() )
		}

		bool isLocked = fileLevel.lockedButtonIndexies.contains( i )
		if ( isLocked )
		{
			Hud_SetLocked( button, true )
			Hud_SetEnabled( button, false )
			continue
		}

		// Browse mode we don't need to show locked-in characters, teammate selctions, or disable buttons, etc.
		// Unless is winter express, or any other mode.
		if ( fileLevel.isBrowseMode && Gamemode() == eGamemodes.WINTEREXPRESS )
			continue

		// Team Focused
		foreach( entity player in players )
		{
			if ( PlayerHasCharacterLockedInOrFocused( player, character ) )
			{
				int playerPickIndex = player.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )
				if ( playerPickIndex <= MAX_TEAM_FOCUS_INDEX )
				{
					RuiSetBool( buttonRui, "teamFocused" + playerPickIndex, true )
					RuiSetInt( buttonRui, "teamColorIndex" + playerPickIndex, player.GetTeamMemberIndex() )
				}
			}
		}

		// Locked in character?
		entity ornull playerWithThisCharacterLocked = GetPlayerWithLockedCharacter( character, players )
		bool isLockedInCharacter                    = playerWithThisCharacterLocked != null
		if ( isLockedInCharacter )
		{
			int playerPickIndex = expect entity( playerWithThisCharacterLocked ).GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )

			RuiSetInt( buttonRui, "teamSelectedIndex", playerPickIndex )
			RuiSetInt( buttonRui, "teamSelectedTeamColorIndex", expect entity( playerWithThisCharacterLocked ).GetTeamMemberIndex() )
		}

		// If the local client player has a character locked in, we 'disable' all buttons
		if ( localPlayerIsLockedIn )
		{
			//Hud_SetEnabled( button, false )
			RuiSetBool( buttonRui, "isFakeDisabled", true )
		}
	}

	// Update player footer RUIs
	LoadoutEntry characterSlot = Loadout_CharacterClass()
	for ( int i = 0 ; i < fileLevel.ruiPlayerBarRuis.len() ; i++ )
	{
		var playerRui = fileLevel.ruiPlayerBarRuis[i]

		float pickStartTime = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetTime( "pickLoadoutGamestateStartTime" ) : GetGlobalNetTime( "pickLoadoutGamestateStartTime" )
		RuiSetGameTime( playerRui, "countdownEndTime", pickStartTime )
		RuiSetInt( playerRui, "yourPick", fileLevel.localClientLockstepIndex + 1 )

		// Update selecting status
		RuiSetBool( playerRui, "isSelecting", currentLockStepIndex == i )
		RuiSetBool( playerRui, "showingCharacterDetails", fileLevel.detailsPanelVisible )
		RuiSetFloat( playerRui, "gcardsStartTime", Playlist() == ePlaylists.fs_scenarios ? selectEndTime : GetGlobalNetTime( "squadPresentationStartTime" ) )

		if ( i == currentLockStepIndex )
		{
			RuiSetGameTime( playerRui, "selectingStartTime", selectStartTime )
			RuiSetGameTime( playerRui, "selectingEndTime", selectEndTime )
		}
		else if ( i < currentLockStepIndex )
		{
			RuiSetGameTime( playerRui, "selectingStartTime", 0.0 )
			RuiSetGameTime( playerRui, "selectingEndTime", 0.0 )
		}
		else if ( i < currentLockStepIndex )
		{
			RuiSetGameTime( playerRui, "selectingStartTime", Time() + 999 )
			RuiSetGameTime( playerRui, "selectingEndTime", Time() + 999 )
		}

		entity ornull playerOrNull = GetTeammateForPickingIndex( i )
		if ( IsValid( playerOrNull ) )
		{
			// Update player info
			entity player = expect entity( playerOrNull )
			EHI playerEHI = ToEHI( player )

			RuiSetInt( playerRui, "playerTeamColorIndex", player.GetTeamMemberIndex() )

			bool isJumpmaster = player == GetLastPickingPlayer()

			if ( !(i in fileLevel.connectedPlayerNames) )
				fileLevel.connectedPlayerNames[ i ] <- player.GetPlayerName()
			else
				fileLevel.connectedPlayerNames[ i ] = player.GetPlayerName()

			if ( player.GetPlayerNetBool( "hasLockedInCharacter" ) && LoadoutSlot_IsReady( playerEHI, characterSlot ) )
			{
				// Has Locked-In Character
				ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
				asset lockedPortrait = CharacterClass_GetCharacterLockedPortrait( character )
				if ( lockedPortrait == $"" )
					lockedPortrait = CharacterClass_GetCharacterSelectPortrait( character )
				RuiSetBool( playerRui, "lockedCharacter", true )
				RuiSetString( playerRui, "characterName", ItemFlavor_GetLongName( character ) )
				RuiSetString( playerRui, "playerName", player.GetPlayerName() )
				RuiTrackInt( playerRui, "micStatus", player, RUI_TRACK_MIC_STATUS )
				RuiSetImage( playerRui, "lockedPortraitImage", lockedPortrait )
				RuiSetBool( playerRui, "statusTextVisible", true )
				RuiSetBool( playerRui, "isDisconnected", false )
				RuiSetBool( playerRui, "isJumpmaster", Playlist() == ePlaylists.fs_scenarios ? false : isJumpmaster )
			}
			else
			{
				// No Locked-In Character
				RuiSetBool( playerRui, "lockedCharacter", false )
				RuiSetString( playerRui, "characterName", "" )
				RuiSetString( playerRui, "playerName", player.GetPlayerName() )
				RuiTrackInt( playerRui, "micStatus", player, RUI_TRACK_MIC_STATUS )
				RuiSetImage( playerRui, "lockedPortraitImage", $"" )
				RuiSetBool( playerRui, "statusTextVisible", true )
				RuiSetBool( playerRui, "isDisconnected", false )
				RuiSetBool( playerRui, "isJumpmaster", Playlist() == ePlaylists.fs_scenarios ? false : isJumpmaster )
			}
		}
		else
		{
			// Player disconnected or never existed
			RuiSetBool( playerRui, "lockedCharacter", false )
			RuiSetImage( playerRui, "lockedPortraitImage", $"" )
			RuiSetInt( playerRui, "playerTeamColorIndex", -1 )

			if ( i in fileLevel.connectedPlayerNames )
			{
				// Disconnected player
				string playerName = fileLevel.connectedPlayerNames[ i ]
				RuiSetString( playerRui, "characterName", "Disconnected" )
				RuiSetString( playerRui, "playerName", playerName )
				RuiSetInt( playerRui, "micStatus", 3 )
				RuiSetBool( playerRui, "statusTextVisible", true )
				RuiSetBool( playerRui, "isDisconnected", true )
				RuiSetBool( playerRui, "isJumpmaster", false )
			}
			else
			{
				// Never had a player
				RuiSetString( playerRui, "characterName", "" )
				RuiSetString( playerRui, "playerName", "" )
				RuiSetInt( playerRui, "micStatus", 3 )
				RuiSetBool( playerRui, "statusTextVisible", false )
				RuiSetBool( playerRui, "isDisconnected", false )
				RuiSetBool( playerRui, "isJumpmaster", false )
			}
		}
	}

	// Update Details Panel
	if ( fileLevel.detailsPanelVisible )
	{
		Hud_SetVisible( fileLevel.detailsPanel, true )

		ItemFlavor ornull detailsCharacter = null

		// Update with hovered button character
		for ( int i = 0 ; i < fileLevel.characterButtons.len() ; i++ )
		{
			var button = fileLevel.characterButtons[i]

			if ( !Hud_IsFocused( button ) )
				continue

			detailsCharacter = fileLevel.buttonIndexCharacterMap[ i ]
			break
		}

		// If no hovered button we can use whatever the menu character is
		if ( detailsCharacter == null )
			detailsCharacter = fileLevel.desiredCharacterOrNull

		if ( detailsCharacter != null )
		{
			UpdateCharacterDetailsMenu( fileLevel.detailsRui, expect ItemFlavor( detailsCharacter ), false )
			Hud_SetVisible( fileLevel.detailsPanel, true )
		}
		else
		{
			Hud_SetVisible( fileLevel.detailsPanel, false )
		}
	}
	else
	{
		Hud_SetVisible( fileLevel.detailsPanel, false )
	}

	// Update Footer Text
	RuiSetBool( fileLevel.buttonHintRui, "showingCharacterDetails", fileLevel.detailsPanelVisible )

	string topString    = ""
	string bottomString = ""
	if ( currentLockStepIndex >= 0 && currentLockStepIndex < MAX_TEAM_PLAYERS )
	{
		if ( SquadMuteLegendSelectEnabled() && !IsSoloMode() )
			topString = Localize( IsSquadMuted() ? "#CHAR_SEL_BUTTON_UNMUTE" : "#CHAR_SEL_BUTTON_MUTE" )

		if ( currentLockStepIndex == fileLevel.localClientLockstepIndex )
		{
			if ( localPlayerIsLockedIn )
				bottomString = Localize( "#CHAR_SEL_BUTTON_HINT_CANEL_DETAILS" )
			else
				bottomString = Localize( "#CHAR_SEL_BUTTON_HINT_SELECT_DETAILS" )
		}
		else
		{
			bottomString = Localize( "#CHAR_SEL_BUTTON_HINT_DETAILS" )
		}
	}
	else if ( SquadMuteLegendSelectEnabled() )
	{
		if ( !IsSoloMode() )
			bottomString = Localize( IsSquadMuted() ? "#CHAR_SEL_BUTTON_UNMUTE" : "#CHAR_SEL_BUTTON_MUTE" )
		else
			bottomString = ""
	}

	string finalString = Localize( "#CHAR_SEL_BUTTON_HINT_N_N", topString, bottomString )
	RuiSetString( fileLevel.buttonHintRui, "hintString", finalString )

	Hud_SetVisible( fileLevel.buttonHintPanel, currentLockStepIndex >= 0 && currentLockStepIndex < MAX_TEAM_PLAYERS )
	Hud_SetVisible( fileLevel.buttonHintPanel, true )
}

void function LocalPlayerPickingSounds()
{
	entity player = GetLocalClientPlayer()
	if ( !IsValid( player ) )
		return

	Signal( player, "LocalPlayerPickingSounds" )
	EndSignal( player, "LocalPlayerPickingSounds" )
	EndSignal( player, "OnDestroy" )

	// Start of turn sound
	EmitSoundOnEntity( player, "pilot_collectible_pickup" )

	float lockstepEndTime = Playlist() == ePlaylists.fs_scenarios ? player.GetPlayerNetTime( "characterSelectLockstepEndTime" ) : GetGlobalNetTime( "characterSelectLockstepEndTime" )
	while( Time() < lockstepEndTime )
	{
		float timeRemaining = lockstepEndTime - Time()
		EmitSoundOnEntity( player, "UI_Survival_Intro_LegendSelectCountDown" )
		wait 1.0
	}
}

void function SetMenuState( int state )
{
	fileLevel.desiredMenuState = state
	Signal( fileLevel.signalDummy, "UpdateScene" )
}

void function CharacterSelect_SetMenuState( int state )
{
	SetMenuState( state )
}

void function UpdateSceneThink_AimTrainer()
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	int currentMenuState                     = -1 // eNewCharacterSelectMenuState.PICKING
	ItemFlavor ornull currentCharacterOrNull = fileLevel.desiredCharacterOrNull
	bool playedPickingAnimForCharacter       = false
	bool playedReadyAnimForCharacter         = false
	
	OnThreadEnd(
		function() : ()
		{
			printt("exit UpdateScene thread")
		}
	)
	
	while( true )
	{
		WaitSignal( fileLevel.signalDummy, "UpdateScene" )
	
		if ( fileLevel.desiredMenuState == -1 || fileLevel.desiredCharacterOrNull == null )
			continue

		bool shouldUpdateModel = true
		bool shouldUpdateAnim  = true
		int currentPickIndex   = GetGlobalNetInt( "characterSelectLockstepIndex" )

		bool menuStateChanged = fileLevel.desiredMenuState != currentMenuState
		if ( menuStateChanged )
			currentMenuState = fileLevel.desiredMenuState

		// New character was selected, we want to update the model and animation
		if ( fileLevel.desiredCharacterOrNull != currentCharacterOrNull )
		{
			shouldUpdateModel = true
			shouldUpdateAnim = true
			currentCharacterOrNull = fileLevel.desiredCharacterOrNull
		}

		// Don't update the model or animation if we are seeing a lock-in sequence
		if ( currentPickIndex != fileLevel.localClientLockstepIndex && fileLevel.lastLockedPlayer != GetTeammateForPickingIndex( currentPickIndex ) && Time() - fileLevel.lockSequenceAnimTime < READY_ANIM_MIN_DURATION )
		{
			shouldUpdateAnim = false
			shouldUpdateModel = false
		}


		// A character was just locked in
		if ( menuStateChanged && currentMenuState == eNewCharacterSelectMenuState.LOCKED )
		{
			shouldUpdateAnim = true
			shouldUpdateModel = true
		}

		#if DEVELOPER
			printt( "| -------- UpdateScene --------" )
			printt( "| shouldUpdateModel:", shouldUpdateModel )
			printt( "| shouldUpdateAnim:", shouldUpdateAnim )
			printt( "| -----------------------------" )
		#endif

		if ( shouldUpdateModel )
		{
			// if we change the model we need to update the anim as well
			shouldUpdateAnim = true
			playedPickingAnimForCharacter = false
			playedReadyAnimForCharacter = false

			// Update the model
			thread UpdatePlayerModel( expect ItemFlavor(currentCharacterOrNull) )
		}

		if ( shouldUpdateAnim )
		{
			// Update the anim

			if ( currentMenuState == eNewCharacterSelectMenuState.PICKING )
				playedPickingAnimForCharacter = true
			if ( currentMenuState == eNewCharacterSelectMenuState.LOCKED )
				playedReadyAnimForCharacter = true

			thread UpdatePlayerAnim( expect ItemFlavor(currentCharacterOrNull), currentMenuState )
		}
	}
}
void function UpdateSceneThink()
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	int currentMenuState                     = -1
	ItemFlavor ornull currentCharacterOrNull = null
	bool playedPickingAnimForCharacter       = false
	bool playedReadyAnimForCharacter         = false
	
	while( true )
	{
		WaitSignal( fileLevel.signalDummy, "UpdateScene" )

		if ( fileLevel.desiredMenuState == -1 || fileLevel.desiredCharacterOrNull == null )
			continue

		bool shouldUpdateModel = false
		bool shouldUpdateAnim  = false
		int currentPickIndex   = Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" )

		bool menuStateChanged = fileLevel.desiredMenuState != currentMenuState
		if ( menuStateChanged )
			currentMenuState = fileLevel.desiredMenuState

		// New character was selected, we want to update the model and animation
		if ( fileLevel.desiredCharacterOrNull != currentCharacterOrNull )
		{
			shouldUpdateModel = true
			shouldUpdateAnim = true
			currentCharacterOrNull = fileLevel.desiredCharacterOrNull
		}

		// Don't update the model or animation if we are seeing a lock-in sequence
		if ( currentPickIndex != fileLevel.localClientLockstepIndex && fileLevel.lastLockedPlayer != GetTeammateForPickingIndex( currentPickIndex ) && Time() - fileLevel.lockSequenceAnimTime < READY_ANIM_MIN_DURATION )
		{
			shouldUpdateAnim = false
			shouldUpdateModel = false
		}


		// A character was just locked in
		if ( menuStateChanged && currentMenuState == eNewCharacterSelectMenuState.LOCKED )
		{
			shouldUpdateAnim = true
			shouldUpdateModel = true
		}

		// Don't play a 'picking' anim on a model that already played the 'ready' anim
		if ( currentMenuState == eNewCharacterSelectMenuState.PICKING && playedReadyAnimForCharacter )
		{
			shouldUpdateAnim = false
		}

		//if ( shouldUpdateModel )
		//	shouldUpdateAnim = true

		#if DEVELOPER
			printt( "| -------- UpdateScene --------" )
			printt( "| shouldUpdateModel:", shouldUpdateModel )
			printt( "| shouldUpdateAnim:", shouldUpdateAnim )
			printt( "| -----------------------------" )
		#endif

		if ( shouldUpdateModel )
		{
			// if we change the model we need to update the anim as well
			shouldUpdateAnim = true
			playedPickingAnimForCharacter = false
			playedReadyAnimForCharacter = false

			// Update the model
			thread UpdatePlayerModel( expect ItemFlavor(currentCharacterOrNull) )
		}

		if ( shouldUpdateAnim )
		{
			// Update the anim

			if ( currentMenuState == eNewCharacterSelectMenuState.PICKING )
				playedPickingAnimForCharacter = true
			if ( currentMenuState == eNewCharacterSelectMenuState.LOCKED )
				playedReadyAnimForCharacter = true

			thread UpdatePlayerAnim( expect ItemFlavor(currentCharacterOrNull), currentMenuState )
		}
	}
}


void function SetChromaCharacter( ItemFlavor character )
{
	Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_VERTICAL, CharacterClass_GetChromaGradient( character ), 0.5 )
}

void function UpdatePlayerModel( ItemFlavor character )
///////////////////////////////////////////////////////
//By @CafeFPS (CafeFPS)//
///////////////////////////////////////////////////////
{
	if (FS_ShouldShowCustomCharacterSelect())
	{
		if ( !fileLevel.menuEntsExist )
			return

		if ( !IsValid( fileLevel.characterModel ) )
			return
		
		DoF_SetNearDepth( 7.5, 7.7 )
		DoF_SetFarDepth( 500, 1000 )
		DoFSetDilateInfocus( true )

		entity ornull pickingPlayer = GetTeammateForPickingIndex( Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" ) )
		if ( pickingPlayer == null )
			return
		ItemFlavor characterSkin = LoadoutSlot_WaitForItemFlavor( ToEHI( expect entity( pickingPlayer ) ), Loadout_CharacterSkin( character ) )
		
		if ( !IsValid( fileLevel.characterModel ) )
			return

		CreateNewCharacterModel( CharacterSkin_GetBodyModel( characterSkin ) )
		CharacterSkin_Apply( fileLevel.characterModel, characterSkin )
		fileLevel.characterModel.Show()

		// Model swap effect
		vector rarityColor           = ItemFlavor_GetQualityColor( characterSkin )
		float fillIntensityScalar    = 10
		float outlineIntensityScalar = 300
		float fadeInTime             = 0.01
		float fadeOutTime            = 0.25
		float lifeTime               = 0.1
		float ditherDelay            = 0.1
		float ditherDuration         = 0.1
		thread PROTO_HighlightTest( fileLevel.characterModel, rarityColor / 255, fillIntensityScalar, outlineIntensityScalar, fadeInTime, fadeOutTime, lifeTime, ditherDelay, ditherDuration, false )
	} else {
		//Signal( fileLevel.signalDummy, "UpdatingModel" )
		//EndSignal( fileLevel.signalDummy, "UpdatingModel" )

		//fileLevel.isUpdatePlayerModelRunning = true
		//OnThreadEnd( void function() {
		//	fileLevel.isUpdatePlayerModelRunning = false
		//} )
	//
		if ( !fileLevel.menuEntsExist )
			return

		if ( !IsValid( fileLevel.characterModel ) )
			return

		entity ornull pickingPlayer = GetTeammateForPickingIndex( Playlist() == ePlaylists.fs_scenarios ? GetLocalClientPlayer().GetPlayerNetInt( "characterSelectLockstepIndex" ) : GetGlobalNetInt( "characterSelectLockstepIndex" ) )
		if ( pickingPlayer == null )//&& !fileLevel.isBrowseMode )
			return
		//else
		//	pickingPlayer = GetLocalClientPlayer()

		// Apply Model and Skin
		//expect entity( pickingPlayer )
		ItemFlavor characterSkin = LoadoutSlot_WaitForItemFlavor( ToEHI( expect entity( pickingPlayer ) ), Loadout_CharacterSkin( character ) )



		//ItemFlavor characterSkin = LoadoutSlot_WaitForItemFlavor( ToEHI( pickingPlayer ), Loadout_CharacterSkin( character ) )

		if ( !IsValid( fileLevel.characterModel ) )
			return

		CreateNewCharacterModel( CharacterSkin_GetBodyModel( characterSkin ) )
		CharacterSkin_Apply( fileLevel.characterModel, characterSkin )

		fileLevel.characterModel.Show()

		//Signal( fileLevel.signalDummy, "PlayerModelUpdated" )

		// Model swap effect
		vector rarityColor           = ItemFlavor_GetQualityColor( characterSkin )
		float fillIntensityScalar    = 10
		float outlineIntensityScalar = 300
		float fadeInTime             = 0.01
		float fadeOutTime            = 0.25
		float lifeTime               = 0.1
		float ditherDelay            = 0.1
		float ditherDuration         = 0.1
		thread PROTO_HighlightTest( fileLevel.characterModel, rarityColor / 255, fillIntensityScalar, outlineIntensityScalar, fadeInTime, fadeOutTime, lifeTime, ditherDelay, ditherDuration, false )

		// Background
		int backgroundSkinIndex = CharacterClass_GetMenuBackgroundSkinIndex( character )
		if ( IsValid( fileLevel.backgroundModelGeo ) )
			fileLevel.backgroundModelGeo.SetSkin( backgroundSkinIndex )

		// Smoke Background
		int smokeSkinIndex = CharacterClass_GetMenuSmokeSkinIndex( character )
		if ( IsValid( fileLevel.backgroundModelSmoke ) )
			fileLevel.backgroundModelSmoke.SetSkin( smokeSkinIndex )

		CharacterMenuLightData lightData = CharacterClass_GetMenuLightData( character )
		if ( fileLevel.lightEntsExist )
		{
			fileLevel.keyLight.SetTweakLightColor( lightData.key_color )
			fileLevel.fillLight.SetTweakLightColor( lightData.fill_color )
			fileLevel.rimLightL.SetTweakLightColor( lightData.rimL_color )
			fileLevel.rimLightR.SetTweakLightColor( lightData.rimR_color )
		}
		else
		{
			#if DEVELOPER
				printt( "Map doesn't have menu lights compiled in. Make sure the latest menu box instance is in the level and recompile the map." )
			#endif
		}

		SetChromaCharacter( character )

		// Name and Quote
		RuiSetString( fileLevel.backgroundRui, "nameString", Localize( ItemFlavor_GetLongName( character ) ) )
		RuiSetString( fileLevel.backgroundRui, "footnoteString", Localize( CharacterClass_GetCharacterSelectSubtitle( character ) ) )
		RuiSetFloat( fileLevel.backgroundRui, "startTime", Time() )	
	}
}

array<ItemFlavor> function GetAllGoodAnimsFromGladcardStancesForCharacter(ItemFlavor character)
///////////////////////////////////////////////////////
//By @CafeFPS (CafeFPS)//
/////////////////////////////////////////////////////// 
//Don't try this at home
{
	array<ItemFlavor> actualGoodAnimsForThisCharacter
	
	switch(ItemFlavor_GetHumanReadableRef( character )){
			case "character_pathfinder":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00267302733" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00543164026" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01261908739" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00913866781" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01749100240" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_bangalore":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00775529591" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID02041779191" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID02122844468" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01046964932" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_bloodhound":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00982377873" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00091072289" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01817535639" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00921909335" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01299384641" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00924111436" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_caustic":
		if( MapName() != eMaps.mp_rr_canyonlands_mu2 && MapName() != eMaps.mp_rr_canyonlands_mu1 && MapName() != eMaps.mp_rr_canyonlands_mu1_night && MapName() != eMaps.mp_rr_canyonlands_64k_x_64k ) 
		{actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01037940994" ) ) )}
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01924098215" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00844387739" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01590253725" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01450555761" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_gibraltar":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00335495845" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01763092699" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01066049905" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01139949206" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00558533496" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID02081761479" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_lifeline":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00294421454" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00693685311" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00545796048" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00036505096" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01386679009" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01657023826" ) ) )
		return actualGoodAnimsForThisCharacter

			case "character_mirage":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01262193178" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00986179205" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID02083161296" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00859145007" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00563654629" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00002234092" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_octane":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01115114314" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00718158226" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00914410572" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01698467954" ) ) )
		//actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00796629018" ) ) )
		return actualGoodAnimsForThisCharacter
		
			case "character_wraith":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID02046254916" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01527711638" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01474484292" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01587991597" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID02088801000" ) ) )
		return actualGoodAnimsForThisCharacter

			case "character_wattson":
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01198897745" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01638491567" ) ) )
		if( MapName() != eMaps.mp_rr_canyonlands_mu2 && MapName() != eMaps.mp_rr_canyonlands_mu1 && MapName() != eMaps.mp_rr_canyonlands_mu1_night && MapName() != eMaps.mp_rr_canyonlands_64k_x_64k ) 
		{actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01313080345" ) ) )}
		return actualGoodAnimsForThisCharacter
		
			case "character_crypto":
		if( MapName() != eMaps.mp_rr_canyonlands_mu2 && MapName() != eMaps.mp_rr_canyonlands_mu1 && MapName() != eMaps.mp_rr_canyonlands_mu1_night && MapName() != eMaps.mp_rr_canyonlands_64k_x_64k ) 
		{actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00269538572" ) ) )}
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00814728196" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01157264561" ) ) )
		actualGoodAnimsForThisCharacter.append( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID01574566414" ) ) )
		return actualGoodAnimsForThisCharacter
	}
	return actualGoodAnimsForThisCharacter
}

void function UpdatePlayerAnim( ItemFlavor character, int currentMenuState )
///////////////////////////////////////////////////////
//By @CafeFPS (CafeFPS)//
/////////////////////////////////////////////////////// 
{
	if (FS_ShouldShowCustomCharacterSelect())
	{
	
		if ( !fileLevel.menuEntsExist )
			return

		entity player = GetLocalClientPlayer()
		
		int ThisRoundAnim = RandomIntRangeInclusive(0,GetAllGoodAnimsFromGladcardStancesForCharacter(character).len()-1)
		array<ItemFlavor> animsforthischaracter = GetAllGoodAnimsFromGladcardStancesForCharacter(character)		
		Signal( fileLevel.signalDummy, "UpdatingAnim" )
		EndSignal( fileLevel.signalDummy, "UpdatingAnim" )
		EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

		if ( MapName() == eMaps.mp_rr_desertlands_64k_x_64k || MapName() == eMaps.mp_rr_desertlands_64k_x_64k_nx || MapName() == eMaps.mp_rr_olympus_mu1 || MapName() == eMaps.mp_rr_desertlands_holiday )
				{
					fileLevel.characterModel.SetLocalOrigin( <-70, 0, 0> )
				}
		else if( MapName() == eMaps.mp_rr_canyonlands_mu2 || MapName() == eMaps.mp_rr_canyonlands_mu1 || MapName() == eMaps.mp_rr_canyonlands_mu1_night || MapName() == eMaps.mp_rr_canyonlands_64k_x_64k || MapName() == eMaps.mp_rr_canyonlands_staging )
				{
					if( MapName() == eMaps.mp_rr_canyonlands_staging )
						fileLevel.characterModel.SetLocalOrigin( <33295.4766, -8546.50879, -23723.8008> )
					else
						fileLevel.characterModel.SetLocalOrigin( <8000, -10000, 5000> )
				}
		
		if (IsValid(fileLevel.backgroundModelGeo)) 
			fileLevel.backgroundModelGeo.Destroy()

		if ( MapName() == eMaps.mp_rr_desertlands_64k_x_64k || MapName() == eMaps.mp_rr_desertlands_64k_x_64k_nx || MapName() == eMaps.mp_rr_desertlands_holiday )
		{
			fileLevel.backgroundModelGeo = CreateClientSidePropDynamic( fileLevel.characterModel.GetLocalOrigin() - <0, 0, 5>, fileLevel.characterModel.GetAngles(), BACKGROUND_GEO_MODEL )
			fileLevel.backgroundModelGeo.kv.solid = 6
			fileLevel.backgroundModelGeo.kv.disableshadows = 1
			fileLevel.backgroundModelGeo.kv.fadedist = -1
			fileLevel.characterNode.SetLocalOrigin(fileLevel.characterModel.GetLocalOrigin())
			fileLevel.camera.SetParent( fileLevel.characterModel, "VDU", false )
			fileLevel.camera.SetLocalOrigin(fileLevel.characterModel.GetLocalOrigin() + <60, -10, 10>)
		}
		else if( MapName() == eMaps.mp_rr_canyonlands_mu1 || MapName() == eMaps.mp_rr_canyonlands_mu1_night || MapName() == eMaps.mp_rr_canyonlands_64k_x_64k || MapName() == eMaps.mp_rr_canyonlands_staging || MapName() == eMaps.mp_rr_olympus_mu1 )
		{
			if( MapName() == eMaps.mp_rr_canyonlands_staging )
				fileLevel.backgroundModelGeo = CreateClientSidePropDynamic( fileLevel.characterModel.GetLocalOrigin() - <0, 0, 5>, fileLevel.characterModel.GetAngles(), BACKGROUND_GEO_MODEL_KC )
			else
				fileLevel.backgroundModelGeo = CreateClientSidePropDynamic( fileLevel.characterModel.GetLocalOrigin() - <0, 0, 5>, fileLevel.characterModel.GetAngles(), BACKGROUND_GEO_MODEL_KC )
			fileLevel.backgroundModelGeo.kv.solid = 6
			fileLevel.backgroundModelGeo.kv.disableshadows = 1
			fileLevel.backgroundModelGeo.kv.fadedist = -1
			fileLevel.characterNode.SetLocalOrigin(fileLevel.characterModel.GetLocalOrigin())
			fileLevel.camera.SetParent( fileLevel.characterModel, "VDU", false )
			fileLevel.camera.SetOrigin(fileLevel.characterModel.GetOrigin() + <-10, 40, 60>)
			if( MapName() == eMaps.mp_rr_canyonlands_staging )
				fileLevel.camera.SetOrigin(fileLevel.camera.GetOrigin() + <0, 0, 20>)
		}
		
		if ( currentMenuState == eNewCharacterSelectMenuState.PICKING )
		{
			#if DEVELOPER
				printt( "| PICKING ANIM", fileLevel.characterModel.GetModelName() )
			#endif 
			
			ItemFlavor anim = animsforthischaracter[ThisRoundAnim]
			asset animtoplay = GetGlobalSettingsAsset( ItemFlavor_GetAsset( anim ), "movingAnimSeq" )		
			thread PlayAnim( fileLevel.characterModel, animtoplay, fileLevel.characterNode )

			if ( fileLevel.backgroundRui != null )
			{
				RuiDestroyIfAlive( fileLevel.backgroundRui )
				fileLevel.backgroundRui = null
			}
			if ( fileLevel.backgroundRuiTopo != null )
			{
				RuiTopology_Destroy( fileLevel.backgroundRuiTopo )
				fileLevel.backgroundRuiTopo = null
			}

			var nameRuiTopo = CreateRUITopology_Worldspace( fileLevel.camera.GetOrigin() + (fileLevel.camera.GetForwardVector() * 200) + (fileLevel.camera.GetRightVector() * 15) + (fileLevel.camera.GetUpVector() * 15 ), fileLevel.camera.GetAngles(), RUI_NAME_PLATE_WIDTH, RUI_NAME_PLATE_HEIGHT )
			fileLevel.backgroundRui = RuiCreate( $"ui/character_select_name_plate_new.rpak", nameRuiTopo, RUI_DRAW_WORLD, 0 )
			
			RuiSetString( fileLevel.backgroundRui, "nameString", Localize( ItemFlavor_GetLongName( character ) ) )
			RuiSetString( fileLevel.backgroundRui, "footnoteString", Localize( CharacterClass_GetCharacterSelectSubtitle( character ) ) )
			RuiSetFloat( fileLevel.backgroundRui, "startTime", Time() )
		}
		else if ( currentMenuState == eNewCharacterSelectMenuState.LOCKED )
		{
			#if DEVELOPER
				printt( "| LOCKED ANIM", string(fileLevel.characterModel.GetModelName()) )
			#endif
				
			Chroma_AddOverlay( CHROMALOOP_SMOKE, CHROMAWAVE_FLASH, {[0.0] = <1, 1, 1>}, 2.0 )
			thread PlayCharacterReadyUpLine( character )
			fileLevel.lockSequenceAnimTime = Time()
			
			ItemFlavor anim = animsforthischaracter[ThisRoundAnim]
			asset animtoplay = GetGlobalSettingsAsset( ItemFlavor_GetAsset( anim ), "movingAnimSeq" )		
			thread PlayAnim( fileLevel.characterModel, animtoplay, fileLevel.characterNode )
			
			if ( fileLevel.backgroundRui != null )
			{
				RuiDestroyIfAlive( fileLevel.backgroundRui )
				fileLevel.backgroundRui = null
			}
			if ( fileLevel.backgroundRuiTopo != null )
			{
				RuiTopology_Destroy( fileLevel.backgroundRuiTopo )
				fileLevel.backgroundRuiTopo = null
			}

			var nameRuiTopo = CreateRUITopology_Worldspace( fileLevel.camera.GetOrigin() + (fileLevel.camera.GetForwardVector() * 200) + (fileLevel.camera.GetRightVector() * 10) + (fileLevel.camera.GetUpVector() * 15 ), fileLevel.camera.GetAngles(), RUI_NAME_PLATE_WIDTH, RUI_NAME_PLATE_HEIGHT )
			fileLevel.backgroundRui = RuiCreate( $"ui/character_select_name_plate_new.rpak", nameRuiTopo, RUI_DRAW_WORLD, 0 )
			
			RuiSetString( fileLevel.backgroundRui, "nameString", Localize( ItemFlavor_GetLongName( character ) ) )
			RuiSetString( fileLevel.backgroundRui, "footnoteString", Localize( CharacterClass_GetCharacterSelectSubtitle( character ) ) )
			RuiSetFloat( fileLevel.backgroundRui, "startTime", Time() )
		}
	} else {
	
		if ( !fileLevel.menuEntsExist )
			return

		Signal( fileLevel.signalDummy, "UpdatingAnim" )
		EndSignal( fileLevel.signalDummy, "UpdatingAnim" )
		EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

		if ( currentMenuState == eNewCharacterSelectMenuState.PICKING )
		{
			printt( "| PICKING ANIM", fileLevel.characterModel.GetModelName() )
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_MAIN_INTRO", fileLevel.characterNode )
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_MAIN_IDLE", fileLevel.characterNode )
		}
		else if ( currentMenuState == eNewCharacterSelectMenuState.LOCKED )
		{
			printt( "| LOCKED ANIM", string(fileLevel.characterModel.GetModelName()) )
			Chroma_AddOverlay( CHROMALOOP_SMOKE, CHROMAWAVE_FLASH, {[0.0] = <1, 1, 1>}, 2.0 )
			thread PlayCharacterReadyUpLine( character )
			fileLevel.lockSequenceAnimTime = Time()
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_READYUP_INTRO", fileLevel.characterNode )
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_READYUP_IDLE", fileLevel.characterNode )
		}
	}
}

void function PlayCharacterReadyUpLine( ItemFlavor character )
{
	//EndSignal( fileLevel.signalDummy, "UpdatingAnim" )
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	array<string> readyUpLines = CharacterClass_GetReadyUpVoicelineEventList( character )
	if ( readyUpLines.len() == 0 )
		return

	wait 0.2

	entity player = GetLocalClientPlayer()
	if ( IsValid( player ) )
		EmitSoundOnEntity( player, readyUpLines.getrandom() )
}

void function DebugMenuThink()
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )
	while( true )
	{
		string desiredCharacter = "null"
		if ( fileLevel.desiredCharacterOrNull != null )
			desiredCharacter = ItemFlavor_GetHumanReadableRef( expect ItemFlavor( fileLevel.desiredCharacterOrNull ) )

		string debugString = "-- Menu State --"
		debugString += "\n" + format( "My Turn: %i", fileLevel.localClientLockstepIndex )
		debugString += "\n" + format( "Current Turn: %i", GetGlobalNetInt( "characterSelectLockstepIndex" ) )
		debugString += "\n" + format( "Browse Mode: %s", fileLevel.isBrowseMode ? "true" : "false" )
		debugString += "\n" + format( "Desired Character: %s", desiredCharacter )
		debugString += "\n" + format( "Desired Menu State: %s", DEV_GetEnumStringSafe( "eNewCharacterSelectMenuState", fileLevel.desiredMenuState ) )

		DebugScreenText( 0.05, 0.5, debugString )

		WaitFrame()
	}
}

#endif //CLIENT

#if SERVER
bool function CharacterSelect_AssignCharacter( entity player, ItemFlavor character, bool updateLoadoutSlot = true )
{
	TakeAllPassives( player )
	
	ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	
	if ( updateLoadoutSlot && ItemFlavor_GetHumanReadableRef( playerCharacter ) != ItemFlavor_GetHumanReadableRef( character ) )
	{
		SetItemFlavorLoadoutSlot( ToEHI( player ), Loadout_CharacterClass(), character )
		#if DEVELOPER
			printt( "AssignCharacter: player", player, "is now", ItemFlavor_GetHumanReadableRef( character ) )
		#endif
	}

	player.SetPlayerNetBool( "hasLockedInCharacter", true )
	
	if( ItemFlavor_GetHumanReadableRef( character ) == "character_wattson" )
		player.SetArmsModelOverride( $"mdl/Weapons/arms/pov_pilot_light_wattson.rmdl" )
	else
		player.SetArmsModelOverride( GetGlobalSettingsAsset( CharacterClass_GetSetFile( character ), "armsModel" ) )

	if ( LiveAPI_IsValidToRun() )
	{
		LiveAPI_WriteLogUsingDefinedFields( eLiveAPI_EventTypes.characterSelected, 
			[ LiveAPI_GetPlayerIdentityTable( player ) ], 
			[ 3/*player*/ ]
		)
	}

	return true
}

bool function ClientCommand_UpdateCharacterLock( entity player, array<string> args )
{
	if ( args.len() != 1 )
		return true

	if ( !IsValid( player ) )
		return true

	bool setLocked = args[0] == "1"
	player.SetPlayerNetBool( "hasLockedInCharacter", setLocked )

	return true
}
#endif //SERVER

//  ██╗   ██╗████████╗██╗██╗     ██╗████████╗██╗   ██╗
//  ██║   ██║╚══██╔══╝██║██║     ██║╚══██╔══╝╚██╗ ██╔╝
//  ██║   ██║   ██║   ██║██║     ██║   ██║    ╚████╔╝
//  ██║   ██║   ██║   ██║██║     ██║   ██║     ╚██╔╝
//  ╚██████╔╝   ██║   ██║███████╗██║   ██║      ██║
//   ╚═════╝    ╚═╝   ╚═╝╚══════╝╚═╝   ╚═╝      ╚═╝

#if SERVER
void function AssignLockStepOrder()
{
	#if DEBUG_LOCK_STEP_PICK
		printt( "Lockstep: -------------------------" )
		printt( "Lockstep: ASSIGNING LOCK STEP ORDER" )
		printt( "Lockstep: -------------------------" )
	#endif

	table< int, array<entity> > groupedPlayers = GetAllPlayersSortedByTeam()

	foreach( int team, array<entity> players in groupedPlayers )
	{
		if ( players.len() == 0 )
			continue

		#if DEBUG_LOCK_STEP_PICK
			printt( "Lockstep:   Team", team, "Pick Order:" )
		#endif

		ArrayRemoveInvalid( players )
		players.randomize()
		int i = 0
		foreach( entity player in players )
		{
			#if DEBUG_LOCK_STEP_PICK
				printt( "Lockstep:    ", i + ":", player, player.GetPlayerName() )
			#endif

			player.SetPlayerNetInt( "characterSelectLockstepPlayerIndex", i )
			i++
		}
	}

	fileLevel.assignedLockStepOrder = true

	#if DEBUG_LOCK_STEP_PICK
		printt( "Lockstep: -------------------------" )
		printt( "Lockstep: -------------------------" )
	#endif
}

/*
void function AssignLockStepOrderForTeam( array<entity> players, int team )
{
	#if DEBUG_LOCK_STEP_PICK
		string debugPrintLine = "  Team " + team + " Pick History: "
	#endif

	table< entity, array< int > > pickHistoryData
	foreach( int i, entity player in players )
	{
		array<int> counts = GetPickOrderCountForPlayer( player )

		pickHistoryData[ player ] <- counts

		#if DEBUG_LOCK_STEP_PICK
			if ( i != 0 )
				debugPrintLine += ", "
			debugPrintLine += player.GetPlayerName() + " ["
			foreach( int k, int count in counts )
			{
				if ( k > 0 )
					debugPrintLine += ","
				debugPrintLine += counts[k].tostring()
			}
			debugPrintLine += "]"
		#endif
	}

	#if DEBUG_LOCK_STEP_PICK
		printt( debugPrintLine )
	#endif

	for ( int i = 0 ; i < MAX_TEAM_PLAYERS ; i++ )
	{
		if ( pickHistoryData.len() == 0 )
			return

		entity player = GetBestPlayerForLockStepPick( pickHistoryData, i )

		Assert( IsValid( player ) )
		Assert( player in pickHistoryData )
		delete pickHistoryData[ player ]

		player.SetPlayerNetInt( "characterSelectLockstepPlayerIndex", i )
		#if DEBUG_LOCK_STEP_PICK
			printt( "   ", i + ":", player.GetPlayerName() )
		#endif
		//UpdatePlayerPickOrderHistory( player, i )
	}
}

entity function GetBestPlayerForLockStepPick( table< entity, array< int > > pickHistoryData, int pick )
{
	// Put players into an array so we can randomize the order so that a tie will result in a random tie breaker based on randomize order
	array<entity> players
	foreach( entity player, array<int> data in pickHistoryData )
		players.append( player )
	players.randomize()

	#if DEBUG_LOCK_STEP_PICK
		printt( "      determining best player for pick", pick )
	#endif

	entity pickedPlayer
	int pickedCount = -1
	foreach( entity player in players )
	{
		Assert( player in pickHistoryData )
		Assert( pick in pickHistoryData[ player ] )

		int count = pickHistoryData[ player ][ pick ]
		#if DEBUG_LOCK_STEP_PICK
			printt( "       ", player.GetPlayerName(), "count:", count )
		#endif

		if ( pickedCount < 0 || count < pickedCount )
		{
			pickedPlayer = player
			pickedCount = count
		}
	}

	Assert( IsValid( pickedPlayer ) )

	return pickedPlayer
}

array<int> function GetPickOrderCountForPlayer( entity player )
{
	array<int> pickHistory = GetPersistentIntArray( player, "characterPickOrderHistory" )

	array<int> counts
	counts.resize( MAX_TEAM_PLAYERS )

	foreach( int i, int pick in pickHistory )
	{
		if ( pick == 0.0 )
			continue
		if ( pick > MAX_TEAM_PLAYERS )
			continue
		counts[ pick - 1 ]++
	}

	return counts
}

void function UpdatePlayerPickOrderHistory( entity player, int pick )
{
	array<int> pickHistory = GetPersistentIntArray( player, "characterPickOrderHistory" )
	pickHistory.insert( 0, pick + 1 )
	pickHistory.resize( PersistenceGetArrayCount( "characterPickOrderHistory" ) )
	SetPersistentIntArray( player, "characterPickOrderHistory", pickHistory )
}
*/
void function CharacterSelect_OnClientConnected( entity player )
{
	// Need this to catch late connecting players, ie player connects during character selection they wont have a lock step index set because AssignLockStepOrder was already called
	if ( GetGameState() >= eGameState.Playing )
		return

	if ( !fileLevel.assignedLockStepOrder )
		return

	#if DEVELOPER
		printt( "LATE CONNECTING PLAYER", player, "MISSED LOCK STEP ASSIGNMENT! TRYING TO ASSIGN A NEW ONE..." )
	#endif
	
	int team                   = player.GetTeam()
	array<entity> squadPlayers = GetPlayerArrayOfTeam( team )
	squadPlayers.fastremovebyvalue( player )

	// Make array of all valid lock step indexies someone could have
	array<int> validLockstepIndexies = []
	for ( int i = 0 ; i < MAX_TEAM_PLAYERS ; i++ )
		validLockstepIndexies.append( i )

	// Remove lock step indexies used by teammates already
	foreach( entity squadPlayer in squadPlayers )
	{
		int squadPlayerIndex = squadPlayer.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" )
		if ( validLockstepIndexies.contains( squadPlayerIndex ) )
			validLockstepIndexies.removebyvalue( squadPlayerIndex )
	}
	
	// Player joined lock-step late, and the team was full. Couldn't assign the late player a lockstep index
	if( validLockstepIndexies.len() == 0 ) //fix crash spamming sv_addbot with same team
		return
	
	// Give the player the last available lockstep index that isn't used. We want to give them the last one possible in hopes they will get to pick a character. If we give them the FIRST available they're more likely to miss their turn.
	int pickIndex = validLockstepIndexies.pop()
	printt( "team", team, "player", player, "pick:", pickIndex )

	// Assert that our pick index isn't used yet
	foreach( entity squadPlayer in squadPlayers )
	{
		if( squadPlayer.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" ) == pickIndex )
			return
	}

	#if DEVELOPER
		printt( "LATE CONNECTING PLAYER", player, "NEW LOCK STEP ASSIGNED!", pickIndex )
	#endif
	
	// Assign lockstep index
	player.SetPlayerNetInt( "characterSelectLockstepPlayerIndex", pickIndex )
}

bool function ClientCommand_UpdateCharacterSelectFocus( entity player, array<string> args )
{
	if ( args.len() != 1 )
		return true

	if ( !IsValid( player ) )
		return true

	int focusIndex = int( args[0] )
	if ( !IsValidItemFlavorGUID( focusIndex ) )
	{
		//printt( "GOT INVALID GUID FOCUS", focusIndex )
		focusIndex = -1
	}
	//printt( "GOT GUID FOCUS", focusIndex )

	if ( player.GetPlayerNetBool( "hasLockedInCharacter" ) == true )
	{
		LoadoutEntry characterSlot = Loadout_CharacterClass()
		EHI playerEHI              = ToEHI( player )
		if ( LoadoutSlot_IsReady( playerEHI, characterSlot ) )
		{
			ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
			focusIndex = ItemFlavor_GetGUID( character )
		}
	}

	player.SetPlayerNetInt( "characterSelectFocusIndex", focusIndex )

	return true
}

#endif //SERVER

#if CLIENT

array<int> function GetButtonUseOrder( int count )
{
	if ( count == 4 )
	{
		return [    -1, 0, 1, -1, -1, -1,
			-1, 2, 3, -1, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1
		]
	}

	if ( count <= 6 )
	{
		return [    -1, 0, 1, 2, -1, -1,
			-1, 3, 4, 5, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1
		]
	}

	if ( count <= 8 )
	{
		return [    -1, 0, 1, 2, 3, -1,
			 4,  5,  6,  7, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1
		]
	}

	if ( count <= 9 )
	{
		return [    -1, 0, 1, 2, -1, -1,
			-1, 3, 4, 5, -1, -1,
			-1, 6, 7, 8, -1, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1
		]
	}

	if ( count <= 12 )
	{
		return [    -1, 0, 1, 2, 3, -1,
			-1, 4, 5, 6, 7, -1,
			-1, 8, 9, 10, 11, -1,
			-1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1
		]
	}

	if ( count <= 25 )
	{
		return [    -1, 0, 1, 2, 3, 4,
			-1, 5, 6, 7, 8, 9,
			-1, 10, 11, 12, 13, 14,
			-1, 15, 16, 17, 18, 19,
			-1, 20, 21, 22, 23, 24
		]
	}

	if ( count <= 28 )
	{
		return [     0, 1, 2, 3, 4, 5,
			6, 7, 8, 9, 10, 11,
			12, 13, 14, 15, 16, 17,
			18, 19, 20, 21, 22, 23,
			-1, 24, 25, 26, 27, -1
		]
	}

	//if ( count <= 30 )
	//{
	return [     0, 1, 2, 3, 4, 5,
		6, 7, 8, 9, 10, 11,
		12, 13, 14, 15, 16, 17,
		18, 19, 20, 21, 22, 23,
		24, 25, 26, 27, 28, 29
	]
	//}

	/*
	return [ 	20,  0,  1,  2,  6, 16,
		21,  3,  4,  5,  7, 17,
		22,  8,  9, 10, 11, 18,
		23, 12, 13, 14, 15, 19,
		28, 24, 25, 26, 27, 29
	]
	*/
}

void function CreateNewCharacterModel( asset model )
{
	Assert( IsValid( fileLevel.characterNode ) )

	if ( IsValid( fileLevel.characterModel ) )
		fileLevel.characterModel.Destroy()

	fileLevel.characterModel = CreateClientSidePropDynamic( fileLevel.characterNode.GetOrigin(), fileLevel.characterNode.GetAngles(), model )
	fileLevel.characterModel.MakeSafeForUIScriptHack()
	fileLevel.characterModel.SetParent( fileLevel.characterNode )
	fileLevel.characterModel.Hide()
}
/*
bool function PlayerArrayContainsCurrentLockstepPlayer( array<entity> players )
{
	foreach( entity player in players )
	{
		if ( player.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" ) == GetGlobalNetInt( "characterSelectLockstepIndex" ) )
			return true
	}
	return false
}
*/

bool function PlayerHasCharacterLockedInOrFocused( entity player, ItemFlavor character )
{
	// Player has character locked in
	if ( PlayerHasCharacterLockedIn( player, character ) )
		return true

	// Don't do hover focus if they have a locked character
	if ( player.GetPlayerNetBool( "hasLockedInCharacter" ) )
		return false

	// Player has focus on this character
	if ( player.GetPlayerNetInt( "characterSelectFocusIndex" ) == ItemFlavor_GetGUID( character ) )
		return true

	return false
}

bool function PlayerHasCharacterLockedIn( entity player, ItemFlavor character )
{
	LoadoutEntry characterSlot = Loadout_CharacterClass()

	// player doens't have any character locked in
	if ( !player.GetPlayerNetBool( "hasLockedInCharacter" ) )
		return false

	EHI playerEHI = ToEHI( player )
	if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
		return false

	ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
	return playerCharacter == character
}

entity ornull function GetPlayerWithLockedCharacter( ItemFlavor character, array<entity> players )
{
	// Return what player has the specified character locked, or null if nobody
	LoadoutEntry characterSlot = Loadout_CharacterClass()
	foreach( entity player in players )
	{
		// player doesn't have a character locked in
		if ( !player.GetPlayerNetBool( "hasLockedInCharacter" ) )
			continue

		EHI playerEHI = ToEHI( player )
		if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
			continue

		ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
		if ( playerCharacter == character )
			return player
	}
	return null
}

int function GetButtonIndexForCharacter( ItemFlavor character )
{
	foreach( int index, ItemFlavor itemFlav in fileLevel.buttonIndexCharacterMap )
	{
		if ( character == itemFlav )
			return index
	}
	return -1
}

array<entity> function GetPlayerSquad()
{
	int team                   = GetLocalClientPlayer().GetTeam()
	array<entity> squadPlayers = GetPlayerArrayOfTeam( team )

	ArrayRemoveInvalid( squadPlayers )

	if ( squadPlayers.len() > MAX_TEAM_PLAYERS )
		squadPlayers = squadPlayers.slice( 0, MAX_TEAM_PLAYERS )

	return squadPlayers
}

array<entity> function GetOtherTeammates()
{
	array<entity> teammates = GetPlayerSquad()
	teammates.fastremovebyvalue( GetLocalClientPlayer() )

	if ( teammates.len() > MAX_TEAM_PLAYERS - 1 )
		teammates = teammates.slice( 0, MAX_TEAM_PLAYERS - 1 )

	return teammates
}

entity ornull function GetLastPickingPlayer()
{
	for ( int i = MAX_TEAM_PLAYERS - 1 ; i >= 0 ; i-- )
	{
		entity ornull player = GetTeammateForPickingIndex( i )
		if ( IsValid( player ) )
			return player
	}

	Assert( 0, "GetLastPickingPlayer wasn't able to get the last picking player on local client team" )

	entity invalidPlayer
	return invalidPlayer
}

entity ornull function GetTeammateForPickingIndex( int index )
{
	int team                   = GetLocalClientPlayer().GetTeam()
	array<entity> squadPlayers = GetPlayerArrayOfTeam( team )
	if ( squadPlayers.len() > MAX_TEAM_PLAYERS )
		squadPlayers = squadPlayers.slice( 0, MAX_TEAM_PLAYERS )

	foreach( entity player in squadPlayers )
	{
		if ( player.GetPlayerNetInt( "characterSelectLockstepPlayerIndex" ) == index )
			return player
	}

	return null
}

bool function DoMenuEntsExist()
{
	array<string> entNames =
	[
		CAMERA_ENT_NAME,
		CHARACTER_ENT_NAME,
	]

	//BACKGROUND_ENT_NAME

	foreach ( name in entNames )
	{
		if ( GetEntArrayByScriptName( name ).len() != 1 )
			return false
	}

	return true
}

bool function DoMenuLightsExist()
{
	array<string> entNames =
	[
		LIGHT_KEY_NAME,
		LIGHT_FILL_NAME,
		LIGHT_RIML_NAME,
		LIGHT_RIMR_NAME,
	]

	foreach ( name in entNames )
	{
		if ( GetEntArrayByScriptName( name ).len() != 1 )
			return false
	}

	return true
}

bool function DoesBackgroundEntExist()
{
	// Temp until the maps get recompiled
	return GetEntArrayByScriptName( BACKGROUND_ENT_NAME ).len() > 0
}

void function FlashScreenWhite( float holdTime = 0.5, float fadeOutDuration = 0.5 )
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	if ( !IsValid( fileLevel.whiteFlash ) )
		return

	Hud_SetEnabled( fileLevel.whiteFlash, false )
	Hud_SetAlpha( fileLevel.whiteFlash, 255 )
	Hud_Show( fileLevel.whiteFlash )

	wait holdTime

	if ( !IsValid( fileLevel.whiteFlash ) )
		return

	Hud_FadeOverTime( fileLevel.whiteFlash, 0, fadeOutDuration )

	wait fadeOutDuration

	if ( !IsValid( fileLevel.whiteFlash ) )
		return

	Hud_Hide( fileLevel.whiteFlash )
}

void function UpdateCharacterDetailsMenu( var detailsRui, ItemFlavor character, bool showCharacterName )
{
	RuiSetGameTime( detailsRui, "initTime", Time() )
	if ( LoadoutSlot_IsReady( ToEHI( GetLocalClientPlayer() ), Loadout_CharacterClass() ) )
	{
		CharacterHudUltimateColorData colorData = CharacterClass_GetHudUltimateColorData( character )
		RuiSetColorAlpha( detailsRui, "ultimateColor", SrgbToLinear( colorData.ultimateColor ), 1 )
		RuiSetColorAlpha( detailsRui, "ultimateColorHighlight", SrgbToLinear( colorData.ultimateColorHighlight ), 1 )
	}

	RuiSetImage( detailsRui, "ultimateIcon", ItemFlavor_GetIcon( CharacterClass_GetUltimateAbility( character ) ) )
	RuiSetString( detailsRui, "ultimateName", Localize( ItemFlavor_GetLongName( CharacterClass_GetUltimateAbility( character ) ) ) )
	RuiSetString( detailsRui, "ultimateDesc", Localize( ItemFlavor_GetLongDescription( CharacterClass_GetUltimateAbility( character ) ) ) )
	RuiSetString( detailsRui, "ultimateType", Localize( "#ULTIMATE" ) )

	RuiSetImage( detailsRui, "tacticalIcon", ItemFlavor_GetIcon( CharacterClass_GetTacticalAbility( character ) ) )
	RuiSetString( detailsRui, "tacticalName", Localize( ItemFlavor_GetLongName( CharacterClass_GetTacticalAbility( character ) ) ) )
	RuiSetString( detailsRui, "tacticalDesc", Localize( ItemFlavor_GetLongDescription( CharacterClass_GetTacticalAbility( character ) ) ) )
	RuiSetString( detailsRui, "tacticalType", Localize( "#TACTICAL" ) )

	RuiSetImage( detailsRui, "passiveIcon", ItemFlavor_GetIcon( CharacterClass_GetPassiveAbility( character ) ) )
	RuiSetString( detailsRui, "passiveName", Localize( ItemFlavor_GetLongName( CharacterClass_GetPassiveAbility( character ) ) ) )
	RuiSetString( detailsRui, "passiveDesc", Localize( ItemFlavor_GetLongDescription( CharacterClass_GetPassiveAbility( character ) ) ) )
	RuiSetString( detailsRui, "passiveType", Localize( "#PASSIVE" ) )
}

void function SetCharacterSelectSceneForChampionSquad()
{
	// Remove "Your Squad" banners

	foreach( var rui in fileLevel.gCardRuiHandles )
		RuiDestroyIfAlive( rui )

	foreach( NestedGladiatorCardHandle handle in fileLevel.nestedGladiatorCardHandles )
		CleanupNestedGladiatorCard( handle, true )
	fileLevel.nestedGladiatorCardHandles.clear()

	// Background Black

	if ( IsValid( fileLevel.backgroundModelGeo ) )
		fileLevel.backgroundModelGeo.SetSkin( CHAMPION_SQAUD_BACKGROUND_SKIN_INDEX )

	if ( IsValid( fileLevel.backgroundModelSmoke ) )
		fileLevel.backgroundModelSmoke.SetSkin( CHAMPION_SQAUD_SMOKE_SKIN_INDEX )

	if ( fileLevel.lightEntsExist )
	{
		fileLevel.keyLight.SetTweakLightColor( < 0.5, 0.5, 0.5 > )
		fileLevel.fillLight.SetTweakLightColor( < 0.2, 0.2, 0.2 > )
		fileLevel.rimLightL.SetTweakLightColor( < 0.75, 0.75, 0.75 > )
		fileLevel.rimLightR.SetTweakLightColor( < 0.6, 0.6, 0.6 > )
	}
	else
	{
		#if DEVELOPER
			printt( "Map doesn't have menu lights compiled in. Make sure the latest menu box instance is in the level and recompile the map." )
		#endif
	}
}
#endif

bool function SquadMuteLegendSelectEnabled()
{
	return GetCurrentPlaylistVarBool( "squad_mute_legend_select_enable", true )
}

bool function FS_ShouldShowCustomCharacterSelect()
{
	if( Playlist() == ePlaylists.fs_scenarios || Gamemode() == eGamemodes.WINTEREXPRESS )
		return true

	return GetCurrentPlaylistVarBool( "r5reloaded_AnimatedCharacterSelect", false )
}