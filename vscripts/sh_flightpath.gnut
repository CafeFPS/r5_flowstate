untyped

global function FlightpathShared_Init
global function GetAttachPoints
global function GetPreviewPoint
global function GetAnalysisOffset
global function MaskTester
global function DogFightAnimsFromIndex
global function GetAnalysisForModel
global function HasAnalysisForModel
global function CopyAttachPoint
global function IsActiveNodeAnalysis

global function AddDropshipFlightAnalysis

#if DEVELOPER && SERVER
global function AddNewAnalysis
#endif

global const CLASSIC_MP_SKYSHOW_DOGFIGHTS_DELAY	= 75.0 //Time it takes after EntitiesDidLoad before we start a skyshow of straton/hornet dogfights
global const DROP_MIN_X = 0.0
global const ANALYSIS_STEPS = 8 // the number of different yaw slices to create flightPath on
global const ANALYSIS_YAW_STEP = 360.0 / ANALYSIS_STEPS
global const FIRST_ONLY = false
global const SPAWNPOINT_USE_TIME = 10.0 // stub for real usage
global const MAX_ANALYSIS_COUNT = 64 // in-engine limit to amount of info stored into nodes that script can use
global const DESCRIPTION_MULTIPLIER = 0.0006 // 1666 units per area

global const DROPSHIP_VERTICAL = "dropship_flyer_attack_vertical_successful"
global const DROPSHIP_STRAFE = "gd_goblin_zipline_strafe"
global const DROPSHIP_FLYER_ATTACK_ANIM = "dropship_flyer_attack"
global const DROPSHIP_FLYER_ATTACK_ANIM_VERTICAL = "dropship_flyer_attack_vertical"
global const DROPSHIP_DROP_ANIM = "gd_goblin_zipline_strafe"
global const DROPSHIP_MODEL = $"mdl/vehicle/goblin_dropship/goblin_dropship.rmdl"
global const DROPSHIP_MODEL_OLD = $"mdl/vehicle/goblin_dropship/goblin_dropship.rmdl"

global const STRATON_FLIGHT_ANIM = "st_gunship_dogfight_C"
global const STRATON_DOGFIGHT_ANIM1 = "st_Dogfight_Target_1"
global const STRATON_DOGFIGHT_ANIM2 = "st_Dogfight_Target_2"
global const STRATON_DOGFIGHT_ANIM3 = "st_Dogfight_Target_3"
global const STRATON_DOGFIGHT_ANIM1_PERSUER = "st_Dogfight_Persuer_1"
global const STRATON_DOGFIGHT_ANIM2_PERSUER = "st_Dogfight_Persuer_2"
global const STRATON_DOGFIGHT_ANIM3_PERSUER = "st_Dogfight_Persuer_3"
global const STRATON_ATTACK_FULL = "st_AngelCity_IMC_Win_Full"
//global const FX_HORNET_DEATH =  $"P_veh_exp_hornet_HS" //TODO: "mdl\vehicle\hornet\hornet_fighter_dest_l_wing.rmdl" does not exist. This particle system requires it. All references have been commented for now.


global const AIRDROP_BASE_ANIM = "dp_droppod_idle"
global const HOTDROP_TURBO_ANIM = "at_hotdrop_drop_2knee_turbo"
global const TURBO_WARP_FX = $"P_warp_in_atlas"
global const TURBO_WARP_COMPANY = $"hotdrop_hld_warp"

global const FX_GUNSHIP_CRASH_EXPLOSION = $"droppod_impact_black"
global const FX_GUNSHIP_CRASH_EXPLOSION_ENTRANCE = $"veh_gunship_warp_FULL"
global const FX_GUNSHIP_CRASH_EXPLOSION_EXIT = $"veh_gunship_warp_OUT_FULL"

global const float WARPFALL_SOUND_DELAY = 1.1
global const float WARPFALL_FX_DELAY = 0.9

global enum eFlightPathAnalysisIndex
{
	DROPPOD_AIRDROP_BASE_ANIM = 0,
	CARE_PACKAGE_AIRDROP_IDLE = 1,
	RESPAWN_DROPSHIP_FLYIN_MOVE = 2,
	#if(false)

#endif
	UNUSED4 = 4,
	UNUSED5 = 5,
	UNUSED6 = 6,
}
// #if HAS_CAPITAL_SHIP_SKYSHOW
// global const TRINITY_SKYBOX = $"mdl/vehicles_r2/spacecraft/trinity/Trinity_1000x.rmdl"
// global const DRACONIS_SKYBOX = $"mdl/vehicles_r2/spacecraft/draconis/draconis_flying_1000x.rmdl"
// #endif

global struct NodeFP
{
	vector origin
	vector angles
	string name
	int uniqueID
	vector attachOrigin
	vector attachAngles
	vector vec
	float dot

	float fraction
	string attachName
	float rating
}

global struct DropTable
{
	table<string,table<string,NodeFP> > nodes
	bool valid
}

global struct CallinData
{
	vector		origin
	float		yaw
	bool 		yawSet

	int			team
	entity		owner
	vector 		ownerEyePos
	bool 		ownerEyePosSet

	float		dist
	string		squadname
	int			style
	bool 		styleSet
	int			dropshipHealth
	bool		success
	array<entity functionref( int, vector, vector )> npcSpawnFuncs

	DropTable 	dropTable
	entity		dropship

	// for dropships specifically
	string 		side = "both"
	string 		anim
	string 		customSnd
	bool  		forcedPosition = false
}

global struct SpawnPointFP
{
	bool 	valid
	vector 	origin
	vector 	angles
	int 	node
}

global struct AttachPoint
{
	vector origin
	vector angles
	string name
	int node
}

global NodeFP NullNodeFP
global typedef nodeFPOrNull var

global struct FlightPath
{
	vector mins
	vector maxs
	int traceMask = TRACE_MASK_NPCWORLDSTATIC
	string idleAnim
	bool hasIdleAnim = false
	bool useNPC = false
	string npcClass = ""
	table<string,array<AttachPoint> > deployAttach
	array<int> nodes
	asset model
	string anim
	int iterator
	int hull
	array<AttachPoint> points
	AttachPoint preview
}


#if SERVER
	//global function ShowAllTitanFallSpots
	global function ShowAllAirdropNodes
	global function CodeCallback_AINFileBuilt
	global function AddCallback_AINFileBuilt
	global function CreateSimpleFlightAnalysis
	//global function DebugDropship
	global function AnaylsisFuncLegalFlightPath
	global function TryAnalysisAtOrigin
	global function GetRandomDropshipDropoffAnims

	global function AddDropshipDropTable
	global function GetDropshipDropTable
	global function HasDropshipDropTable

	global function SkyboxCapitalShips
	global function StratonHornetDogfights
	//global function SpawnRandomDogFight
	global function StratonHornetDogfightsIntense
	//global function GetFlightPathModel
	//global function HasFlightPathModel

	global function GetAnalysisDataIndex
	global function GetTitanfallNodesInRadius
	//global function DisableTitanfallForLifetimeOfEntityNearOrigin
	//global function DisableTitanfallForNodes
	//global function TemporarilyDisableTitanfallAroundRadius

	global function AddTitanfallBlocker
	global function InitializeFlightAnalysis
	global function PassedAnalysisFunc
	global function AnalysisHasPrepSpawnpointFunc
	global function RunAnalysisPrepFunc


	struct
	{
		//table<FlightPath, table<string,array<AttachPoint> > functionref( FlightPath, vector, float ) > flightAnalysisFuncs
		table<FlightPath, bool functionref( FlightPath, vector, float ) > flightAnalysisFuncs
		table<FlightPath, var functionref( FlightPath, vector, float ) > analysisPrepSpawnpointFunc

		table<asset, table<string, int> > ainAnalysisIndices

		table<entity, DropTable> dropshipDropOffDropTable
		//table<string,asset> flightPathModel
		table<asset,string> flightPathAttachOffset

		var dataTable
		int nameColumn
		int modelColumn
		string skyboxCamName
		array< void functionref() > ainFileBuiltCallbacks = []
	} file
#endif // SERVER

struct
{
	table<asset, table<string, FlightPath> > flightAnalysis
	array<string> dropshipDropoffAnims
	bool activeNodeAnalysis = false
} shFile


void function FlightpathShared_Init()
{
	FlagInit( "DisableDropships", false )

	FlagInit( "DogFights" )
	FlagInit( "FlyerPickupAnalysis" )
	FlagInit( "StratonFullAttack" )
	FlagInit( "FlightPath_TitanDrop" )
	FlagInit( "FlightPath_Airdrop" )

	FlagSet( "FlightPath_Airdrop" )

	// #if HAS_CAPITAL_SHIP_SKYSHOW
	// PrecacheModel( TRINITY_SKYBOX )
	// PrecacheModel( DRACONIS_SKYBOX )
	// #endif

	#if SERVER
	//file.dataTable = GetDataTable( DATA_TABLE_FLIGHT_PATH_ASSETS ) // todo(dw): 369837
	//file.nameColumn = GetDataTableColumnByName( file.dataTable, "name" )
	//
	//file.modelColumn = GetDataTableColumnByName( file.dataTable, "mp_model" )
	#endif // server

	level.drawAnalysisPreview <- false

	level.testHardPoints <- []
	level.testFlagSpawnPoints <- []
	level.titanfallBlockers <- []

	level.superCallinOffset <- {}
	level.superCallinOffset[ DROPSHIP_MODEL ] <- 700.0
	level.superCallinOffset[ DROPSHIP_MODEL_OLD ] <- 700.0

	shFile.dropshipDropoffAnims.append( DROPSHIP_STRAFE )
	// angel is using all 8 ain slots so we can't add the extra zipline anim to it.
	shFile.dropshipDropoffAnims.append( DROPSHIP_VERTICAL )

	// the purpose of this script is to cache animation movement, to be able to check via traces whether or not it can be used

	FlagInit( "FlightAnalysisReady" )
	FlagInit( "StratonFlybys" )

	RegisterSignal( "StratonHornetDogfights" )
	RegisterSignal( "ClearDisableTitanfall" )

	level.spawnPointsInUse <- {}
	level.disallowedTitanfalls <- {}

	AddCallback_EntitiesDidLoad( EntitiesDidLoad )
}

void function EntitiesDidLoad()
{
	if ( IsMenuLevel() )
		return

	#if SERVER
	//InitFlightPathAsset( "fp_dropship_model" )
	//InitFlightPathAsset( "fp_dropship_hero_model" )
	//
	//if ( !IsMenuLevel() )
	//{
	//	if ( !Flag( "DisableDropships" ) )
	//	{
	//		for ( int i = 0; i < shFile.dropshipDropoffAnims.len(); i++ )
	//		{
	//			AddAinAnalysisIndex( DROPSHIP_MODEL, shFile.dropshipDropoffAnims[i] )
	//			AddAinAnalysisIndex( DROPSHIP_MODEL_OLD, shFile.dropshipDropoffAnims[i] )
	//		}
	//	}
	//}
	//
	//if ( Flag( "StratonFlybys" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_straton_model" )
	//	InitFlightPathAsset( "fp_hornet_model" ) // generally needed when straton is precached
	//	AddAinAnalysisIndex( model, STRATON_FLIGHT_ANIM )
	//}
	//
	//if ( Flag( "DogFights" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_straton_model" )
	//	InitFlightPathAsset( "fp_hornet_model" ) // generally needed when straton is precached
	//	AddAinAnalysisIndex( model, STRATON_DOGFIGHT_ANIM1 )
	//	AddAinAnalysisIndex( model, STRATON_DOGFIGHT_ANIM2 )
	//}
	//
	//if ( Flag( "StratonFullAttack" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_straton_model" )
	//	InitFlightPathAsset( "fp_hornet_model" ) // generally needed when straton is precached
	//	// straton attacks a spot
	//	AddAinAnalysisIndex( model, STRATON_ATTACK_FULL )
	//}
	//
	//// TODO: use more generic model
	//CreateSimpleFlightAnalysis( $"mdl/humans/class/medium/pilot_medium_bloodhound.rmdl", "mp_pt_medium_zipline_slide_idle" )
	//
	//asset dropshipModel = InitFlightPathAsset( "fp_dropship_model" )
	//
	FlightPath flightPath
	//string event
	//if ( !Flag( "DisableDropships" ) )
	//{
	//	event = "dropship_deploy"
	//	flightPath = CreateFlightAnalysis( dropshipModel, DROPSHIP_STRAFE, GetDropshipRopeAttachments(), event )
	//	AddBoundingMins( flightPath, <-325,-325,-96> )
	//	AddBoundingMaxs( flightPath, <325,325,185> )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncDropshipFindDropNodes, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 2 ) // iterate every other node
	//
	//	#if DEVELOPER
	//	bool foundDropoffSpawnpoint = FlightPathHasNodeAndMatchesAINData( flightPath )
	//	#endif
	//
	//	flightPath = CreateFlightAnalysis( dropshipModel, DROPSHIP_VERTICAL, GetDropshipRopeAttachments(), event )
	//	AddBoundingMins( flightPath, <-325,-325,-96> )
	//	AddBoundingMaxs( flightPath, <325,325,185> )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncDropshipFindDropNodes, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 2 ) // iterate every other node
	//
	//	#if DEVELOPER
	//	if ( !foundDropoffSpawnpoint )
	//	{
	//		if ( !FlightPathHasNodeAndMatchesAINData( flightPath ) && !Flag( "DisableDropships" ) )
	//			Warning( "There are no player dropship dropoff nodes. Add Dropsip Spawn Start, rebuild AIN or set flag DisableDropships." )
	//	}
	//	#endif
	//}
	//
	//if ( Flag( "StratonFlybys" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_straton_model" )
	//	InitFlightPathAsset( "fp_hornet_model" ) // generally needed when straton is precached
	//	flightPath = CreateFlightAnalysis( model, STRATON_FLIGHT_ANIM, {} )
	//	AddFighterBounds( flightPath )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncLegalFlightPath, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 1 )
	//}
	//
	//if ( Flag( "DogFights" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_straton_model" )
	//	InitFlightPathAsset( "fp_hornet_model" ) // generally needed when straton is precached
	//	flightPath = CreateFlightAnalysis( model, STRATON_DOGFIGHT_ANIM1, {} )
	//	AddFighterBounds( flightPath )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncLegalFlightPath, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 1 )
	//
	//	flightPath = CreateFlightAnalysis( model, STRATON_DOGFIGHT_ANIM2, {} )
	//	AddFighterBounds( flightPath )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncLegalFlightPath, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 1 )
	//
	//	flightPath = CreateFlightAnalysis( model, STRATON_DOGFIGHT_ANIM3, {} )
	//	AddFighterBounds( flightPath )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncLegalFlightPath, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 1 )
	//}
	//
	//if ( Flag( "StratonFullAttack" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_straton_model" )
	//	InitFlightPathAsset( "fp_hornet_model" ) // generally needed when straton is precached
	//	flightPath = CreateFlightAnalysis( model, STRATON_ATTACK_FULL, {} )
	//	AddFighterBounds( flightPath )
	//	AddAnalysisFunc( flightPath, AnaylsisFuncLegalFlightPath, HULL_HUMAN )
	//	AddAnalysisIterator( flightPath, 1 )
	//}
	//
	//asset modeldropshipModel = InitFlightPathAsset( "fp_dropship_model" )
	//flightPath = CreateFlightAnalysis( modeldropshipModel, "gd_flyin_A_left_localnodes", GetDropshipRopeAttachments(), event )
	//AddBoundingMins( flightPath, <-325,-325,-96> )
	//AddBoundingMaxs( flightPath, <325,325,185> )
	//AddAnalysisFunc( flightPath, AnaylsisFuncDropshipFindDropNodes, HULL_HUMAN )
	//AddAnalysisIterator( flightPath, 2 ) // iterate every other node
	//
	//
	//// buffer the height to account for ground plane abnormality
	////AddAnalysisPoint( flightPath, <13.915,8.58578,50>, <0.00356261,0.0105928,0.00143976> )
	////AddAnalysisPoint( flightPath, <15.4668,8.58606,50>, <0.00356261,0.0105928,0.00143976> )
	//
	//if ( Flag( "FlightPath_TitanDrop" ) )
	//{
	//	asset model = InitFlightPathAsset( "fp_titan_model" )
	//
	//	flightPath = CreateFlightAnalysis( model, HOTDROP_TURBO_ANIM, {} )
	//	AddBoundingMins( flightPath, <-65,-65,0> )
	//	AddBoundingMaxs( flightPath, <65,65,240> )
	//	AddAnalysisTraceMask( flightPath, CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_GRATE | CONTENTS_MOVEABLE | CONTENTS_TITANCLIP )
	//
	//	AddIdleAnimation( flightPath, "at_idle_2" )
	//	AddAnalysisFunc( flightPath, TitanFindDropNodes, HULL_TITAN )
	//	//AddPrepSpawnpointFunc( flightPath, TitanHulldropSpawnpoint )
	//	AddAnalysisIterator( flightPath, 1 ) // iterate each node
	//}

	/*if ( Flag( "FlyerPickupAnalysis" ) )
	{
		foreach ( animation in GetFlyerPickupAnimations() )
		{
			if ( !animation.hasAnalysis )
				continue

			AddAinAnalysisIndex( FLYER_MODEL, animation.flyer )

			InitializeFlightAnalysis( animation.flightPath, FLYER_MODEL, animation.flyer, {} )
			flightPath = animation.flightPath
			AddBoundingMins( flightPath, <-200,-200,20> )
			AddBoundingMaxs( flightPath, <200,200,100> )
			AddAnalysisTraceMask( flightPath, TRACE_MASK_SHOT_HULL )
			AddAnalysisFunc( flightPath, AnaylsisFuncLegalFlightPath, HULL_HUMAN )
			AddAnalysisIterator( flightPath, 1 )
		}
	}*/

	if ( Flag( "FlightPath_Airdrop" ) )
	{
		AddAinAnalysisIndex( DROPPOD_MODEL, AIRDROP_BASE_ANIM )

		asset model = DROPPOD_MODEL //InitFlightPathAsset( "fp_titan_model" )

		flightPath = CreateFlightAnalysis( model, AIRDROP_BASE_ANIM, {} )
		AddBoundingMins( flightPath, <-65,-65,0> )
		AddBoundingMaxs( flightPath, <65,65,240> )
		AddAnalysisTraceMask( flightPath, CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_GRATE | CONTENTS_MOVEABLE | CONTENTS_TITANCLIP )

		AddIdleAnimation( flightPath, AIRDROP_BASE_ANIM )
		AddAnalysisFunc( flightPath, TryAirdropPoint, HULL_TITAN )
		AddAnalysisIterator( flightPath, 1 ) // iterate each node



		// THIS IS THE FLIGHT ANALYSIS USED FOR END ZONE CIRCLES
		// WE NEED TO USE A DIFFERENT MODEL / ANIM COMBO TO CREATE A UNIQUE ENTRY
		AddAinAnalysisIndex( CARE_PACKAGE_AIRDROP_MODEL, CARE_PACKAGE_IDLE )
		flightPath = CreateFlightAnalysis( CARE_PACKAGE_AIRDROP_MODEL, CARE_PACKAGE_IDLE, {} )
		AddBoundingMins( flightPath, <-65,-65,0> )
		AddBoundingMaxs( flightPath, <65,65,240> )
		AddAnalysisTraceMask( flightPath, CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_GRATE | CONTENTS_MOVEABLE | CONTENTS_TITANCLIP )

		AddIdleAnimation( flightPath, AIRDROP_BASE_ANIM )
		AddAnalysisFunc( flightPath, TryCircleEndZone, HULL_TITAN )
		AddAnalysisIterator( flightPath, 1 ) // iterate each node
	}

	FlagSet( "FlightAnalysisReady" )
	#endif
}

#if SERVER

//asset function InitFlightPathAsset( string name )
//{
//	int row = GetDataTableRowMatchingStringValue( file.dataTable, file.nameColumn, name )
//	Assert( row > -1, "Didn't find " + name )
//	asset model = GetDataTableAsset( file.dataTable, row, file.modelColumn )
//	PrecacheModel( model )
//	file.flightPathModel[ name ] <- model
//	return model
//}

//asset function GetFlightPathModel( string name )
//{
//	Assert( name in file.flightPathModel, "Model " + name + " has not been loaded" )
//	return file.flightPathModel[ name ]
//}

//bool function HasFlightPathModel( string name )
//{
//	return name in file.flightPathModel
//}

int function GetAnalysisDataIndex( FlightPath flightPath )
{
	return file.ainAnalysisIndices[ flightPath.model ][ flightPath.anim ] * ANALYSIS_STEPS
}

array<string> function GetRandomDropshipDropoffAnims()
{
	array<string> anims = clone shFile.dropshipDropoffAnims
	anims.randomize()
	return anims
}

#endif

void function DrawAnalysis( FlightPath flightPath )
{
	array<AttachPoint> points = flightPath.points
	for ( int i = 1; i < points.len(); i++ )
	{
		AttachPoint point1 = points[i-1]
		AttachPoint point2 = points[i]
		DebugDrawLine( point1.origin, point2.origin, 255, 0, 0, true, 15.0 )
	}
}

bool function HasAnalysisForModel( asset model, string animation )
{
	if ( !( model in shFile.flightAnalysis ) )
		return false
	return animation in shFile.flightAnalysis[ model ]
}

FlightPath function GetAnalysisForModel( asset model, string animation )
{
	Assert( model in shFile.flightAnalysis )
	Assert( animation in shFile.flightAnalysis[ model ] )

	return shFile.flightAnalysis[ model ][ animation ]
}

void function InitFlightAnalysis( FlightPath flightPath )
{
	flightPath.deployAttach[ "left" ] <- []
	flightPath.deployAttach[ "right" ] <- []
}

FlightPath function CreateFlightAnalysis( asset model, string anim, table<string, array<string> > attachments, string event = "" )
{
	FlightPath Table
	InitializeFlightAnalysis( Table, model, anim, attachments, event )
	return Table
}

FlightPath function CreateFlightAnalysisNPC( asset model, string anim, table<string, array<string> > attachments, string event = "" )
{
	FlightPath Table
	Table.npcClass = "npc_dropship"
	Table.useNPC = true
	InitializeFlightAnalysis( Table, model, anim, attachments, event )
	return Table
}

FlightPath function InitializeFlightAnalysis( FlightPath Table, asset model, string anim, table<string, array<string> > attachments, string event = "" )
{
	InitFlightAnalysis( Table )
	if ( !( model in shFile.flightAnalysis ) )
	{
		shFile.flightAnalysis[ model ] <- {}
	}

	Assert( !( anim in shFile.flightAnalysis[ model ] ), "Already added " + anim + " to flight flightPath for " + model )


	Table.model = model
	Table.anim = anim

	entity dropship = CreatePropDynamic( model, <0,0,0>, <0,0,0> )

	// TODO: TEMP this is because dropships do not translate properly when they are prop dynamics.  Haggerty is fixing this.  Remove this when fixed.
	#if SERVER
	if ( Table.useNPC )
	{
		dropship.Destroy()
		dropship = CreateEntity( Table.npcClass )
		DispatchSpawn( dropship )
		dropship.SetModel( model )
	}
	#endif

	Table.points = FillFlightAnalysisPoints( dropship, anim )
	if ( Table.points.len() )
		CopyAttachPoint( Table.points.top(), Table.preview )

	if ( event != "" )
	{
		FillDeployForAnalysisForEvent( dropship, anim, event, Table, attachments )
	}

	/*
	local points = Table.points
	for ( int i = 0; i + 1 < points.len(); i++ )
	{
		DebugDrawLine( points[i].origin, points[i+1].origin, 255, 0, 0, true, 20.0 )
	}
	*/

	dropship.Destroy()

	//Table.model <- model
	shFile.flightAnalysis[ model ][ anim ] <- Table
	return Table
}

void function CopyAttachPoint( AttachPoint source, AttachPoint destination )
{
	destination.origin = source.origin
	destination.angles = source.angles
	destination.name = source.name
}

void function DrawAnalysisArray( Array )
{
	array< table<string, int> > colors
	colors.append( { r = 255, g = 155, b = 10 } )
	colors.append( { r = 55, g = 55, b = 250 } )

	int index = 0
	table<string, int> color
	for ( int i = 0; i + 1 < Array.len(); i++ )
	{
		index++
		index %= colors.len()
		color = colors[ index ]
		DebugDrawLine( Array[i].origin, Array[i+1].origin, color.r, color.g, color.b, true, 15.0 )
	}
}

array<AttachPoint> function FillFlightAnalysisPoints( entity dropship, string anim )
{
	dropship.Hide()

	// try to precompute the various flight paths. Disabled because angle info is coming in wrong.
	string attachName = "ORIGIN"
	int attachIndex = dropship.LookupAttachment( attachName )
	if ( attachIndex == 0 )
	{
		attachName = "OFFSET"
		attachIndex = dropship.LookupAttachment( attachName )
		if ( attachIndex == 0 )
			return []
	}

	float duration = dropship.GetSequenceDuration( anim )
	int steps = int( duration * 1.5 )
	float time, ratio
	array<AttachPoint> Array

	if ( !steps )
	{
		Attachment result = dropship.Anim_GetAttachmentAtTime( anim, attachName, 0.0 )

		AttachPoint point
		vector pos = result.position
		if ( pos.z < DROP_MIN_X )
			pos.z = DROP_MIN_X

		point.origin = pos
		point.angles = result.angle

		Array.append( point )
		return Array
	}

	for ( int i = 0; i <= steps; i++ )
	{
		ratio = float( i ) / float( steps )
		time = duration * ratio
		Attachment result = dropship.Anim_GetAttachmentAtTime( anim, attachName, time )

		AttachPoint point
		vector pos = result.position
		if ( pos.z < DROP_MIN_X )
			pos.z = DROP_MIN_X

		point.origin = pos
		point.angles = result.angle

		Array.append( point )
	}

	table removed
	for ( int i = 1; i + 1 < Array.len(); i++ )
	{
		vector pR = Array[ i - 1 ].origin
		vector p = Array[ i ].origin
		vector pF = Array[ i + 1 ].origin

		vector vec1 = pR - pF
		vector vec2 = pR - p

		vec1.Norm()
		vec2.Norm()

		float dot = DotProduct( vec1, vec2 )

		if ( dot > 0.998 )
			removed[ Array[i] ] <- true
	}

	for ( int i = 0; i < Array.len(); i++ )
	{
		if ( Array[i] in removed )
		{
			Array.remove( i )
			i--
		}
	}

	return Array
}

void function AddIdleAnimation( FlightPath flightPath, string anim )
{
	flightPath.idleAnim = anim
	flightPath.hasIdleAnim = true
}

void function AddAnalysisTraceMask( FlightPath flightPath, int mask )
{
	flightPath.traceMask = mask
}

void function AddBoundingMaxs( FlightPath flightPath, vector maxs )
{
	flightPath.maxs = maxs
}

void function AddBoundingMins( FlightPath flightPath, vector mins )
{
	flightPath.mins = mins
}

void function AddAnalysisIterator( FlightPath flightPath, int iterator )
{
	flightPath.iterator = iterator
}

array<AttachPoint> function GetAttachPoints( FlightPath flightPath, string side )
{
	return flightPath.deployAttach[ side ]
}

/*void function AddAnalysisPoint( FlightPath flightPath, vector org, vector ang )
{
	Point point
	if ( org.z < DROP_MIN_X )
		org.z = DROP_MIN_X
	point.origin = org

	// bounding boxes currently ignore pitch and roll
	//ang.x = 0
	//ang.z = 0
	point.angles = ang
	flightPath.points.append( point )
}*/

void function AddPreviewPoint( FlightPath flightPath, vector org, vector ang )
{
	//if ( org.z < DROP_MIN_X )
	//	org.z = DROP_MIN_X
	AttachPoint point = flightPath.preview
	point.origin = org
	point.angles = ang
}

Point function GetPreviewPoint( FlightPath flightPath )
{
	Point point
	point.origin = flightPath.preview.origin
	point.angles = flightPath.preview.angles
	return point
}

void function FillDeployForAnalysisForEvent( entity dropship, string anim, string event, FlightPath Table, table<string, array<string> > attachments )
{
	float frac = dropship.GetScriptedAnimEventCycleFrac( anim, event )
	Assert( frac != -1, " event " + event + " does not exist in animation " + anim )
	if ( !frac )
		return

	float duration = dropship.GetSequenceDuration( anim )
	float time = duration * frac
	Attachment result = dropship.Anim_GetAttachmentAtTime( anim, "ORIGIN", time )

	AttachPoint point = Table.preview
	point.origin = result.position
	point.angles = result.angle

	if ( attachments.len() )
	{
		Table.deployAttach = {}

		foreach ( side, attachArray in attachments )
		{
			Table.deployAttach[ side ] <- []
			for ( int i = 0; i < attachArray.len(); i++ )
			{
				string attach = attachArray[i]
				result = dropship.Anim_GetAttachmentAtTime( anim, attach, time )

				AttachPoint pos
				pos.origin = result.position
				pos.angles = result.angle
				pos.name = attach

				Table.deployAttach[ side ].append( pos )
			}
		}
	}
}

#if SERVER
void function AddAnalysisFunc( FlightPath flightPath, bool functionref( FlightPath, vector, float ) func, int hull )
{
	file.flightAnalysisFuncs[ flightPath ] <- func
	flightPath.hull = hull
}

bool function PassedAnalysisFunc( FlightPath flightPath, vector vec1, float float1 )
{
	bool functionref( FlightPath, vector, float ) func = file.flightAnalysisFuncs[ flightPath ]

	return func( flightPath, vec1, float1 )
}

void function AddPrepSpawnpointFunc( FlightPath flightPath, var functionref( FlightPath, vector, float ) func )
{
	file.analysisPrepSpawnpointFunc[ flightPath ] <- func
}

bool function AnalysisHasPrepSpawnpointFunc( FlightPath flightPath )
{
	return flightPath in file.analysisPrepSpawnpointFunc
}

var function RunAnalysisPrepFunc( FlightPath flightPath, vector vec1, float float1 )
{
	return file.analysisPrepSpawnpointFunc[ flightPath ]( flightPath, vec1, float1 )
}
#endif // SERVER

/*
function LegalFlightPath( flightPath, origin, angles )
{
}
*/

vector function GetAnalysisOffset( FlightPath flightPath )
{
	if ( flightPath.model in level.superCallinOffset )
		return <0,0,level.superCallinOffset[ flightPath.model ]>

	return <0,0,0>
}

void function MaskTester( int mask )
{
	printt( "called from " + DumpPreviousFunction() )
	table Table
	Table[" CONTENTS_EMPTY				"] <- CONTENTS_EMPTY
	Table[" CONTENTS_SOLID				"] <- CONTENTS_SOLID
	Table[" CONTENTS_WINDOW				"] <- CONTENTS_WINDOW
	Table[" CONTENTS_AUX				"] <- CONTENTS_AUX
	Table[" CONTENTS_GRATE				"] <- CONTENTS_GRATE
	Table[" CONTENTS_SLIME				"] <- CONTENTS_SLIME
	Table[" CONTENTS_WATER				"] <- CONTENTS_WATER
	Table[" CONTENTS_WINDOW_NOCOLLIDE	"] <- CONTENTS_WINDOW_NOCOLLIDE
	Table[" CONTENTS_OPAQUE				"] <- CONTENTS_OPAQUE
	Table[" CONTENTS_TESTFOGVOLUME		"] <- CONTENTS_TESTFOGVOLUME
	Table[" CONTENTS_PHYSICSCLIP		"] <- CONTENTS_PHYSICSCLIP
	Table[" CONTENTS_NOGRAPPLE			"] <- CONTENTS_NOGRAPPLE
	Table[" CONTENTS_IGNORE_NODRAW_OPAQUE	"] <- CONTENTS_IGNORE_NODRAW_OPAQUE
	Table[" CONTENTS_MOVEABLE				"] <- CONTENTS_MOVEABLE
	Table[" CONTENTS_PLAYERCLIP			"] <- CONTENTS_PLAYERCLIP
	Table[" CONTENTS_MONSTERCLIP			"] <- CONTENTS_MONSTERCLIP
	Table[" CONTENTS_BLOCKLOS				"] <- CONTENTS_BLOCKLOS
	Table[" CONTENTS_NOCLIMB				"] <- CONTENTS_NOCLIMB
	Table[" CONTENTS_TITANCLIP			"] <- CONTENTS_TITANCLIP
	Table[" CONTENTS_BULLETCLIP			"] <- CONTENTS_BULLETCLIP
	Table[" CONTENTS_MONSTER				"] <- CONTENTS_MONSTER
	Table[" CONTENTS_DEBRIS				"] <- CONTENTS_DEBRIS
	Table[" CONTENTS_DETAIL				"] <- CONTENTS_DETAIL
	Table[" CONTENTS_TRANSLUCENT			"] <- CONTENTS_TRANSLUCENT
	Table[" CONTENTS_OCCLUDESOUND			"] <- CONTENTS_OCCLUDESOUND
	Table[" CONTENTS_SOUNDTRIGGER			"] <- CONTENTS_SOUNDTRIGGER
	Table[" CONTENTS_HITBOX				"] <- CONTENTS_HITBOX

	foreach ( key, val in Table )
	{
		if ( val & mask )
			printt( "found " + key )
	}
}


#if SERVER
int function AddNewAnalysis( asset model, string anim, var nodeIndex = null )
{
	printt( "Writing Analysis for " + model + " " + anim )

	int nodeCount = NavMeshNode_GetNodeCount()
	FlightPath flightPath = GetAnalysisForModel( model, anim )

	vector offset = GetAnalysisOffset( flightPath )

	int iterator = flightPath.iterator
	Assert( iterator, "Iterator not set!" )

	int functionref( FlightPath, int, vector ) func

	if ( shFile.activeNodeAnalysis )
		func = NodeAnalysis
	else
		func = NodeAnalysisPreview

	int total = 0
	int dataIndex = GetAnalysisDataIndex( flightPath )
	printt( "dataIndex: " + dataIndex )

	if ( nodeIndex != null )
	{
		expect int( nodeIndex )
		total += func( flightPath, nodeIndex, offset )
	}
	else
	{
		for ( int index = 0; index < nodeCount; index += iterator )
		{
			//printt( "Node " + index + " / " + nodeCount )
			total += func( flightPath, index, offset )
		}
	}

	return total
}
#endif // SERVER


array<table> function FillFlightAnalysisPoints2( entity dropship, string anim )
{
	dropship.Hide()

	array<table> Array

	// try to precompute the various flight paths. Disabled because angle info is coming in wrong.
	int attachIndex = dropship.LookupAttachment( "ORIGIN" )
	if ( attachIndex == 0 )
		return Array

	float duration = dropship.GetSequenceDuration( anim )
	int steps = int( duration * 15 )
	float time, ratio

	int stepper = int( steps * 0.98 )
	printt( "stepper " + stepper )

	for ( int i = 0; i <= steps; i++ )
	{
		ratio = i / float( steps )
		time = duration * ratio
		Attachment result = dropship.Anim_GetAttachmentAtTime( anim, "ORIGIN", time )

		table point
		vector pos = result.position
		if ( pos.z < DROP_MIN_X )
			pos.z = DROP_MIN_X

		//result.angle.z = 0
		point.origin <- pos
		point.angles <- result.angle
		point.skip <- stepper > 0 && i % stepper == 0

		Array.append( point )
	}

	for ( ;; )
	{
		bool smoothed = false
		for ( int i = 1; i + 1 < Array.len(); i++ )
		{
			if ( Array[i].skip )
				continue

			vector pR = expect vector( Array[ i - 1 ].origin )
			vector p = expect vector( Array[ i ].origin )
			vector pF = expect vector( Array[ i + 1 ].origin )

			vector vec1 = p - pR
			vector vec2 = p - pF
			float length = Length( vec1 ) + Length( vec2 )

			vec1.Norm()
			vec2.Norm()

			float dot = DotProduct( vec1, vec2 )

			//if ( dot < 0.99999
			if ( length < 100 )
			{
				if ( dot < -0.8 )
				{
					//printt( "dot " + dot )
					Array.remove( i )
					i--
					smoothed = true
					continue
				}
			}
			else if ( length < 1000 )
			{
				if ( dot < -0.99 )
				{
					//printt( "dot " + dot )
					Array.remove( i )
					i--
					smoothed = true
					continue
				}
			}
			else if ( length < 4000 )
			{
				if ( dot < -0.995 )
				{
					//printt( "dot " + dot )
					Array.remove( i )
					i--
					smoothed = true
					continue
				}
			}
			else
			{
				if ( dot < -0.999 )
				{
					//printt( "dot " + dot )
					Array.remove( i )
					i--
					smoothed = true
					continue
				}
			}
		}

		if ( !smoothed )
			break
	}

	return Array
}

#if SERVER

void function AddCallback_AINFileBuilt( void functionref() callbackFunc )
{
	//Assert( !( callbackFunc in file.ainFileBuiltCallbacks), "Allready added callback func" + callbackFunc + " in AddCallback_AINFileBuilt" )
	file.ainFileBuiltCallbacks.append( callbackFunc )
}

void function CodeCallback_AINFileBuilt()
{
	SetAINScriptVersion( AIN_REV )

	if ( NavMeshNode_GetNodeCount() <= 0 )
		return

	if ( Flag( "FlightPath_TitanDrop" ) )
	{
		array<asset> allTitanSettings = GetAllowedPlayerTitanSettings()
		asset titanSettings
		foreach ( settings in allTitanSettings )
		{
			asset model = GetGlobalSettingsAsset( settings, "bodyModel" )
			if ( !ModelIsPrecached( model ) )
				continue

			titanSettings = settings
			break
		}

	 	Assert( titanSettings != $"", "Trying to use Flag FlightPath_TitanDrop, but there are no titans precached for this level" )

		level.ainTestTitan <- CreateNPCTitanFromSettings( titanSettings, TEAM_IMC, <0,0,0>, <0,0,0> )
	}

	level.testHardPoints = GetEntArrayByClass_Expensive( "info_hardpoint" )
	level.testFlagSpawnPoints = GetEntArrayByClass_Expensive( "info_spawnpoint_flag" )

	printt( "Building AIN file" )
	shFile.activeNodeAnalysis = true
	array<table> totals

	foreach ( model, Table in file.ainAnalysisIndices )
	{
		foreach ( anim, offset in Table )
		{
			printt( "Prebuilding node info for " + model + " / " + anim + "." )
			int count = AddNewAnalysis( model, anim )
			table InfoTable
			InfoTable.count <- count
			InfoTable.anim <- anim
			InfoTable.model <- model
			totals.append( InfoTable )
		}
	}

	if ( Flag( "FlightPath_TitanDrop" ) )
		level.ainTestTitan.Destroy()

	if ( MapRequiresFullFlightpathSupport() )
	{
		bool foundZero = false
		asset modelWithZeroPaths = $""
		string animWithZeroPaths = ""

		foreach ( total in totals )
		{
			printt( "Found " + total.count + " cases of " + total.model + " " + total.anim )
			if ( total.count == 0 )
			{
				foundZero = true
				modelWithZeroPaths = expect asset( total.model )
				animWithZeroPaths = expect string( total.anim )
			}
		}

		if ( !level.isTestmap )
		{
			Assert( !foundZero, "Found zero of expected anim path " + animWithZeroPaths + " for model " + modelWithZeroPaths + ". Make sure spectre nodes didn't leak, or there are enough path nodes in level!" )
		}
	}

	foreach( callbackFunc in file.ainFileBuiltCallbacks )
		callbackFunc()

	if ( GetCurrentPlaylistName() != "buildain" )
		return

	int modeIdx = 0
	if ( GetCurrentPlaylistGamemodeByIndex( modeIdx ) != "tdm" )
		return

	string currentMapName = GetMapName()
	int numMaps = GetCurrentPlaylistGamemodeByIndexMapsCount( modeIdx )
	int nextMapIdx = 0
	for ( int mapIdx = 0; mapIdx < numMaps; ++mapIdx )
	{
		string mapName = GetCurrentPlaylistGamemodeByIndexMapByIndex( modeIdx, mapIdx )
		if ( mapName == currentMapName )
		{
			nextMapIdx = mapIdx + 1
			break
		}
	}

	if ( nextMapIdx >= numMaps )
		return

	string mapName = GetCurrentPlaylistGamemodeByIndexMapByIndex( modeIdx, nextMapIdx )
	GameRules_ChangeMap( mapName, "tdm" )
}

void function AddAinAnalysisIndex( asset model, string anim )
{
	int count = 0
	foreach ( key, value in file.ainAnalysisIndices )
	{
		foreach ( item in value )
		{
			count++
		}
	}

	if ( !( model in file.ainAnalysisIndices ) )
	{
		file.ainAnalysisIndices[ model ] <- {}
	}

	file.ainAnalysisIndices[ model ][ anim ] <- count
	Assert( count + ANALYSIS_STEPS <= MAX_ANALYSIS_COUNT )
}

bool function NodeHasCallInForDataIndex( int nodeIndex, int dataIndex )
{
	for ( int i = dataIndex; i < dataIndex + ANALYSIS_STEPS; i++ )
	{
		if ( NavMeshNode_GetBooleanData( nodeIndex, i ) )
			return true
	}

	return false
}

void function CreateSimpleFlightAnalysis( asset model, string anim )
{
	string attachName
	if ( model in file.flightPathAttachOffset )
		attachName = file.flightPathAttachOffset[ model ]
	else
		attachName = "ORIGIN"
	// need this to find the difference between ref and origin for the zipline slide
	entity pete = CreatePropDynamic( model )
	Attachment result = pete.Anim_GetAttachmentAtTime( anim, attachName, 0.0 )

	FlightPath flightPath = CreateFlightAnalysis( model, anim, {} )
	AddPreviewPoint( flightPath, result.position, result.angle )
	pete.Kill_Deprecated_UseDestroyInstead()
}

/*
function CompareDropshipModels( mdl1, mdl2, attachments )
{
	wait 3

	entity model2 = CreatePropDynamic( mdl2, <0,0,0>, <0,0,0> )

	local attachment = "RopeAttachRightC"
	local attachid2 = model2.LookupAttachment( attachment )
	local origin2 = model1.GetAttachmentOrigin( attachid2 )
	local angles2 = model1.GetAttachmentAngles( attachid2 )

	DrawArrow( origin2, angles2, 30.0, 100 )
	DebugDrawText( origin2 + <0,0,20>, mdl2, true, 30.0 )

	/ *
	return
	entity model1 = CreatePropDynamic( mdl1, <0,0,0>, <0,0,0> )
	entity model2 = CreatePropDynamic( mdl2, <0,0,0>, <0,0,0> )

	//attachments.origin <- [ "origin" ]
	local Orgattachid1 = model1.LookupAttachment( "origin" )
	local Orgattachid2 = model2.LookupAttachment( "origin" )
	local Orgorigin1 = model1.GetAttachmentOrigin( Orgattachid1 )
	local Orgorigin2 = model1.GetAttachmentOrigin( Orgattachid2 )

	foreach ( Array in attachments )
	{
		foreach ( attachment in Array )
		{
			entity ent1 = CreateOwnedScriptMover( model1 )
			entity ent2 = CreateOwnedScriptMover( model2 )
			ent1.SetParent( model1, attachment )
			ent2.SetParent( model2, attachment )
			printt( ent1.GetOrigin() )
			printt( ent2.GetOrigin() )
			printt( Distance( ent1.GetOrigin() )
			//local attachid1 = model1.LookupAttachment( attachment )
			//local attachid2 = model2.LookupAttachment( attachment )
			//local origin1 = model1.GetAttachmentOrigin( attachid1 )
			//local origin2 = model1.GetAttachmentOrigin( attachid2 )
			//local angles1 = model2.GetAttachmentAngles( attachid1 )
			//local angles2 = model2.GetAttachmentAngles( attachid2 )

			//DrawArrow( origin1, angles1, 30, 100 )
			//DrawArrow( origin2, angles2, 30, 100 )
			//DebugDrawText( origin1 + <0,0,20>, mdl1, true, 30 )
			//DebugDrawText( origin2 + <0,0,20>, mdl2, true, 30 )

			//DebugDrawText( origin1, attachment, true, 30 )
			//DebugDrawText( origin2, attachment, true, 30 )
			//printt( "Attach " + attachment )
			//printt( "Origin dist " + Distance( origin1, origin2 ) )
			//printt( "dist from origin1 " + Distance( Orgorigin1, origin1 ) )
			//printt( "dist from origin2 " + Distance( Orgorigin2, origin2 ) )
			//printt( "angles1 " + angles1 )
			//printt( "angles2 " + angles2 )
			//printt( " " )
		}
	}
	* /
}
*/

#if SERVER
//void function DebugDropship()
//{
//	thread DebugDropshipThread()
//}

//void function DebugDropshipThread()
//{
//	string event = "dropship_deploy"
//	table<string, array<string> > attaches = GetDropshipRopeAttachments()
//	foreach ( anim in shFile.dropshipDropoffAnims )
//	{
//		printt( "testing anim " + anim )
//		FlightPath flightPath = GetAnalysisForModel( DROPSHIP_MODEL, anim )
//		waitthread TestDropshipAnalysis( flightPath )
//	}
//}
#endif

//void function TestDropshipAnalysis( FlightPath flightPath )
//{
//	//int nodeCount = NavMeshNode_GetNodeCount()
//	vector offset = GetAnalysisOffset( flightPath )
//	local iterator = flightPath.iterator
//	Assert( iterator, "Iterator not set!" )
//
//	int dataIndex = GetAnalysisDataIndex( flightPath )
//	printt( "dataIndex: " + dataIndex )
//
//	//for ( int index = 0; index < nodeCount; index += iterator )
//	int index = 24
//	{
//		//printt( "Node " + index + " / " + nodeCount )
//		TestDropshipAnalysisFunc( flightPath, index, offset )
//	}
//}

//void function TestDropshipSquad( guys, int nodeIndex, int yawIndex )
//{
//	printt( "Guys dropped: " + guys.len() )
//	//Assert( guys.len() == 6 )
//
//	wait 8
//
//	foreach ( entity guy in guys )
//	{
//		if ( IsAlive( guy ) )
//		{
//			vector ornull clampedPos = NavMesh_ClampPointForAI( guy.GetOrigin(), guy )
//
//			if ( clampedPos == null )
//			{
//				Warning( "No node for guy from dropship node: " + nodeIndex + " with yaw index " + yawIndex )
//				DebugDrawAxis( guy.GetOrigin(), <0,0,0>, 10.0, 150 )
//				continue
//			}
//			guy.Die()
//		}
//	}
//}

//void function TestDropshipAnalysisFunc( FlightPath flightPath, int index, vector offset )
//{
//	vector origin = NavMeshNode_GetNodePos( index )
//	origin = origin + offset
//
//	int dataIndex = GetAnalysisDataIndex( flightPath )
//
////	for ( int p = 0; p < ANALYSIS_STEPS; p++ )
//	int p = 0
//	{
//		if ( NavMeshNode_GetBooleanData( index, p + dataIndex ) )
//		{
//	//		if ( !array[ p ] )
//	//		{
//	////			printt( ( p + dataIndex ) + ": False" )
//	//			continue
//	//		}
//	//
//	////		printt( ( p + dataIndex ) + ": True" )
//
//			float yaw = p * ANALYSIS_YAW_STEP
//			vector angles = <0,yaw,0>
//			vector forward = AnglesToForward( angles )
//			DebugDrawLine( origin, origin + forward * 80, 255, 100, 0, true, 5.0 )
//
//			CallinData drop
//			InitCallinData( drop )
//			drop.origin 	= origin
//			drop.yaw 		= yaw
//			drop.anim		= flightPath.anim
//			drop.team 		= TEAM_MILITIA
//			SetCallinStyle( drop, eDropStyle.FORCED )
//
//			thread RunDropshipDropoff( drop )
//			WaitSignal( drop, "WarpedIn" )
//
//			table result = WaitSignal( drop, "OnDropoff" )
//			thread TestDropshipSquad( result.guys, index, p )
//
//			drop.dropship.WaitSignal( "OnDeath" )
//		}
//	}
//}

//void function ShowAllTitanFallSpots()
//{
//	wait 0.5
//	FlightPath flightPath = GetAnalysisForModel( GetFlightPathModel( "fp_titan_model" ), HOTDROP_TURBO_ANIM )
//
//	int nodeCount = NavMeshNode_GetNodeCount()
//	//vector offset = GetAnalysisOffset( flightPath )
//	local iterator = flightPath.iterator
//	int dataIndex = GetAnalysisDataIndex( flightPath )
//
//	/*vector up = <0,0,10>
//	vector down = <0,0,-10>
//	vector right = <0,10,0>
//	vector left = <0,-10,0>
//	vector forward = <10,0,0>
//	vector back = <-10,0,0>*/
//
//	vector origin
//	bool drawThrough = false
//	float time = 120.0
//
//	array<vector> yawVecs
//	for ( int i = 0; i < ANALYSIS_STEPS; i++ )
//	{
//		float yaw = i * ANALYSIS_YAW_STEP
//		vector forward = AnglesToForward( <0,yaw,0> )
//		yawVecs.append( forward * 20.0 )
//	}
//
//	printt( "checking dataIndex " + dataIndex )
//
//	int hits = 0
//	for ( int i = 0; i < nodeCount; i++ )
//	{
//		//i = 2414
//		origin = NavMeshNode_GetNodePos( i )
//		for ( int p = 0; p < ANALYSIS_STEPS; p++ )
//		{
//			if ( NavMeshNode_GetBooleanData( i, p + dataIndex ) )
//			{
//				DebugDrawLine( origin, origin + yawVecs[p], 0, 255, 0, drawThrough, time )
//				hits++
//			}
//			else
//			{
//				DebugDrawLine( origin, origin + yawVecs[p], 255, 0, 0, drawThrough, time )
//			}
//		}
//		//return
//
//		/*if ( NodeHasFlightPath( dataIndex, i ) )
//		{
//			DebugDrawLine( origin + down, origin + up, 0, 255, 0, drawThrough, time )
//			DebugDrawLine( origin + right, origin + left, 0, 255, 0, drawThrough, time )
//			DebugDrawLine( origin + forward, origin + back, 0, 255, 0, drawThrough, time )
//		}
//		else
//		{
//			DebugDrawLine( origin + down, origin + up, 255, 0, 0, drawThrough, time )
//			DebugDrawLine( origin + right, origin + left, 255, 0, 0, drawThrough, time )
//			DebugDrawLine( origin + forward, origin + back, 255, 0, 0, drawThrough, time )
//		}*/
//	}
//
//	printt( "Found " + hits + " uses of this sequence." )
//}

bool function TryAirdropPoint( FlightPath flightPath, vector baseOrigin, float yaw )
{
	if ( IsPointOutOfBounds( baseOrigin ) )
		return false

	// Airdrops doesn't use animations right now so no need to pass that info along
	return VerifyAirdropPoint( baseOrigin, yaw )
}

bool function TryCircleEndZone( FlightPath flightPath, vector baseOrigin, float yaw )
{
	#if SERVER
	if ( !SURVIVAL_IsValidCircleLocation( baseOrigin ) )
		return false
	#endif

	// Airdrops doesn't use animations right now so no need to pass that info along
	return TryAirdropPoint( flightPath, baseOrigin, yaw )
}

void function ShowAllAirdropNodes( entity player = null )
{
	wait 0.5
	FlightPath flightPath = GetAnalysisForModel( DROPPOD_MODEL, AIRDROP_BASE_ANIM )

	int nodeCount = NavMeshNode_GetNodeCount()
	//vector offset = GetAnalysisOffset( flightPath )
	int iterator = flightPath.iterator
	int dataIndex = GetAnalysisDataIndex( flightPath )

	vector origin
	bool drawThrough = true
	float time = 5.0

	array<vector> yawVecs
	for ( int i = 0; i < ANALYSIS_STEPS; i++ )
	{
		float yaw = i * ANALYSIS_YAW_STEP
		vector forward = AnglesToForward( <0,yaw,0> )
		yawVecs.append( forward * 20.0 )
	}

	printt( "checking dataIndex " + dataIndex )

	int hits = 0
	for ( int i = 0; i < nodeCount; i += iterator )
	{
		origin = NavMeshNode_GetNodePos( i )
		if ( IsValid( player) && Distance( origin, player.GetOrigin() ) > 2500 )
			continue

		for ( int p = 0; p < ANALYSIS_STEPS; p++ )
		{
			DebugDrawText( origin + <0,0,16>, string( i ), !drawThrough, time )	// for some reason the bool is reversed for this debug draw function
			if ( NavMeshNode_GetBooleanData( i, p + dataIndex ) )
			{
				DebugDrawLine( origin, origin + yawVecs[p], 0, 255, 0, drawThrough, time )
				hits++
			}
			else
			{
				DebugDrawLine( origin, origin + yawVecs[p], 255, 0, 0, drawThrough, time )
			}
		}
	}

	printt( "Found " + hits + " uses of this sequence." )
}

bool function AnaylsisFuncLegalFlightPath( FlightPath flightPath, vector origin, float yaw )
{
	// find nodes that are legal for a simple flight path
	vector angles = <0,yaw,0>
	vector forward = AnglesToForward( angles )
	vector right = AnglesToRight( angles )
	bool legal = IsLegalFlightPath( flightPath, origin, forward, right, !shFile.activeNodeAnalysis && FLIGHT_PATH_DEBUG )

	return legal
}

void function AddFighterBounds( FlightPath flightPath )
{
	//AddBoundingMins( flightPath, <-378,-160,0> )
	//AddBoundingMaxs( flightPath, <256,160,208> )

	// tracehull requires square x/y for now..
	AddBoundingMins( flightPath, <-325,-325,0> )
	AddBoundingMaxs( flightPath, <325,325,208> )
}
#endif // SERVER

table<string,string> function DogFightAnimsFromIndex( int animIndex )
{
	string anim1
	string anim2

	switch ( animIndex )
	{
		case 0:
			anim1 = STRATON_DOGFIGHT_ANIM1
			anim2 = STRATON_DOGFIGHT_ANIM1_PERSUER
			break
		case 1:
			anim1 = STRATON_DOGFIGHT_ANIM2
			anim2 = STRATON_DOGFIGHT_ANIM2_PERSUER
			break
		case 2:
			anim1 = STRATON_DOGFIGHT_ANIM3
			anim2 = STRATON_DOGFIGHT_ANIM3_PERSUER
			break
	}

	return { anim1 = anim1, anim2 = anim2 }
}

bool function IsActiveNodeAnalysis()
{
	return shFile.activeNodeAnalysis
}

#if SERVER
void function StratonHornetDogfights()
{
	//PrintFunc()
	svGlobal.levelEnt.Signal( "StratonHornetDogfights" )
	svGlobal.levelEnt.EndSignal( "StratonHornetDogfights" )

	for ( ;; )
	{
		for ( int i = 0; i < 20; i++ )
		{
			float yaw = RandomFloat( 360.0 )
			//thread SpawnRandomDogFight( yaw )

			wait RandomFloatRange( 4, 6 )
		}

		wait 20

		for ( int i = 0; i < 20; i++ )
		{
			float yaw = RandomFloat( 360.0 )
			//thread SpawnRandomDogFight( yaw )

			wait RandomFloatRange( 8, 20 )
		}

		wait 40
	}
}

void function StratonHornetDogfightsIntense()
{
	if ( GetCurrentPlaylistVarInt( "skyshow_enabled", 0 ) == 0 )
		return

	//PrintFunc()
	svGlobal.levelEnt.Signal( "StratonHornetDogfights" )
	svGlobal.levelEnt.EndSignal( "StratonHornetDogfights" )

	for ( ;; )
	{
		float yaw = RandomFloat( 360.0 )
		//thread SpawnRandomDogFight( yaw )
		wait RandomFloatRange( 1, 3 )
	}
}

void function SkyboxCapitalShips( string name = "skybox_cam_level" )
{
	file.skyboxCamName = name
	AddCallback_OnClientConnected( OnClientConnected )
}

void function OnClientConnected( entity player )
{

}

//void function SpawnRandomDogFight( float yaw )
//{
//	//PrintFunc()
//	// int animIndex = RandomInt( 3 )
//	int animIndex = RandomInt( 2 ) //reduced to 2 since we ran out of indeces
//
//	table<string,string> anims = DogFightAnimsFromIndex( animIndex )
//	string anim1 = anims.anim1
//
//	asset model = GetFlightPathModel( "fp_straton_model" )
//	FlightPath flightPath = GetAnalysisForModel( model, anim1 )
//
//	CallinData drop
//	InitCallinData( drop )
//	SetCallinStyle( drop, eDropStyle.RANDOM_FROM_YAW )
//	SetCallinYaw( drop, yaw )
// 	SpawnPointFP spawnPoint = GetSpawnPointForStyle( flightPath, drop )
// 	if ( !spawnPoint.valid )
// 		return
//
//	int x = int( spawnPoint.origin.x )
//	int y = int( spawnPoint.origin.y )
//	int z = int( spawnPoint.origin.z )
//	yaw = spawnPoint.angles.y
//
//	array<entity> players = GetPlayerArray()
//	foreach ( player in players )
//	{
//		Remote_CallFunction_NonReplay( player, "ServerCallback_DogFight", x, y, z, yaw, animIndex )
//	}
//}

table function GetTitanfallNodesInRadius( vector titanfallOrigin, int radius )
{
	int nodeCount = NavMeshNode_GetNodeCount()
	int radiusSqr = (radius * radius)
	table nodeTable

	for ( int nodeIdx = 0; nodeIdx < nodeCount; nodeIdx++ )
	{
		if ( DistanceSqr( titanfallOrigin, NavMeshNode_GetNodePos( nodeIdx ) ) < radiusSqr )
			nodeTable[nodeIdx] <- []
	}

	return nodeTable
}

//void function DisableTitanfallForLifetimeOfEntityNearOrigin( entity ownerEntity, vector origin, int radius = TITANHOTDROP_DISABLE_ENEMY_TITANFALL_RADIUS )
//{
//	#if TITANS_CLASSIC_GAMEPLAY
//	Assert( Flag( "FlightPath_TitanDrop" ) )
//
//	table nodeTable = GetTitanfallNodesInRadius( origin, radius )
//	thread DisableTitanfallForNodes( nodeTable, ownerEntity, origin, radius )
//	#endif
//}

//void function TemporarilyDisableTitanfallAroundRadius( vector origin, int radius, float timeDelay = 5.0 ) //WARNNING: This doesn't actually work since it doesn't mark the nodes (e.g. NavMeshNode_SetBooleanData( node, dataIndex + p, false )). Also has problems similiar to SetInvulnerable() etc where you want to avoid having the last function called win, i.e. might need a counter or an enum
//{
//	#if TITANS_CLASSIC_GAMEPLAY
//	string titanfallID = UniqueString()
//	level.disallowedTitanfalls[ titanfallID ] <- { origin = origin, radius = radius }
//
//	wait timeDelay
//	delete level.disallowedTitanfalls[ titanfallID ]
//	#endif
//}

//void function DisableTitanfallForNodes( table nodeTable, entity ownerEntity, vector origin, int radius )
//{
//	#if TITANS_CLASSIC_GAMEPLAY
//	EndSignal( ownerEntity, "OnDestroy" )
//	EndSignal( ownerEntity, "ClearDisableTitanfall" )
//
//	FlightPath flightPath = GetAnalysisForModel( GetFlightPathModel( "fp_titan_model" ), HOTDROP_TURBO_ANIM )
//	int dataIndex = GetAnalysisDataIndex( flightPath )
//
//	string titanfallID = UniqueString()
//
//	level.disallowedTitanfalls[ titanfallID ] <- { origin = origin, radius = radius }
//
//	foreach ( node, nodeData in nodeTable )
//	{
//		Assert( nodeData.len() == 0 )
//		nodeData.resize( ANALYSIS_STEPS )
//		for ( int p = 0; p < ANALYSIS_STEPS; p++ )
//		{
//			nodeData[p] = NavMeshNode_GetBooleanData( node, dataIndex + p )
//			if ( nodeData[p] == true )
//				NavMeshNode_SetBooleanData( node, dataIndex + p, false )
//		}
//	}
//
//	OnThreadEnd(
//		function() : ( nodeTable, dataIndex, titanfallID )
//		{
//			delete level.disallowedTitanfalls[ titanfallID ]
//
//			foreach ( node, nodeData in nodeTable )
//			{
//				Assert( nodeData.len() == ANALYSIS_STEPS )
//				nodeData.resize( ANALYSIS_STEPS )
//				for ( int p = 0; p < ANALYSIS_STEPS; p++ )
//				{
//					if ( nodeData[p] == true )
//						NavMeshNode_SetBooleanData( node, dataIndex + p, nodeData[p] )
//				}
//			}
//		}
//	)
//
//	WaitSignal( ownerEntity, "OnDeath" )
//	#endif
//}

void function AddTitanfallBlocker( vector origin, int radius, int height )
{
	float maxHeight = origin.z + height

	table Table = { origin = origin, radius = radius, maxHeight = maxHeight }
	level.titanfallBlockers.append( Table )
}

void function TryAnalysisAtOrigin( FlightPath flightPath, array<bool> Array, vector origin )
{
	bool prep = flightPath in file.analysisPrepSpawnpointFunc
	for ( int i = 0; i < Array.len(); i++ )
	{
		float yaw = i * ANALYSIS_YAW_STEP
		vector org = origin
		if ( prep )
		{
			var newOrg = file.analysisPrepSpawnpointFunc[ flightPath]( flightPath, origin, yaw )
			if ( newOrg != null )
			{
				org = expect vector( newOrg )
			}
		}

		if ( !PassedAnalysisFunc( flightPath, org, yaw ) )
			continue

		Array[ i ] = true
	}
}

void function AddDropshipDropTable( entity dropship, DropTable dropTable )
{
	file.dropshipDropOffDropTable[ dropship ] <- dropTable
}

DropTable function GetDropshipDropTable( entity dropship )
{
	Assert( dropship in file.dropshipDropOffDropTable )
	return file.dropshipDropOffDropTable[ dropship ]
}

bool function HasDropshipDropTable( entity dropship )
{
	if ( !( dropship in file.dropshipDropOffDropTable ) )
		return false

	return file.dropshipDropOffDropTable[ dropship ].valid
}
#endif // SERVER

void function AddDropshipFlightAnalysis( int index, asset model, string anim, bool functionref( FlightPath, vector, float ) analysisFunc, string event = "" )
{
	shFile.dropshipDropoffAnims.append( anim )

	//if ( !( model in level.superCallinOffset ) )
	//	level.superCallinOffset[ model ] <- offset

	#if SERVER
	AddAinAnalysisIndex( model, anim )

	FlightPath flightPath = CreateFlightAnalysis( model, anim, {}, event )
	AddBoundingMins( flightPath, <-325, -325, -96> )
	AddBoundingMaxs( flightPath, <325, 325, 185> )
	AddAnalysisFunc( flightPath, analysisFunc, HULL_HUMAN )
	AddAnalysisIterator( flightPath, 2 ) // iterate every other node
	#endif
}

