/// =================== ///
///		Onboarding		///
/// =================== ///

/*
	Onboarding handles user interaction from joining until the enabled character selection outros have been completed.

	Everything after that is gamemode-specific.
	To handle onboarding completion in your gamemode code, use AddCallback_GameStateEnter for eGameState.Playing.

	Onboarding is controlled by playlist vars, define them in the gamemode spec to control.
	Available playlist vars:
		General:
			custom_onboarding							- Completely disable default onboarding sequences, leveraging onboarding on the gamemode.
		Waiting for players:
			waiting_for_players_min_wait 				- Minimal time to wait before checking for players.
			waiting_for_players_timeout_seconds 		- Maximum time to wait for connecting players.
			waiting_for_players_has_black_screen 		- Select whether the player should have a black background instead of a view of their current origin.
			waiting_for_players_spawning_enabled		- Select whether the player should be spawned (partial spawn since at this stage no settings have been assigned).
			waiting_for_players_countdown_seconds		- The countdown before the next onboarding stage.
			charselect_intro_music_start_time			- The offset from character selection unlock when the character selection music should be started.
		Character selection:
			charselect_enabled							- Select whether the default character selection logic should be used. If false, random legends will be assigned.
			charselect_intro_transition_duration		- The duration of transition from waiting for players to character selection.
			charselect_intro_countdown_duration			- The duration of the pre legend selection countdown (You choose N'nd).
			charselect_picking_delay_before_all 		- The duration of delay before the legend pick logic starts.
			charselect_picking_delay_on_first			- The duration of delay after the first player has picked their legend.
			character_select_time_min					- Minimal time for player to select their legend.
			character_select_time_max					- Maximum time for player to select their legend.
			charselect_picking_delay_after_each_lock	- The duration of delay after any player has picked their legend.
			charselect_picking_delay_after_all			- The duration of delay after all players have picked their legend.
			charselect_outro_scene_change_duration		- The duration of delay to switch the scene to next steps.
		Player squad overview:
			survival_enable_squad_intro					- Show player squad. If disabled, the player squad duration is skipped.
			charselect_outro_squad_present_duration		- The duration of player squad data being present on screen.
		Champion squad overview:
			survival_enable_gladiator_intros			- Show champion squad. If disabled, the champion squad duration is skipped.
			charselect_outro_champion_present_duration	- The duration of champion squad data being present on screen.
		End:
			charselect_outro_transition_duration		- The duration of transition from past steps to playing state.
*/
global function SV_CL_Onboarding_Init

#if SERVER
	global function TakeLoadoutRelatedWeapons
	global function GiveLoadoutRelatedWeapons
	global function DecideRespawnPlayer
	global function DecideRespawnPlayer_Retail

	global function PlayerStartSpectating
	global function PlayerStopSpectating

	global function UpdatePlayerCounts
	global function Flowstate_AssignUniqueCharacterForPlayer
	global function Flowstate_SetAssignedCustomModelToPlayer

	global function SetCallback_ObserverThreadOverride

	global function SetPlayerSettings
	global function Flowstate_ApplyModifiedMovementToPlayer
#endif

global function ModifiedMovement_RegisterNetworking

global function PreGame_GetWaitingForPlayersHasBlackScreen
global function PreGame_GetWaitingForPlayersSpawningEnabled
global function PreGame_GetWaitingForPlayersDelayMin
global function PreGame_GetWaitingForPlayersDelayMax
global function PreGame_GetWaitingForPlayersCountdown

global function CharSelect_GetIntroMusicStartTime
global function CharSelect_GetIntroTransitionDuration
global function CharSelect_GetIntroCountdownDuration

global function CharSelect_GetPickingDelayBeforeAll
global function CharSelect_GetPickingDelayOnFirst
global function CharSelect_GetPickingSingleDurationMax
global function CharSelect_GetPickingSingleDurationMin
global function CharSelect_GetPickingDelayAfterEachLock
global function CharSelect_GetPickingDelayAfterAll

global function CharSelect_GetOutroSceneChangeDuration
global function CharSelect_GetOutroSquadPresentDuration
global function CharSelect_GetOutroChampionPresentDuration
global function CharSelect_GetOutroTransitionDuration

global function Survival_GetCharacterSelectDuration
global function Survival_CharacterSelectEnabled

struct
{
	void functionref(entity player ) ObserverThreadOverrideCallback = null
	int flowstate_modified_movement
	
	#if SERVER
		bool use_r2_deathcam
	#endif
} file


void function SV_CL_Onboarding_Init()
{
	OnboardingPlaylistSettings_Init()
	
	#if SERVER
		SetAutoReloadState( false ) //let native know ~mkos
		RegisterSignal( "Flowstate_RestartLv4MagazinesThread" )
		FlagInit( "MinPlayersReached", false )
		
		RespawnBehavior_Init()
		AddCallback_OnPlayerKilled( OnPlayerKilled )
		AddCallback_OnClientConnected( OnClientConnected )
		
		#if TRACKER
			AddCallback_OnBatchStatsLoaded( Tracker_SetChampionOnPersistenceLoad )
		#endif

		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterClass(), OnCharacterClassChanged )
		foreach ( character in GetAllCharacters() )
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterSkin( character ), OnCharacterSkinChanged )

		SetGameState( eGameState.WaitingForPlayers )

		if ( OnboardingEnabled() )
			thread Sequence_WaitingForPlayers()
		
		if( Gamemode() == eGamemodes.SURVIVAL )
			AddCallback_GameStateEnter( eGameState.Postmatch, void function() : (){ SetAutoReloadState( true ) } ) //check for native reload ~mkos
	#endif
}

#if SERVER
/*
	███████╗███████╗ ██████╗ ██╗   ██╗███████╗███╗   ██╗ ██████╗███████╗███████╗
	██╔════╝██╔════╝██╔═══██╗██║   ██║██╔════╝████╗  ██║██╔════╝██╔════╝██╔════╝
	███████╗█████╗  ██║   ██║██║   ██║█████╗  ██╔██╗ ██║██║     █████╗  ███████╗
	╚════██║██╔══╝  ██║▄▄ ██║██║   ██║██╔══╝  ██║╚██╗██║██║     ██╔══╝  ╚════██║
	███████║███████╗╚██████╔╝╚██████╔╝███████╗██║ ╚████║╚██████╗███████╗███████║
	╚══════╝╚══════╝ ╚══▀▀═╝  ╚═════╝ ╚══════╝╚═╝  ╚═══╝ ╚═════╝╚══════╝╚══════╝
	
	This part describes the onboarding sequences: threaded functions which control the onboarding.
*/

void function Sequence_WaitingForPlayers()
{
	// Wait the absolute minimum delay, if required (0 by default)
	wait PreGame_GetWaitingForPlayersDelayMin()

	// Start to wait for players.
	// Countdown will be reached when the minimum amount of players join, or when the maximum delay is reached (if enabled).
	float timeSpentWaitingForPlayers = 0.0
	float maximumTimeToSpendToWaitForPlayers = PreGame_GetWaitingForPlayersDelayMax() - PreGame_GetWaitingForPlayersDelayMin()

	// bool shouldNotWaitForever = maximumTimeToSpendToWaitForPlayers > 0.0 && !PreGame_GetWaitingForPlayersWaitForeverEnabled()

	while ( !Flag( "MinPlayersReached" ) )
	{
		const float LOOP_INTERVAL = 0.1

		timeSpentWaitingForPlayers += LOOP_INTERVAL
		wait LOOP_INTERVAL

		int connectedPlayerCount = GetPlayerArray().len()

		// if ( shouldNotWaitForever 
			// && timeSpentWaitingForPlayers >= maximumTimeToSpendToWaitForPlayers
			// && connectedPlayerCount > 0
			// )
			// break
	}

	// Update to make client aware of the countdown
	UpdateSequencedTimePoints( Time() )

	bool introCountdownEnabled = CharSelect_GetIntroCountdownDuration() > 0.0
	
	if( Gamemode() != eGamemodes.SURVIVAL)
		wait PreGame_GetWaitingForPlayersCountdown() + (introCountdownEnabled ? 0.0 : CharSelect_GetIntroMusicStartTime()) - 1
	else
		wait PreGame_GetWaitingForPlayersCountdown() + (introCountdownEnabled ? 0.0 : CharSelect_GetIntroMusicStartTime())
	
	if( Gamemode() == eGamemodes.fs_aimtrainer )
		return

	if( Gamemode() != eGamemodes.SURVIVAL && Gamemode() != eGamemodes.WINTEREXPRESS )
	{
		foreach( player in GetPlayerArray() )
		{
			if( !IsValid( player ) )
				continue
			
			if( Gamemode() != eGamemodes.CUSTOM_CTF )
			{
				ScreenCoverTransition_Player(player, Time() + 2)
			} 
			else
			{
				ScreenFade( player, 0, 0, 0, 255, 1, 0, FFADE_OUT | FFADE_STAYOUT )
			}
		}
	}
	
	#if TRACKER
		if( bLog() && !Tracker_IsBatchStatsLoaded() && Flowstate_IsTrackerSupportedMode() )
			waitthread WaitSignalOrTimeout( svGlobal.levelEnt, Tracker_GetMaxWaitForBatchLoad(), "BatchFetchComplete" )
	
		WaitFrame()
	#endif

	if ( GetCurrentPlaylistVarBool( "survival_commentary_champion_enabled", true ) && GetPlayerArray().len() > 0 )
	{
		#if !TRACKER 
			entity champion = GetPlayerArray().getrandom()
			SetChampion( champion )
		#endif
	}

	if ( !introCountdownEnabled )
		PlayPickLoadoutMusic( false )
	
	thread Sequence_PickLoadout()
}

void function Sequence_PickLoadout()
{
	if ( Playlist() == ePlaylists.fs_scenarios || !Survival_CharacterSelectEnabled() || Gamemode() != eGamemodes.SURVIVAL ) 
	{
		foreach ( player in GetPlayerArray() )
		{
			ItemFlavor musicPack = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_MusicPack() )
			string skydiveMusicID = MusicPack_GetSkydiveMusic( musicPack )
			StopMusicOnPlayer( player, skydiveMusicID )
		}

		thread Sequence_Prematch() 
		return
	}

	// Assign character selection order to teams
	AssignLockStepOrder()

	ScreenCoverTransition_AllPlayers( Time() + CharSelect_GetIntroTransitionDuration() )
	wait CharSelect_GetIntroTransitionDuration()

	SetGameState( eGameState.PickLoadout )

	// Update future time points now that the delays should be predictable
	UpdateSequencedTimePoints( Time() )

	bool introCountdownEnabled = CharSelect_GetIntroCountdownDuration() > 0.0

	// Signalize that character selection sequence should be started clientside
	SetGlobalNetBool( "characterSelectionReady", true )

	if ( introCountdownEnabled )
	{
		wait CharSelect_GetIntroCountdownDuration() + (CharSelect_GetIntroMusicStartTime() - CharSelect_GetIntroTransitionDuration())
		PlayPickLoadoutMusic( true )
	}

	wait CharSelect_GetPickingDelayBeforeAll()

	for ( int pickIndex = 0; pickIndex < MAX_TEAM_PLAYERS; pickIndex++ )
	{
		float startTime = Time()

		float timeSpentOnSelection = Survival_GetCharacterSelectDuration( pickIndex ) + CharSelect_GetPickingDelayAfterEachLock()
		if ( pickIndex == 0 )
			timeSpentOnSelection += CharSelect_GetPickingDelayOnFirst()

		float endTime = startTime + timeSpentOnSelection

		SetGlobalNetInt( "characterSelectLockstepIndex", pickIndex )
		SetGlobalNetTime( "characterSelectLockstepStartTime", startTime )
		SetGlobalNetTime( "characterSelectLockstepEndTime", endTime )
		
		//compare player pick with GetLoadoutSlotContentsIndexInternal( playerEHI, entry ) before setting a forced pick
		// if( pickIndex == 0 ) 
		// {
			foreach ( player in GetAllPlayersOfLockstepIndex( pickIndex ) )
			{
				Flowstate_AssignUniqueCharacterForPlayer(player, false)
			}
		// }
		
		wait timeSpentOnSelection

		foreach ( player in GetAllPlayersOfLockstepIndex( pickIndex ) )
		{
			ItemFlavor selectedCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
			CharacterSelect_AssignCharacter( player, selectedCharacter )
		}

		wait CharSelect_GetPickingDelayAfterEachLock()
	}

	// Reset selection step to lock all character selection loadout slots
	SetGlobalNetInt( "characterSelectLockstepIndex", MAX_TEAM_PLAYERS )

	foreach ( player in GetPlayerArray() )
		if ( !player.GetPlayerNetBool( "hasLockedInCharacter" ) )
			Flowstate_AssignUniqueCharacterForPlayer(player, true) // Joined too late, assign a random legend so everything runs fine

	wait CharSelect_GetPickingDelayAfterAll()

	wait CharSelect_GetOutroTransitionDuration() + CharSelect_GetOutroSceneChangeDuration() / 3.5 - CharSelect_GetPickingDelayAfterEachLock() * MAX_TEAM_PLAYERS

	if ( CharSelect_PlayerSquadIntroEnabled() ) {
		if ( CharSelect_PostSelectionMusicEnabled() )
			foreach ( player in GetPlayerArray() )
			{
				string skydiveMusicID = MusicPack_GetSkydiveMusic( LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_MusicPack() ) )
				EmitSoundOnEntityOnlyToPlayer( player, player, skydiveMusicID )
			}

		wait CharSelect_GetOutroSquadPresentDuration() - CharSelect_GetOutroSceneChangeDuration() / 3.5
	}

	thread Sequence_Prematch()
}

void function Flowstate_AssignUniqueCharacterForPlayer(entity player, bool lock)
{
	array< ItemFlavor > characters = clone GetAllCharacters()

	for ( int i = characters.len() - 1; i >= 0; i-- )
	{
		int playlistOpinion = GetItemFlavorPlaylistOpinion( ItemFlavor_GetHumanReadableRef( characters[ i ] ) )

		if( playlistOpinion == eItemFlavorPlaylistOpinion.LOCKED )
			characters.remove( i )
	}
	
	bool quit
	for ( int i = characters.len() - 1; i >= 0; i-- )
	{
		quit = false
		foreach ( squadMate in GetPlayerArrayOfTeam( player.GetTeam() ) )
		{
			if( quit )
				continue

			if( squadMate == player )
				continue
			
			ItemFlavor mateCharacter = LoadoutSlot_GetItemFlavor( ToEHI( squadMate ), Loadout_CharacterClass() )
			if( mateCharacter == characters[ i ] )
			{
				characters.remove( i )
				quit = true
			}
		}
	}

	ItemFlavor initialCharacter
	
	if( characters.len() == 0) //Shouldn't happen, but just in case. (Teams of more than 10 players probably)
		initialCharacter = GetAllCharacters().getrandom()
	else
		initialCharacter = characters.getrandom()
	
	player.SetPlayerNetInt( "characterSelectFocusIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( Loadout_CharacterClass(), initialCharacter ) )
	
	CharacterSelect_AssignCharacter( player, initialCharacter )
	
	if( !lock || IsDevGamemode() )
		player.SetPlayerNetBool( "hasLockedInCharacter", false )
}

void function Sequence_Prematch()
{
	SetGameState( eGameState.Prematch )

	// Update future time points now that the delays should be predictable
	UpdateSequencedTimePoints( Time() )

	if ( CharSelect_ChampionSquadIntroEnabled() )
		wait CharSelect_GetOutroChampionPresentDuration()

	// The gamemode handles everything past this point
	SetGameState( eGameState.Playing )
}

// Custom logic for sequence orchestration
void function UpdateSequencedTimePoints( float referenceTime, int gameStateOverride = -1 )
{
	SetGlobalNetInt( "gameState", GetGameState() )

	if( Playlist() == ePlaylists.fs_scenarios )
		return

	switch ( gameStateOverride != -1 ? gameStateOverride : GetGameState() )
	{
		case eGameState.WaitingForPlayers:
			SetGlobalNetTime( "PreGameStartTime", referenceTime + PreGame_GetWaitingForPlayersCountdown() )
			SetGlobalNetTime( "pickLoadoutGamestateStartTime", referenceTime + PreGame_GetWaitingForPlayersCountdown() + CharSelect_GetIntroTransitionDuration() + CharSelect_GetIntroCountdownDuration() )
			break
		case eGameState.PickLoadout:
			float timeBeforeCharacterSelection = CharSelect_GetIntroCountdownDuration() + CharSelect_GetPickingDelayBeforeAll()
		
			float timeToSelectAllCharacters = CharSelect_GetPickingDelayOnFirst()
			for ( int pickIndex = 0; pickIndex < MAX_TEAM_PLAYERS; pickIndex++ )
				timeToSelectAllCharacters += Survival_GetCharacterSelectDuration( pickIndex ) + CharSelect_GetPickingDelayAfterEachLock()
		
			float timeAfterCharacterSelection = CharSelect_GetPickingDelayAfterAll() + CharSelect_GetOutroTransitionDuration()

			float timeBeforeChampionPresentation = CharSelect_PlayerSquadIntroEnabled() ? CharSelect_GetOutroSquadPresentDuration() : 0.0
			float timeAfterChampionPresentation = CharSelect_ChampionSquadIntroEnabled() ? CharSelect_GetOutroChampionPresentDuration() : 0.0
				
			SetGlobalNetTime( "squadPresentationStartTime", referenceTime + timeBeforeCharacterSelection + timeToSelectAllCharacters + timeAfterCharacterSelection )
			SetGlobalNetTime( "championSquadPresentationStartTime", referenceTime + timeBeforeCharacterSelection + timeToSelectAllCharacters + timeAfterCharacterSelection + timeBeforeChampionPresentation )
			SetGlobalNetTime( "pickLoadoutGamestateEndTime", referenceTime + timeBeforeCharacterSelection + timeToSelectAllCharacters + timeAfterCharacterSelection + timeBeforeChampionPresentation + timeAfterChampionPresentation )
			break
	}
}

void function PlayPickLoadoutMusic( bool introCountdownEnabled )
{
	if ( !Survival_CharacterSelectEnabled() )
		return

	foreach ( player in GetPlayerArray() )
	{
		string pickLoadoutMusicID = MusicPack_GetCharacterSelectMusic( LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_MusicPack() ) )
		EmitSoundOnEntityOnlyToPlayer( player, player, pickLoadoutMusicID )
	}

	wait fabs( CharSelect_GetIntroMusicStartTime() )

	if ( introCountdownEnabled )
		wait CharSelect_GetIntroTransitionDuration()
}

#endif

#if SERVER
/*
	██████╗  █████╗ ███████╗███████╗    ██████╗ ███████╗███████╗██████╗  █████╗ ██╗    ██╗███╗   ██╗
	██╔══██╗██╔══██╗██╔════╝██╔════╝    ██╔══██╗██╔════╝██╔════╝██╔══██╗██╔══██╗██║    ██║████╗  ██║
	██████╔╝███████║███████╗█████╗      ██████╔╝█████╗  ███████╗██████╔╝███████║██║ █╗ ██║██╔██╗ ██║
	██╔══██╗██╔══██║╚════██║██╔══╝      ██╔══██╗██╔══╝  ╚════██║██╔═══╝ ██╔══██║██║███╗██║██║╚██╗██║
	██████╔╝██║  ██║███████║███████╗    ██║  ██║███████╗███████║██║     ██║  ██║╚███╔███╔╝██║ ╚████║
	╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝    ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝     ╚═╝  ╚═╝ ╚══╝╚══╝ ╚═╝  ╚═══╝

	This part describes the base respawn (the bare minimum for a proper respawn) functions.
*/

void function TakeLoadoutRelatedWeapons( entity player )
{
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )

	// Shared
	if(IsValid(player.GetOffhandWeapon( OFFHAND_SLOT_FOR_CONSUMABLES )))
		player.TakeOffhandWeapon( OFFHAND_SLOT_FOR_CONSUMABLES )

	// Loadout meleeskin
	if(IsValid(player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_2 )))
		player.TakeNormalWeaponByIndexNow( WEAPON_INVENTORY_SLOT_PRIMARY_2 )
	
	if(IsValid(player.GetOffhandWeapon( OFFHAND_MELEE )))
		player.TakeOffhandWeapon( OFFHAND_MELEE )

	// Character related
	if(IsValid(player.GetOffhandWeapon( OFFHAND_TACTICAL )))
		player.TakeOffhandWeapon( OFFHAND_TACTICAL )
	if(IsValid(player.GetOffhandWeapon( OFFHAND_ULTIMATE )))
		player.TakeOffhandWeapon( OFFHAND_ULTIMATE )

	// if( GameRules_GetGameMode() == SURVIVAL )
	TakeAllPassives( player )
}

void function GiveLoadoutRelatedWeapons( entity player )
{
	TakeLoadoutRelatedWeapons(player)
	
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	ItemFlavor tactical = CharacterClass_GetTacticalAbility( character )
	ItemFlavor ultimate = CharacterClass_GetUltimateAbility( character )
	ItemFlavor passive = CharacterClass_GetPassiveAbility( character )
	
	player.GiveOffhandWeapon( CONSUMABLE_WEAPON_NAME, OFFHAND_SLOT_FOR_CONSUMABLES, [] )
	player.GiveOffhandWeapon( CharacterAbility_GetWeaponClassname( tactical ), OFFHAND_TACTICAL, [] )
	player.GiveOffhandWeapon( CharacterAbility_GetWeaponClassname( ultimate ), OFFHAND_ULTIMATE, [] )

	if( !is1v1EnabledAndAllowed() || is3v3Mode() ) // Todo: unweave gamemode logic ()
	{
		player.GiveWeapon( "mp_weapon_melee_survival", WEAPON_INVENTORY_SLOT_PRIMARY_2, [] )
		player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, [] )
	}

	if( !Flowstate_GivePassive() || !Flowstate_PassivesAllowedForMode() )
		return

	GivePassive( player, CharacterAbility_GetPassiveIndex( passive ) )

	if( ItemFlavor_GetHumanReadableRef( character ) == "character_caustic" || ItemFlavor_GetHumanReadableRef( character ) == "character_gibraltar" )
	{
		if( !PlayerHasPassive( player, ePassives.PAS_FORTIFIED) )
			GivePassive( player, ePassives.PAS_FORTIFIED )
	} 
	else if( ItemFlavor_GetHumanReadableRef( character ) == "character_crypto" )
	{
		if( !PlayerHasPassive( player, ePassives.PAS_CRYPTO ) )
			GivePassive( player, ePassives.PAS_CRYPTO )
	}
}


array<string> enabledMods = []
bool script_bHighlight = true
bool script_bGiveskins = false
bool script_bRespawnInitComplete = false

void function RespawnBehavior_Init()
{
	script_bHighlight = ( Gamemode() == eGamemodes.SURVIVAL || Gamemode() == eGamemodes.fs_snd || Playlist() == ePlaylists.fs_scenarios )
	script_bGiveskins = GetCurrentPlaylistVarBool( "flowstate_giveskins_characters", false )
	
	table<string, string> possibleMods = {
		survival_jumpkit_enabled = "enable_doublejump",
		survival_wallrun_enabled = "enable_wallrun"
	}

	foreach ( playlistVar, modName in possibleMods )
		if ( GetCurrentPlaylistVarBool( playlistVar, false ) || GetCurrentPlaylistVarInt( "flowstate_modified_movement", 0 ) == 1 )
			enabledMods.append( modName )
		
	script_bRespawnInitComplete = true
}

void function DecideRespawnPlayer( entity player, bool giveLoadoutWeapons = true )
{
	#if DEVELOPER
		//Warning("DecideRespawnPlayer: " + string( player ) )
		DumpStack()
		mAssert( script_bRespawnInitComplete, "RespawnBehavior_Init() --- wasn't ready in DecideRespawnPlayer()" )
	#endif
	
	if ( !IsValid( player ) ) 
		return
	
	if ( IsAlive( player ) )
	 	TakeLoadoutRelatedWeapons( player )
		
	//This calls the definitive native code to respawn player, which will first fire "OnRespawnPlayer", and then fire signal "OnSpawned" in CodeCallback_OnPlayerRespawned ~mkos
	DoRespawnPlayer( player, null )

	player.p.lastRespawnTime = Time()
	
	ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	asset characterSetFile = CharacterClass_GetSetFile( playerCharacter )
	player.SetPlayerSettingsWithMods( characterSetFile, enabledMods )

	Remote_CallFunction_NonReplay( player, "ServerCallback_YouRespawned" )

	PlayerStopSpectating( player )

	// ItemFlavor playerCharacterSkin = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterSkin( playerCharacter ) )
	// CharacterSkin_Apply( player, playerCharacterSkin )
	player.AmmoPool_SetCapacity( 65535 )

	if ( giveLoadoutWeapons || Gamemode() == eGamemodes.map_editor_deprecated )
		GiveLoadoutRelatedWeapons( player )

	Survival_SetInventoryEnabled( player, giveLoadoutWeapons )

	player.SetPlayerNetInt( "respawnStatus", eRespawnStatus.NONE )

	player.SetPlayerNetBool( "pingEnabled", true )
	player.SetHealth( player.GetMaxHealth() )

	UpdatePlayerCounts()
	
	if( Gamemode() == eGamemodes.map_editor_deprecated ) //todo move to mode specific callback
		thread (void function() : ( player )
		{
			if(IsValid(player.GetOffhandWeapon( OFFHAND_TACTICAL )))
			{
				player.TakeOffhandWeapon( OFFHAND_TACTICAL )
				player.GiveOffhandWeapon( "mp_weapon_editor", OFFHAND_TACTICAL, [] )
				player.SetActiveWeaponByName( eActiveInventorySlot.mainHand, "mp_weapon_editor" )
			}
			if(IsValid(player.GetOffhandWeapon( OFFHAND_ULTIMATE )))
				player.TakeOffhandWeapon( OFFHAND_ULTIMATE )
			
			wait 1
			Message(player, "PROP DYNAMIC MAP EDITOR", "Made by Sal, Fireproof, Pebbers & JustANormalUser. Misc fixes by CaféFPS.", 8)
		})()
		
	if( player.IsThirdPersonShoulderModeOn() )
		player.SetThirdPersonShoulderModeOn() // If you respawn in third person, it will automatically revert to first person, so turn it on again

	#if DEVELOPER
	SetSkydiveEmotesForAllCharacters( player )
	#endif

	//Set highlight to mantain retail behavior
	if( script_bHighlight )
	{
		Highlight_SetFriendlyHighlight( player, "sp_friendly_hero" )
	}
	
	Flowstate_ApplyModifiedMovementToPlayer( player )

	if( Playlist() == ePlaylists.fs_scenarios )
		return

	if( player.p.assignedCustomModel != -1 )
	{
		Flowstate_SetAssignedCustomModelToPlayer( player, player.p.assignedCustomModel )
	}
	if( script_bGiveskins )
	{
		array<ItemFlavor> characterSkinsA = GetValidItemFlavorsForLoadoutSlot( ToEHI( player ), Loadout_CharacterSkin( LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() ) ) )
		CharacterSkin_Apply( player, characterSkinsA[characterSkinsA.len()-RandomIntRangeInclusive(1,4)])
	}
	
	//commented, already signaled in code callback after DoRespawnPlayer fires ~mkos
	
	// if( Gamemode() != eGamemodes.SURVIVAL && Gamemode() != eGamemodes.WINTEREXPRESS )
		// player.Signal("OnRespawned")		
}

// clean up and move to main when completely debugged. Cafe
bool function DecideRespawnPlayer_Retail( entity player, bool allowSpawnAsObserver = false )
{
	#if DEVELOPER
	DumpStack()
	#endif

	Assert( IsValid( player ), player + " is invalid!!" )
	Assert( !IsAlive( player ), player + " is already alive" )

	if ( !player.hasConnected || player.GetTeam() == TEAM_SPECTATOR )
	{
		printf( "%s() - player.hasConnected was false: %s", FUNC_NAME(), string( player ) )
		return false
	}

	if ( IsPVEMode() && (player.p.respawnCount == 0) )
		return false

	if ( (GetGameState() <= eGameState.WaitingForPlayers) && !PreGame_GetWaitingForPlayersSpawningEnabled() )
	{
		printf( "%s() - No spawning when waiting for players: %s", FUNC_NAME(), string( player ) )
		return false
	}

	if ( PlayerShouldObserve( player ) )
	{
		printf( "%s() - PlayerShouldObserve() was true: %s", FUNC_NAME(), string( player ) )
		if ( true ) //GamemodeUtility_IsSpectatorEnabled() ) review. Cafe
		{
			if ( IsPlayerEliminated( player ) && (GetGameState() == eGameState.Playing) && IsRoundBased() )
				SendHudMessage( player, "#GAMEMODE_RESPAWN_NEXT_ROUND", -1, 0.4, 255, 255, 255, 255, 1.0, 6.0, 1.0 )

			#if SERVER
				if ( file.ObserverThreadOverrideCallback != null )
					file.ObserverThreadOverrideCallback(player)
				else
					thread ObserverThread( player )
			#endif
		}

		return false
	}

	// if ( allowSpawnAsObserver )
		// player.AllowSpawnAsObserverOnce()

	printf( "%s() - Attempting to spawn: %s", FUNC_NAME(), string( player ) )
	bool didSpawn = RespawnTitanPilot( player )
	printf( "%s() - Spawn %s: %s", FUNC_NAME(), (didSpawn ? "success" : "failed"), string( player ) )

	return didSpawn
}


bool function RespawnTitanPilot( entity player )
{
	Assert( PlayerCanSpawn( player ), player + " cant spawn now" )

	if ( IsLobby() )
		return false

	DoRespawnPlayer( player, null )
	
	if( script_bHighlight )
	{
		Highlight_SetFriendlyHighlight( player, "sp_friendly_hero" )
	}
	
	Flowstate_ApplyModifiedMovementToPlayer( player )

	if( player.p.assignedCustomModel != -1 )
	{
		Flowstate_SetAssignedCustomModelToPlayer( player, player.p.assignedCustomModel )
	}

	return true
}

void function SetCallback_ObserverThreadOverride( void functionref( entity player ) func  )
{
	file.ObserverThreadOverrideCallback = func
}


bool function PlayerShouldObserve( entity player )
{
	if ( player.GetTeam() == TEAM_SPECTATOR )
		return true
	if ( IsPrivateMatchSpectator( player ) )
		return true
	// if ( !InitialPlayerSpawnOccurred() )
		// return true
	if ( IsPlayerEliminated( player ) )
		return true

	return false
}

void function Flowstate_SetAssignedCustomModelToPlayer( entity player, int index )
{
	switch( index )
	{
		case 1:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/w_blisk.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_blisk.rmdl" )
		break
		
		case 2:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/w_phantom.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_phantom.rmdl" )
		break
		
		case 3:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/w_amogino.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_amogino.rmdl" )
		break

		case 4:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/w_rhapsody.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_rhapsody.rmdl" )
		break
		
		case 5:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/w_ash_legacy.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_ash_legacy.rmdl" )
		break

		case 6:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/w_jackcooper.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_jackcooper.rmdl" )
		break

		case 7:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/pilot_medium_loba.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_pilot_medium_loba.rmdl" )
		break
		
		case 8:
		player.SetBodyModelOverride( $"mdl/Humans/pilots/pilot_heavy_revenant.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_pilot_heavy_revenant.rmdl" )
		break

		case 9: // ballistic
		player.SetBodyModelOverride( $"mdl/Humans/pilots/ballistic_base_w.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/ballistic_base_v.rmdl" )
		break
		
		case 10: // mrvn
		player.SetBodyModelOverride( $"mdl/flowstate_custom/w_marvin.rmdl" )
		player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_amogino.rmdl" )
		break

		case 11: // pete
		player.SetBodyModelOverride( $"mdl/flowstate_custom/w_pete_mri.rmdl" )
		player.SetArmsModelOverride( $"mdl/flowstate_custom/ptpov_pete_mri.rmdl" )
		break
	}	
}

void function SetSkydiveEmotesForAllCharacters( entity player ) // You need to unlock the loadout for this to work
{
	// array< array< string > > emoteArrays = [ [ "skydive_emote_bangalore_backflip" ], [ "skydive_emote_bloodhound_backflip" ], [ "skydive_emote_caustic_backflip" ], [ "skydive_emote_gibraltar_backflip" , 
								// "skydive_emote_gibraltar_surf" ], [ "skydive_emote_lifeline_backflip", "skydive_emote_lifeline_windmill" ], [ "skydive_emote_mirage_backflip", 
								// "skydive_emote_mirage_rodeo" ], [ "skydive_emote_octane_backflip" ], [ "skydive_emote_pathfinder_backflip", "skydive_emote_pathfinder_birdattack" ], 
								// [ "skydive_emote_wattson_backflip", "skydive_emote_wattson_explorer" ], [ "skydive_emote_wraith_backflip" ] ]

	// foreach( emoteArray in emoteArrays )
	// {
		// for( int i = 0; i < emoteArray.len(); i++ )
			// ClientCommand( player, "loadouts_devset skydive_emote_" + i + " " + emoteArray[ i ] )
	// }
}
#endif

#if SERVER
/*
	███████╗██████╗ ███████╗ ██████╗████████╗ █████╗ ████████╗██╗███╗   ██╗ ██████╗ 
	██╔════╝██╔══██╗██╔════╝██╔════╝╚══██╔══╝██╔══██╗╚══██╔══╝██║████╗  ██║██╔════╝ 
	███████╗██████╔╝█████╗  ██║        ██║   ███████║   ██║   ██║██╔██╗ ██║██║  ███╗
	╚════██║██╔═══╝ ██╔══╝  ██║        ██║   ██╔══██║   ██║   ██║██║╚██╗██║██║   ██║
	███████║██║     ███████╗╚██████╗   ██║   ██║  ██║   ██║   ██║██║ ╚████║╚██████╔╝
	╚══════╝╚═╝     ╚══════╝ ╚═════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝ 

	This part describes the spectator functions.
*/

void function PlayerStartSpectating( entity player, entity attacker, bool squadCheck = false, int team = 0, bool FromConnectingPlayerEliminated = false, int attackerEHandle = -1)
{	
	array<entity> clientTeam = GetPlayerArrayOfTeam_Alive( player.GetTeam() )
	clientTeam.fastremovebyvalue( player )

	bool isSolos = IsSoloMode()
	bool isAloneOrSquadEliminated = clientTeam.len() == 0
	
	entity specTarget = null

	if ( Spectator_GetReplayIsEnabled() || isSolos )
	{
		if ( attacker == player ) return;
		if ( attacker == null ) return;
		if ( !IsValid( attacker ) || !IsAlive( attacker ) ) return;
		
		specTarget = attacker;
	}
	else if ( isAloneOrSquadEliminated )
	{
		array<entity> alivePlayers = GetPlayerArray_Alive()
		if ( alivePlayers.len() > 0 )
			specTarget = alivePlayers.getrandom()
		else
			return //GG
	}
	else
	{
		if ( clientTeam.len() > 0 )
			specTarget = clientTeam.getrandom()
	}
	
	if(squadCheck)
	{		
		RespawnBeacons_OnSquadEliminated( team ) // this sets respawnStatus too
		//StatsHook_SquadEliminated( GetPlayerArrayOfTeam_Connected( team ) )

		UpdateMatchSummaryPersistentVars( team )
		foreach ( sPlayer in GetPlayerArray() )
			Remote_CallFunction_NonReplay( sPlayer, "ServerCallback_SquadEliminated", team )
	} else
	{
		if ( !FromConnectingPlayerEliminated )
			player.SetPlayerNetInt( "respawnStatus", eRespawnStatus.WAITING_FOR_DELIVERY )
		else
			player.SetPlayerNetInt( "respawnStatus", eRespawnStatus.NONE )

		//Remote_CallFunction_NonReplay( player, "ServerCallback_DeathRecapDataUpdated", true, attackerEHandle)	//disabled 	
		
		//Remote_CallFunction_NonReplay( player, "ServerCallback_ShowDeathScreen" )
		Remote_CallFunction_ByRef( player, "ServerCallback_ShowDeathScreen" )
	}
		
	// wait 3 //Time to send death recap updated signal
	
	// if( !IsValid( player ) )
		// return

	wait GetDeathCamLength() //- 3 // To show deathcamera
	
	if( !IsValid( player ) )
		return
	
	if( !IsAlive( player ) && IsValid( specTarget ) && ShouldSetObserverTarget( specTarget ) )
	{
		player.SetPlayerNetInt( "spectatorTargetCount", GetPlayerArrayOfTeam_Alive( specTarget.GetTeam() ).len() )
		player.SetSpecReplayDelay( 1 )
		player.StartObserverMode( OBS_MODE_IN_EYE )
		player.SetObserverTarget( specTarget )
		player.SetPlayerCanToggleObserverMode( false )
	} else if( !IsAlive( player ) && GetPlayerArray_Alive().len() > 0 )
	{
		specTarget = GetPlayerArray_Alive().getrandom()
		
		if( !ShouldSetObserverTarget( specTarget ) )
			return // GG
		
		player.SetPlayerNetInt( "spectatorTargetCount", GetPlayerArrayOfTeam_Alive( specTarget.GetTeam() ).len() )
		player.SetSpecReplayDelay( 1 )
		player.StartObserverMode( OBS_MODE_IN_EYE )
		player.SetObserverTarget( specTarget )
		player.SetPlayerCanToggleObserverMode( false )
	}
}

void function PlayerStopSpectating( entity player )
{
	player.SetPlayerNetInt( "spectatorTargetCount", 0 )
	player.SetSpecReplayDelay( 0 )
	player.StopObserverMode()
}
#endif

#if SERVER
/*
	██████╗	 █████╗ ██╗     ██╗     ██████╗  █████╗  ██████╗██╗  ██╗███████╗
	██╔════╝██╔══██╗██║     ██║     ██╔══██╗██╔══██╗██╔════╝██║ ██╔╝██╔════╝
	██║     ███████║██║     ██║     ██████╔╝███████║██║     █████╔╝ ███████╗
	██║     ██╔══██║██║     ██║     ██╔══██╗██╔══██║██║     ██╔═██╗ ╚════██║
	╚██████╗██║  ██║███████╗███████╗██████╔╝██║  ██║╚██████╗██║  ██╗███████║
	 ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝

	This part describes the onboarding/shared gamemode callbacks.
*/

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	if ( !IsValid( victim ) || !IsValid( attacker ) )
		return
	
	if( is1v1EnabledAndAllowed() )
	{
		int sourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
		
		if ( sourceId == eDamageSourceId.damagedef_suicide || sourceId == eDamageSourceId.damagedef_despawn )
			return
	}
	
	UpdatePlayerCounts()
		
	if ( attacker.IsPlayer() && victim.IsPlayer() && attacker != victim )
	{
		attacker.SetPlayerNetInt( "kills", attacker.GetPlayerNetInt( "kills" ) + 1 )
	}

	if( Playlist() == ePlaylists.SURVIVAL )
		Remote_CallFunction_NonReplay( victim, "ServerCallback_YouDied", attacker, GetHealthFrac( victim ), DamageInfo_GetDamageSourceIdentifier( damageInfo ), DamageInfo_GetDamage( damageInfo ) )

	victim.SetPlayerGameStat( PGS_DEATHS, victim.GetPlayerGameStat( PGS_DEATHS ) + 1 )
	if( Gamemode() != eGamemodes.CUSTOM_CTF && Gamemode() != eGamemodes.fs_snd )
		victim.SetPlayerNetInt( "deaths", victim.GetPlayerNetInt( "deaths" ) + 1 )
	
	victim.FreezeControlsOnServer()
	
	victim.SetPredictionEnabled( false )
	
	if( Gamemode() == eGamemodes.fs_snd || Flowstate_IsHaloMode() ) //todo: init single bool conditional
		return
	
	victim.StartObserverMode( OBS_MODE_DEATHCAM )
	
	if( file.use_r2_deathcam && ShouldSetObserverTarget( attacker ) )
		victim.SetObserverTarget( attacker )
	else
		victim.SetObserverTarget( null )
}

void function ResetZiplineUseCountOnMantle( entity player )
{
	if( !IsValid( player ) )
		return
	
	//printt("Mantling, zipline use count reset.")
	
	player.p.ziplineUsages = 0
	Remote_CallFunction_NonReplay( player, "ServerCallback_NessyMessage", 40 )
}

void function OnClientConnected( entity player )
{
	// Min players logic
	int connectedPlayerCount = GetPlayerArray().len()

	SetGlobalNetInt( "connectedPlayerCount", connectedPlayerCount )

	int minPlayers = GetCurrentPlaylistVarInt( "min_players", 1 )
	
	if ( connectedPlayerCount >= minPlayers && !Flag( "MinPlayersReached" ) )
		FlagSet( "MinPlayersReached" )
	// Min players logic end
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.MANTLE, ResetZiplineUseCountOnMantle )
	UpdatePlayerCounts()
	
	int maxTeamSize = GetCurrentPlaylistVarInt( "max_team_size", 1 )
	int numTeams = GetCurrentPlaylistVarInt( "max_players", 0 ) / GetCurrentPlaylistVarInt( "max_team_size", 1 )

	array<entity> allplayers = GetPlayerArray()

	foreach (p in allplayers)
	{
		if (!IsValid(p)) continue

		int teamSize = GetPlayerArrayOfTeam( p.GetTeam() ).len()

		if( teamSize < maxTeamSize )
		{
			SetTeam( player, p.GetTeam() )
			break
		}
	}

	array<entity> playerTeam = GetPlayerArrayOfTeam( player.GetTeam() )
	int teamMemberIndex = playerTeam.len() - 1
	player.SetTeamMemberIndex( teamMemberIndex )


	bool replaceOrigin = false
	if( Playlist() == ePlaylists.survival_dev || Playlist() == ePlaylists.dev_default || GetCurrentPlaylistVarBool( "is_practice_map", false ) || Playlist() == ePlaylists.fs_movementrecorder )
	{
		vector origin
		if( GetPlayerArray_Alive().len() > 0 && IsValid( GetPlayerArray_Alive()[0] ) )
		{
			origin = GetPlayerArray_Alive()[0].GetOrigin()
			replaceOrigin = true
		}
		
		PlayerMatchState_Set( player, ePlayerMatchState.NORMAL )
		
		if( !GetCurrentPlaylistVarBool( "is_practice_map", false ) )
		{
			Flowstate_AssignUniqueCharacterForPlayer(player, true)
			player.SetOrigin( origin )
		}

		player.p.survivalLandedOnGround = true
		player.p.respawnPodLanded = true

		DecideRespawnPlayer( player, true )
		GiveBasicSurvivalItems( player )
	}

	if( !replaceOrigin )
	{
		switch( MapName() )
		{
			case eMaps.mp_rr_olympus_mu1:
				player.SetOrigin( <833.014587, -19103.7949, -4947.88916> )
				player.SetAngles( <0, -5.91907549, 0> )
			break
			case eMaps.mp_rr_canyonlands_64k_x_64k:
			case eMaps.mp_rr_canyonlands_mu1:
			case eMaps.mp_rr_canyonlands_mu2:
			case eMaps.mp_rr_canyonlands_mu1_night:				
				player.SetOrigin( <-3557.94165, 9962.51074, 3600> )
				player.SetAngles( <0, 65.3776093, 0> )
			break
			
			case eMaps.mp_rr_desertlands_64k_x_64k:
			case eMaps.mp_rr_desertlands_64k_x_64k_nx:
			case eMaps.mp_rr_desertlands_64k_x_64k_tt:
			case eMaps.mp_rr_desertlands_mu1:
			case eMaps.mp_rr_desertlands_holiday:
				player.SetOrigin( <4838.49658, 13516.8604, -4025.90625> )
				player.SetAngles( <0, -136.298843, 0> )
			break
			
			default:
				entity startEnt = GetEnt( "info_player_start" )
				player.SetOrigin( startEnt.GetOrigin() )
				player.SetAngles( startEnt.GetAngles() )
			break
		}
	}

	player.p.isConnected = true
	player.Signal( "OnConnected" )

	thread Flowstate_CheckForLv4MagazinesAndRefillAmmo( player )
}

void function OnCharacterClassChanged( EHI playerEHI, ItemFlavor flavor )
{
	if ( GetGameState() < eGameState.Playing && !IsFiringRangeGameMode() )
		return

	entity player = FromEHI( playerEHI )
	if ( IsAlive( player ) ) {	
		CharacterSelect_AssignCharacter( player, flavor, false )
		DecideRespawnPlayer( player )
	}
}

void function OnCharacterSkinChanged( EHI playerEHI, ItemFlavor flavor )
{
	if ( GetGameState() < eGameState.Playing && !IsFiringRangeGameMode() )
		return

	entity player = FromEHI( playerEHI )

	CharacterSkin_Apply( player, flavor )
}

array<int> function GetTeamsForPlayersFlowstate( array<entity> playersToUse )
{
	array<int> results
	foreach ( player in playersToUse )
	{
		int team = player.GetTeam()
		if ( !results.contains( team ) )
			results.append( team )
	}

	return results
}

void function UpdatePlayerCounts()
{

	//string currGameMode = GameRules_GetGameMode()
	
	int currGameMode = Gamemode()
	
	switch(currGameMode)
	{
		case eGamemodes.WINTEREXPRESS:
		array<entity> playersAlive = GetPlayerArray_Alive()
		SetGlobalNetInt( "livingPlayerCount", playersAlive.len() )
		SetGlobalNetInt( "squadsRemainingCount", playersAlive.len() )		
		break

		case eGamemodes.fs_infected:
		SetGlobalNetInt( "livingPlayerCount", GetPlayerArrayOfTeam_Alive(TEAM_IMC).len() )
		SetGlobalNetInt( "livingShadowPlayerCount", GetPlayerArrayOfTeam_Alive(TEAM_MILITIA).len() )
		SetGlobalNetInt( "squadsRemainingCount", 2 )
		break
		
		case eGamemodes.fs_dm:
		array<entity> connectedPlayers = GetPlayerArray_ConnectedNotSpectatorTeam()
		SetGlobalNetInt( "livingPlayerCount", connectedPlayers.len() )
		SetGlobalNetInt( "squadsRemainingCount", connectedPlayers.len() )
		break

		case eGamemodes.CUSTOM_CTF:
		array<entity> connectedPlayers = GetPlayerArray_ConnectedNotSpectatorTeam()
		SetGlobalNetInt( "livingPlayerCount", connectedPlayers.len() )
		SetGlobalNetInt( "squadsRemainingCount", connectedPlayers.len() )		
		break
		
		case eGamemodes.fs_prophunt:
		array<entity> propsAlive = GetPlayerArrayOfTeam_Alive( TEAM_MILITIA )
		SetGlobalNetInt( "livingPlayerCount", propsAlive.len() )
		SetGlobalNetInt( "squadsRemainingCount", propsAlive.len() )		
		break

		case eGamemodes.flowstate_pkknockback:
		array<entity> playersAlive = GetPlayerArray_Alive()
		SetGlobalNetInt( "livingPlayerCount", playersAlive.len() )
		SetGlobalNetInt( "squadsRemainingCount", playersAlive.len() )		
		break
		
		case eGamemodes.fs_duckhunt:
		array<entity> ducksAlive = GetPlayerArrayOfTeam_Alive( TEAM_MILITIA )
		SetGlobalNetInt( "livingPlayerCount", ducksAlive.len() )
		SetGlobalNetInt( "squadsRemainingCount", ducksAlive.len() )		
		break
		
		case eGamemodes.fs_snd:
		foreach( player in GetPlayerArray() )
			Remote_CallFunction_ByRef( player, "SND_ForceUpdatePlayerCount" )
			//Remote_CallFunction_NonReplay( player, "SND_ForceUpdatePlayerCount")
		break
		
		default:
		SetGlobalNetInt( "livingPlayerCount", GetPlayerArray_AliveConnected().len() )
		SetGlobalNetInt( "squadsRemainingCount", GetNumTeamsRemaining() )		
		break
	}

}
#endif

#if SERVER || CLIENT
/*
	██████╗	 ██████╗ ███╗   ██╗██████╗ ██╗████████╗██╗ ██████╗ ███╗   ██╗ █████╗ ██╗     ███████╗
	██╔════╝██╔═══██╗████╗  ██║██╔══██╗██║╚══██╔══╝██║██╔═══██╗████╗  ██║██╔══██╗██║     ██╔════╝
	██║     ██║   ██║██╔██╗ ██║██║  ██║██║   ██║   ██║██║   ██║██╔██╗ ██║███████║██║     ███████╗
	██║     ██║   ██║██║╚██╗██║██║  ██║██║   ██║   ██║██║   ██║██║╚██╗██║██╔══██║██║     ╚════██║
	╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║   ██║   ██║╚██████╔╝██║ ╚████║██║  ██║███████╗███████║
	 ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚══════╝

	This part describes customizable data which are used in sequence logic.
	The conditional functions usually get the value from the current playlist.
*/


// General
bool function OnboardingEnabled() 								{ return !GetCurrentPlaylistVarBool( "custom_onboarding", false ) }

// Waiting for players
bool function PreGame_GetWaitingForPlayersHasBlackScreen()		{ return GetCurrentPlaylistVarBool( "waiting_for_players_has_black_screen", false ) }
bool function PreGame_GetWaitingForPlayersSpawningEnabled()		{ return GetCurrentPlaylistVarBool( "waiting_for_players_spawning_enabled", false ) }
bool function PreGame_GetWaitingForPlayersWaitForeverEnabled() 	{ return GetCurrentPlaylistVarBool( "wait_for_players_forever", false ) }
float function PreGame_GetWaitingForPlayersDelayMin()			{ return GetCurrentPlaylistVarFloat( "waiting_for_players_min_wait", 0.0 ) }
float function PreGame_GetWaitingForPlayersDelayMax()			{ return GetCurrentPlaylistVarFloat( "waiting_for_players_timeout_seconds", 20.0 ) }
float function PreGame_GetWaitingForPlayersCountdown()			{ return GetCurrentPlaylistVarFloat( "waiting_for_players_countdown_seconds", 8.0 ) }

// Waiting for players -> character selection
float function CharSelect_GetIntroMusicStartTime()		 		{ return GetCurrentPlaylistVarFloat( "charselect_intro_music_start_time", -0.8 ) }
float function CharSelect_GetIntroTransitionDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_intro_transition_duration", 3.0 ) }
float function CharSelect_GetIntroCountdownDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_intro_countdown_duration", 0.0 ) }

// Character selection
float function CharSelect_GetPickingDelayBeforeAll()			{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_before_all", 0.0 ) }
float function CharSelect_GetPickingDelayOnFirst()				{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_on_first", 1.5 ) }
float function CharSelect_GetPickingSingleDurationMax()			{ return GetCurrentPlaylistVarFloat( "character_select_time_max", 8.0 ) }
float function CharSelect_GetPickingSingleDurationMin()			{ return GetCurrentPlaylistVarFloat( "character_select_time_min", 6.0 ) }
float function CharSelect_GetPickingDelayAfterEachLock()		{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_after_each_lock", 0.5 ) }
float function CharSelect_GetPickingDelayAfterAll()				{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_after_all", 1.5 ) }

// Character selection -> player squad -> champion squad -> outro
bool function CharSelect_PostSelectionMusicEnabled()			{ return GetCurrentPlaylistVarBool( "survival_enable_squad_intro_music", true ) }
bool function CharSelect_PlayerSquadIntroEnabled()				{ return GetCurrentPlaylistVarBool( "survival_enable_squad_intro", true ) }
bool function CharSelect_ChampionSquadIntroEnabled()			{ return GetCurrentPlaylistVarBool( "survival_enable_gladiator_intros", true ) }
float function CharSelect_GetOutroSceneChangeDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_outro_scene_change_duration", 4.0 ) }
float function CharSelect_GetOutroSquadPresentDuration()		{ return GetCurrentPlaylistVarFloat( "charselect_outro_squad_present_duration", 6.0  ) }
float function CharSelect_GetOutroChampionPresentDuration()		{ return GetCurrentPlaylistVarFloat( "charselect_outro_champion_present_duration", 8.0 ) }
float function CharSelect_GetOutroTransitionDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_outro_transition_duration", 3.0 ) }

// Custom logic
float function Survival_GetCharacterSelectDuration( int pickIndex )
{
	float min = CharSelect_GetPickingSingleDurationMin()
	float max = CharSelect_GetPickingSingleDurationMax()
	return GraphCapped( pickIndex, 0, MAX_TEAM_PLAYERS - 1, max, min )
}

bool function Survival_CharacterSelectEnabled()
{
	if ( Survival_GetCharacterSelectDuration( 0 ) <= 0.0 )
		return false

	return GetCurrentPlaylistVarBool( "charselect_enabled", true )
}
#endif

void function OnboardingPlaylistSettings_Init()
{
	#if CLIENT 
		SetConVarInt( "cl_quota_stringCmdsPerSecond", 200 )
	#endif 
	
	#if SERVER
		SetConVarInt( "sv_quota_stringCmdsPerSecond", 200 )
		file.flowstate_modified_movement = GetCurrentPlaylistVarInt( "flowstate_modified_movement", 0 )
		file.use_r2_deathcam = GetCurrentPlaylistVarBool( "use_r2_deathcam", false )
	#endif
}

#if SERVER
void function SetPlayerSettings( entity player, table settings )
{
	foreach( k,v in settings )
	{		
		string cmd_server = "_setClassVarServer"
		string cmd = " " + k + " " + v
		
		cmd_server += cmd 
		
		#if DEVELOPER
			printt( player, cmd_server )
		#endif
		
		ClientCommand( player, cmd_server )
		SetEntityVar( player, k, v )
		player.kv.k = v
	}
}

void function Flowstate_ApplyModifiedMovementToPlayer( entity player, bool resetOnly = false )
{
	if( file.flowstate_modified_movement == 0 )
		return

	if( resetOnly )
		return

	switch( file.flowstate_modified_movement )
	{
		case 1:
			player.SetMoveSpeedScale( 0.87 )		
			SetPlayerSettings( player, TRUE_TF2_SETTINGS )
			
			#if DEVELOPER
				printt( "Player movement changed to TF2" )
			#endif
		break
		
		case 2:
				StatusEffect_AddEndless(player, eStatusEffect.move_slow, 0.1)
				player.SetMoveSpeedScale(1.38854974986041364747)
				player.DisableMantle()
				player.SetGroundFrictionScale(1.03125)
				SetPlayerSettings( player, CSGO_MOVEMENT )
			
			#if DEVELOPER
				printt( "Player movement changed to CSGO" )
			#endif
		break

		case 3:
				StatusEffect_AddEndless(player, eStatusEffect.move_slow, 0.1)
				player.SetMoveSpeedScale(1.77840093365762835808)
				player.DisableMantle()	
				SetPlayerSettings( player, HL1_MOVEMENT )
			
			#if DEVELOPER
				printt( "Player movement changed to HL1" )
			#endif
		break

		case 4:
				StatusEffect_AddEndless(player, eStatusEffect.move_slow, 0.1)
				player.SetMoveSpeedScale( 1.1 )
				player.DisableMantle()
				SetPlayerSettings( player, HALO_MOVEMENT )
			
			#if DEVELOPER
				printt( "Player movement changed to Halo" )
			#endif
		break

		case 5:
				SetPlayerSettings( player, SURF_SETTINGS )
				
				#if DEVELOPER
					printt( "Player movement changed to Surf" )
				#endif
		break
		
		case 6:
				SetPlayerSettings( player, SUPERGLIDE_BOOST_SETTINGS )
				
				#if DEVELOPER
					printt( "Superglide modified for all players" )
				#endif
		break

		case 7:
				player.SetMoveSpeedScale( 0.87 )	
				SetPlayerSettings( player, TRUE_TF2_SETTINGS_LOW_GRAV )
				
				#if DEVELOPER
					printt( "Player movement changed to TF2" )
				#endif
		break
	}
}
#endif

void function ModifiedMovement_RegisterNetworking()
{
	foreach( k,v in HALO_MOVEMENT ) //using halo movement for var keys as a test
	{
		RegisterEntityVar_Entity( "player", expect string( k ), 0 )
		
		#if CLIENT
			RegisterEntityVarChangeCallback( "player", expect string( k ), OnVarChangedCallback_PlayerMovement )
		#endif
	}
}