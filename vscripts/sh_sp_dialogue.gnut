//=========================================================
//	sh_sp_dialogue.gnut
//=========================================================

#if CLIENT
const bool DEBUG_QUEUE_PRINTS = false

global table<string, bool> FORBIDDEN_DIALOGUE_EVENT_NAMES = {
		// only use this in case of emergencies!
		// diag_mp_pathfinder_ping_helpcall_1p = true, // example
}
#endif


global function RegisterCSVDialogue
global function SPDialogueInit
global function Dialog_RegisterNetworking


#if SERVER
global function PlayDialogue
global function PlayDialogue_AllConnectedPlayers
global function PlayDialogue_NoWait
global function PlayDialogueForAnimEvent
global function PlayBTDialogue
global function PlayGabbyDialogue
global function StopDialogue
global function StopDialogueForPlayer
global function PlayDialogueForPlayer_NoWait
global function PlayDialogueForPlayer
global function PlayRadioDialogueToAll
global function PlayRadioDialogueToTeam
global function PlayRadioDialogueToPlayer
#endif //SERVER


#if CLIENT
global function SCB_PlayDialogueOnEntity
global function SCB_PlayDialogueAtPosition
global function SCB_PlayDialogueOnEnvironmentSpeakers
global function SCB_PlayDialogueOnCustomSpeakers1
global function SCB_AbortCurrentDialogue
global function SetUseDialogueVDU
global function PlayAnyClientSelfDialogueByName
global function GetAnyDialogueAliasFromName
global function GetAnyAliasIdForName
global function PlayClientDialogueOnEntity

global function PauseDialogueQueue
global function ResumeDialogueQueue

global function ResumeMainDialogueQueue
global function PauseMainDialogueQueue
global function SuspendMainDialogueQueueForDurationOfSound
global function RemovePlayerDialogueEventsFromMainDialogueQueue


global function RegisterEnvironmentSpeaker
global function DeregisterEnvironmentSpeaker
global function CustomSpeakers1ListInit
#endif //CLIENT


#if DEVELOPER
global function ShouldTryToReplaceMissingVoiceWithTempVoice
#endif // DEVELOPERELOPER


//////////////////////
//////////////////////
//// Global Types ////
//////////////////////
//////////////////////
global struct QueueItem
{
	int    priority
	int    entHandle   = -1
	float  timeAdded   = -1
	bool   active      = false
	string debugRef    = ""
	bool   success     = true
	int    serialNum   = -1
}


enum eDialogueQueues
{
	main,
	custom1,

	_COUNT
}

global struct EnvironmentSpeaker
{
	vector origin
	string crowdQuietAlias             = ""
	string crowdActiveAlias            = ""
	string crowdCheerAlias             = ""
	string crowdRoarAlias              = ""
	string crowdOvationAlias           = ""
	string crowdChantAlias             = ""
	string crowdEndMatchChantAlias     = ""
	string activeVOLine                = ""
	float  quietLoopSecondsToTimeout   = 0
	float  activeLoopSecondsToTimeout  = 0
	float  cheerLoopSecondsToTimeout   = 0
	float  oneShotDelayBetweenReuse    = 0
	float  ovationLoopSecondsToTimeout = 0
	entity speakerEnt
	float  distanceSqr
}


global enum eDialogueFlags
{
	SHORT_DELAY_AFTER_PLAYING      = (1 << 0),
	SURVIVAL_HOST_ALL_SPEAKERS     = (1 << 1),
	NO_ON_FINISHED_NOTIFY          = (1 << 2),
	MUTE_PLAYER_PINGS_FOR_DURATION = (1 << 3),
	USE_CUSTOM_QUEUE1              = (1 << 4),
	USE_CUSTOM_SPEAKERS1           = (1 << 5),
}

// Speakers
global const string ENVIRONMENT_SPEAKER_SCRIPT_NAME = "info_survival_speaker_location"


// Play priorities
global const PRIORITY_NO_QUEUE  = 0     // Plays the dialogue right away, avoiding the queue.
global const PRIORITY_HIGH      = 20    // Enters the queue with the highest of priorities, only other items in queue of same priority will play first
global const PRIORITY_NORMAL    = 10
global const PRIORITY_LOW       = 5
global const PRIORITY_LOWEST    = 1


#if DEVELOPER
global const string TEMP_VOICE  = "playerM1"
#endif // DEVELOPERELOPER


///////////////////////
///////////////////////
//// Private Types ////
///////////////////////
///////////////////////
struct DialogueEntryGroup
{
	string     groupName
	array<int> aliasIds
	asset      sourceDataTable
}


struct DialogueData
{
	string alias
	int    priority
	string perspective
	bool   canPlayIfSolo
	string radioDisplayName
	string voice
	bool   radioIntercept
	string DEV_DialogueText
	asset  vduVideo

	DialogueEntryGroup& group
	int                 indexInGroup
}


struct QueueData
{
	array<QueueItem> queue
	#if CLIENT
		string flagPauseQueue
		int    dialoguePauseStackCount = 0
		table  signalDummy
	#endif
}


#if CLIENT
struct CachedCharacterData
{
	string longName
	asset  portraitImage
}
#endif //CLIENT


struct
{
	array<DialogueData>               registeredDialog
	table<string, DialogueEntryGroup> nameToGroupMap

	bool                  dialoguePlaying = false
	table<int, QueueData> queueDatas
	var                   currentDialoguePlayingHandle
	table<string, asset>  callerIDs
	table<int, bool>      waitingOnDialogue
	bool                  useVDU = false
	array<var>            currentDialoguePlayingHandles
	int                   lastLineRequestPriority

	array<string> validVoices

	#if DEVELOPER
		array<string> validPerspectives = ["", "solo", "radio"] // blank perspective means 1p and 3p, solo means additional to-self perspective on top of 1p and 3p
	#endif // DEVELOPERELOPER

	#if CLIENT
		var                                devTextDialogueRUI
		int                                videoChannel = -1
		array<EnvironmentSpeaker>          environmentSpeakers
		array<entity>                      customSpeakers1
		table<string, CachedCharacterData> voiceToCachedCharDataMap
	#endif //CLIENT
} file


/////////////////////////
/////////////////////////
//// Initialiszation ////
/////////////////////////
/////////////////////////
void function SPDialogueInit()
{
	//
	foreach ( string keyName, int eNumIdx in eDialogueQueues )
	{
		if ( eNumIdx == eDialogueQueues._COUNT )
			continue

		QueueData data
		#if(CLIENT)
			data.flagPauseQueue = format( "Flag_%sQueuePaused", keyName )
		#endif
		file.queueDatas[ eNumIdx ] <- data
	}

	#if SERVER
	RegisterSignal( "DialogueFinishedForID" )
	RegisterSignal( "AllDialogueFinished" )
	RegisterSignal( "fireSalvo" )
	AddClientCommandCallback( "DialogueFinishedForID", ClientCommand_DialogueFinishedForID )
	AddClientCommandCallback( "AllDialogueFinished", ClientCommand_AllDialogueFinished )

	#if DEVELOPER
		// When a character is loaded from bakery, add their currently registered voice value
		// to the list of voices to be verified by VerifyExistenceOfNongenericAliases
		AddCallback_OnItemFlavorRegistered( eItemType.character, OnCharacterRegistered )
	#endif //DEV
#endif //SERVER

	AddCallback_OnItemFlavorRegistered( eItemType.character, OnCharacterRegistered )

	#if(CLIENT)
		AddCallback_OnClientScriptInit( ClientScriptInitForPlayer )
		AddCallback_EntitiesDidLoad( EnvironmentSpeakerListInit )

		RegisterSignal( "QueueUpdated" )
		RegisterSignal( "NextInQueue" )
		RegisterSignal( "RemovedFromQueue" )
		RegisterSignal( "AbortCurrentDialogue" )
		RegisterSignal( "EndSoundEarly" )

		file.videoChannel = ReserveVideoChannel()

		foreach ( int idx, QueueData queueData in file.queueDatas )
		{
			FlagInit( queueData.flagPauseQueue, false )
			thread QueueThink( queueData )
		}

		foreach( string eventName, bool unused in FORBIDDEN_DIALOGUE_EVENT_NAMES )
			printf( "Dialogue sound event '%s' has been disabled in script.", eventName )
	#endif //
}


const string FUNCNAME_PlayDialogueOnEntity = "SCB_PlayDialogueOnEntity"
const string FUNCNAME_PlayDialogueAtPosition = "SCB_PlayDialogueAtPosition"
const string FUNCNAME_PlayDialogueOnEnvironmentSpeakers = "SCB_PlayDialogueOnEnvironmentSpeakers"
const string FUNCNAME_PlayDialogueOnCustomSpeakers1 = "SCB_PlayDialogueOnCustomSpeakers1"
const string FUNCNAME_AbortCurrentDialogue = "SCB_AbortCurrentDialogue"


void function Dialog_RegisterNetworking()
{
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnEntity, "int", -1, INT_MAX, "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueAtPosition, "int", -1, INT_MAX, "int", INT_MIN, INT_MAX, "vector", -MAX_WORLD_COORD, MAX_WORLD_COORD, 32 )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnEnvironmentSpeakers, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", -1, INT_MAX, "entity" )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnCustomSpeakers1, "int", 0, INT_MAX, "int", 0, INT_MAX )
	Remote_RegisterClientFunction( FUNCNAME_AbortCurrentDialogue )
}


DialogueData function GetDataForAliasId( int index )
{
	return file.registeredDialog[index]
}


#if SERVER && DEVELOPER
void function OnCharacterRegistered( ItemFlavor flavor )
{
	var block    = GetSettingsBlockForAsset( CharacterClass_GetSetFile( flavor ) )
	string voice = GetSettingsBlockString( block, "voice" )

	if ( !file.validVoices.contains( voice ) )
		file.validVoices.append( voice )
}
#endif //SERVER && DEVELOPER


#if(CLIENT)
int function GetAnyAliasIdForName( string dialogueName )
{
	if ( !(dialogueName in file.nameToGroupMap) )
		return -1
	DialogueEntryGroup group = file.nameToGroupMap[dialogueName]
	return group.aliasIds.getrandom()
}
#endif //

#if CLIENT || !DEVELOPER
void function OnCharacterRegistered( ItemFlavor flavor )
{
	var block    = GetSettingsBlockForAsset( CharacterClass_GetSetFile( flavor ) )
	string voice = GetSettingsBlockString( block, "voice" ).tolower()

	if ( !file.validVoices.contains( voice ) )
	{
		file.validVoices.append( voice )
		#if(CLIENT)
			CachedCharacterData ccd
			ccd.longName = ItemFlavor_GetLongName( flavor )
			ccd.portraitImage = CharacterClass_GetCharacterLockedPortrait( flavor )
			file.voiceToCachedCharDataMap[voice] <- ccd
		#endif //
	}
}
#endif


void function EnvironmentSpeakerListInit()
{
	#if(CLIENT)
		array<entity> speakerEnts = GetEntArrayByScriptName( ENVIRONMENT_SPEAKER_SCRIPT_NAME )

		foreach( speaker in speakerEnts )
		{
			RegisterEnvironmentSpeaker( speaker )
		}
	#endif //
}


#if(CLIENT)
void function CustomSpeakers1ListInit( array<entity> customSpeakers1 )
{
	if ( file.customSpeakers1.len() > 0 )
		printt( "Dialogue system custom speakers 1 already are set up, they are now being overwritten." )

	file.customSpeakers1 = customSpeakers1
}
#endif //


#if(CLIENT)
EnvironmentSpeaker function RegisterEnvironmentSpeaker( entity speakerEnt )
{
	EnvironmentSpeaker speaker
	speaker.origin = speakerEnt.GetOrigin()
	speaker.speakerEnt = speakerEnt

	file.environmentSpeakers.append( speaker )
	return speaker
}
#endif


#if(CLIENT)
void function DeregisterEnvironmentSpeaker( EnvironmentSpeaker speaker )
{
	file.environmentSpeakers.fastremovebyvalue( speaker )
}
#endif


void function RegisterCSVDialogue( asset dt )
{
	//
	var dataTable = GetDataTable( dt )

	int columnName                = GetDataTableColumnByName( dataTable, "name" )
	int columnAlias               = GetDataTableColumnByName( dataTable, "alias" )
	int columnPriority            = GetDataTableColumnByName( dataTable, "priority" )
	int columnRadioDisplayName    = GetDataTableColumnByName( dataTable, "radioDisplayName" )
	int columnVoice               = GetDataTableColumnByName( dataTable, "voice" )
	int columnRadioIntercept      = GetDataTableColumnByName( dataTable, "radioIntercept" )
	int columnVDUVideo            = GetDataTableColumnByName( dataTable, "vduVideo" )
	int columnDevDialogueText     = GetDataTableColumnByName( dataTable, "dialogue" )
	int optionalColumnPerspective = GetDataTableColumnByName( dataTable, "perspective" )
	int optionalCanPlayIfSolo     = GetDataTableColumnByName( dataTable, "canPlayIfSolo" )

	int numRows = GetDatatableRowCount( dataTable )
	for ( int i = 0; i < numRows; i++ )
	{
		string name = GetDataTableString( dataTable, i, columnName )

		//
		if ( name == "" )
			continue

		//
		if ( name.slice( 0, 2 ) == "//" )
			continue

		string alias = GetDataTableString( dataTable, i, columnAlias )
		int priority = GetDataTableInt( dataTable, i, columnPriority )
		Assert( priority >= 0, "Dialogue alias " + alias + " has invalid priority in the dialogue csv. Must be >= 0" )

		string extraPerspective = ((optionalColumnPerspective > -1) ? GetDataTableString( dataTable, i, optionalColumnPerspective ) : "")

		#if SERVER && DEVELOPER
		Assert( file.validPerspectives.contains( extraPerspective ), "Dialogue name " + name + " has a perspective field, but an invalid perspective. Check the perspective column in the CSV against file.validPerspectives in sh_sp_dialogue.gnut" )
		#endif

		bool canPlayIfSolo      = ((optionalCanPlayIfSolo > -1) ? GetDataTableBool( dataTable, i, optionalCanPlayIfSolo ) : true)
		string radioDisplayName = GetDataTableString( dataTable, i, columnRadioDisplayName )
		string voice            = ((columnVoice > -1) ? GetDataTableString( dataTable, i, columnVoice ).tolower() : "")
		bool radioIntercept     = ((columnRadioIntercept > -1) ? GetDataTableBool( dataTable, i, columnRadioIntercept ) : false)
		asset vduVideo          = ((columnVDUVideo > -1) ? GetDataTableAsset( dataTable, i, columnVDUVideo ) : $"")
		string DEV_DialogueText = GetDataTableString( dataTable, i, columnDevDialogueText )

		if ( (voice.len() > 0) && (!file.validVoices.contains( voice )) )
			Warning( "Dialogue '%s' in source '%s' specifies unknown voice '%s'.", name, string( dt ), voice )

		if ( (voice.len() > 0) && (radioDisplayName.len() > 0) )
		{
			Warning( "Dialogue '%s' has both voice '%s' and radioDisplay '%s'. Will only use voice.", name, voice, radioDisplayName )
			radioDisplayName = ""
		}

		RegisterDialogueLine( name, alias, priority, radioDisplayName, voice, radioIntercept, vduVideo, DEV_DialogueText, extraPerspective, canPlayIfSolo, dt )
	}
}


string s_prevNameRegistered
void function RegisterDialogueLine( string name, string alias, int priority, string radioDisplayName, string voice, bool radioIntercept, asset vduVideo, string DEV_DialogueText, string extraPerspective, bool canPlayIfSolo, asset dt )
{
	Assert( name != "", "Can't register a line of dialogue with no name" )
	Assert( priority >= 0, "Can't register a line of dialogue with a negative priority" )
	Assert( alias != "" || DEV_DialogueText != "", "Dialogue alias " + name + " doesn't have a miles event listed or dev text. You need one or the other." )

	if ( vduVideo != $"" )
		Assert( radioDisplayName != "", "Dialogue alias " + name + " specifies a vdu bink without setting radioDisplayName as well." )

#if SERVER && DEVELOPER
	if ( alias != "" && !DoesAliasExist( alias ) )
	{
		if ( alias.find( "%" ) >= 0 )
			VerifyExistenceOfNongenericAliases( alias, extraPerspective )
		else
			Warning( "Error: Dialogue '" + name + "': alias '" + alias + "' can't be registered because the alias does not exist" )
	}
#endif // SERVER && DEVELOPER

	DialogueData data
	data.alias = alias
	data.priority = priority
	data.perspective = extraPerspective
	data.canPlayIfSolo = canPlayIfSolo
	data.radioDisplayName = radioDisplayName
	data.voice = voice
	data.radioIntercept = radioIntercept
	data.vduVideo = vduVideo
	data.DEV_DialogueText = DEV_DialogueText

	int aliasId = file.registeredDialog.len()
	file.registeredDialog.append( data )

	if ( !(name in file.nameToGroupMap) )
	{
		DialogueEntryGroup newGroup
		newGroup.groupName = name
		newGroup.sourceDataTable = dt
		file.nameToGroupMap[name] <- newGroup
	}
	DialogueEntryGroup group = file.nameToGroupMap[name]
	Assert( (dt == group.sourceDataTable), format( "Dialogue entry '%s' from '%s' has already been defined in '%s'.", name, string( dt ), string( group.sourceDataTable ) ) )
	Assert( ((group.aliasIds.len() == 0) || (s_prevNameRegistered == name)), format( "Dialogue entry '%s' in '%s' is defined in more than one section. Dupes (groups) are allowed, but must be defined all one-after-another.", name, string( dt ) ) )

	data.indexInGroup = group.aliasIds.len()
	data.group = group
	group.aliasIds.append( aliasId )

	// printt( "DIALOGUE", name )

	s_prevNameRegistered = name
}

#if SERVER && DEVELOPER
void function VerifyExistenceOfNongenericAliases( string alias, string extraPerspective )
{
	array<string> specifiedPerspectiveAliases = []

	if ( alias.find( "%perspective%" ) >= 0 )
	{
		specifiedPerspectiveAliases.append( StringReplace( alias, "%perspective%", "1p" ) )
		specifiedPerspectiveAliases.append( StringReplace( alias, "%perspective%", "3p" ) )

		if ( extraPerspective != "" )
		{
			specifiedPerspectiveAliases.append( StringReplace( alias, "%perspective%", extraPerspective ) )
		}

	}
	else
	{
		specifiedPerspectiveAliases.append( alias )
	}

	foreach( string specifiedAlias in specifiedPerspectiveAliases )
	{
		if ( specifiedAlias.find( "%voice%" ) >= 0 )
		{
			foreach ( string voice in file.validVoices )
			{
				IssueWarningIfAliasMissing( StringReplace( specifiedAlias, "%voice%", voice ) )
			}
		}
		else
		{
			IssueWarningIfAliasMissing( specifiedAlias )
		}
	}
}

void function IssueWarningIfAliasMissing( string alias )
{
	if( !DoesAliasExist( alias ) )
		Warning( "Error: Dialogue alias '" + alias + "' can't be registered because the alias does not exist. Most likely missing a Miles event." )
}
#endif // SERVER && DEVELOPER

int function GetLinePriority( int aliasID )
{
	if ( aliasID == -1 )
		return -1

	DialogueData data = file.registeredDialog[aliasID]
	return data.priority
}

#if SERVER // TODO: This all needs to be fixed in the future!!!!
void function PlayDialogueForAnimEvent( entity ent, string dialogueName )
{
	if ( !( dialogueName in file.nameToGroupMap ) )
	{
		Warning(  ( "Dialogue line " + dialogueName + " is not registered" ) )
		return
	}

	DialogueEntryGroup group = file.nameToGroupMap[dialogueName]
	int aliasID = group.aliasIds.getrandom()
	DialogueData data = file.registeredDialog[aliasID]
	Assert( data.priority == PRIORITY_NO_QUEUE, ("Dialogue " + dialogueName + " triggered via qc must use PRIORITY_NO_QUEUE") )
	thread PlayDialogue( dialogueName, ent )
}

void function PlayDialogue( string name, entity speaker, float delay = 0, int dialogueFlags = 0 )
{
	array<entity> players = GetPlayerArray_Alive()
	for ( int i = players.len() - 1; i >= 0; i-- )
	{
		if ( i > 0 )
			thread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
		else
			waitthread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
	}
}

void function PlayDialogue_AllConnectedPlayers( string name, entity speaker, float delay = 0, int dialogueFlags = 0 )
{
	array<entity> players = GetPlayerArray()
	for ( int i = players.len() - 1; i >= 0; i-- )
	{
		if ( i > 0 )
			thread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
		else
			waitthread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
	}
}

void function PlayDialogue_NoWait( string name, entity speaker )
{
	array<entity> players = GetPlayerArray_Alive()
	for ( int i = players.len() - 1; i >= 0; i-- )
		PlayDialogueForPlayer_NoWait( name, players[i], speaker )
}

void function PlayBTDialogue( string name, float delay = 0, int dialogueFlags = 0 )
{
	/*array<entity> players = GetPlayerArray_Alive()
	for ( int i = players.len() - 1; i >= 0; i-- )
	{
		entity speaker
		entity petTitan = players[i].GetPetTitan()
		if ( IsValid( petTitan ) )
			speaker = GetBuddyTitanDialogueEnt( petTitan )
		else
			speaker = GetBuddyTitanDialogueEnt( players[i] )

		// Catch issues like BT is not created yet so the dialogue ent doesn't exist yet. In this case we just use the player for sound position, which gives us the same result anyhow.
		if ( !IsValid( speaker ) )
			speaker = players[i]

		if ( i > 0 )
			thread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
		else
			waitthread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
	}*/
}

void function PlayGabbyDialogue( string name, entity speaker, string anim = "face_generic_talker_flat" )
{
	speaker.EndSignal( "OnDestroy" )

	//for the next game we shouldn't have variants of dialogue and functionality should be done through a CSV - Chad
	speaker.Anim_ScriptedAddGestureSequence( anim, false )
	PlayDialogue( name, speaker )
	speaker.Anim_ScriptedRemoveAllGestures()
}

void function StopDialogue()
{
	array<entity> players = GetPlayerArray_Alive()
	foreach ( player in players )
		Remote_CallFunction_NonReplay( player, "SCB_AbortCurrentDialogue" )
}

void function StopDialogueForPlayer( entity player )
{
	Remote_CallFunction_NonReplay( player, "SCB_AbortCurrentDialogue" )
}

void function PlayDialogue_Internal( int aliasID, int dialogueFlags, entity player, entity speaker, int responseID = -1, entity responseSpeaker = null )
{
	if ( dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS )
	{
		Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueOnEnvironmentSpeakers, aliasID, NUM_NEARBY_SPEAKERS_TO_PLAY_FROM, dialogueFlags, responseID, responseSpeaker )
	}
	else if ( speaker.IsNPC() || speaker.IsPlayer() || (speaker.GetClassName() == "script_mover_lightweight") )
	{
		Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueOnEntity, aliasID, dialogueFlags, speaker.GetEncodedEHandle() )
	}
	else
	{
		vector pos = (speaker == svGlobal.worldspawn) ? player.EyePosition() : speaker.GetOrigin()
		Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueAtPosition, aliasID, dialogueFlags, pos)
	}
}

void function PlayDialogueForPlayer_NoWait( string name, entity player, entity speaker, float delay = 0, int dialogueFlags = 0 )
{
	/*if ( !IsValid( player ) )
		return

	if ( !IsValid( speaker ) )
		return

	if ( file.registeredDialog.find( name ) < 0 )
	{
		Warning( "Dialogue line " + name + " is not registered" )
		return
	}
	Assert( player.IsPlayer(), "Tried to play dialogue " + name + " to a non-player" )

	int aliasID = file.registeredDialog.find( name )

	if ( ! ShouldPlayDialogueIfSolo( file.registeredDialog[aliasID], speaker ) )
	{
		return
	}

	PlayDialogue_Internal( aliasID, (dialogueFlags | eDialogueFlags.NO_ON_FINISHED_NOTIFY), player, speaker )*/
}

void function PlayRadioDialogueTo_Internal( string alias, array<entity> players )
{
	/*int dialogueFlags = 0

	int aliasID = file.registeredDialog.find( alias )
	Assert( aliasID >= 0, "Given dialogue alias not registered." )
	foreach( entity player in players )
	{
		if ( !IsValid( player ) )
			continue
		PlayDialogue_Internal( aliasID, (dialogueFlags | eDialogueFlags.NO_ON_FINISHED_NOTIFY | eDialogueFlags.SHORT_DELAY_AFTER_PLAYING), player, svGlobal.worldspawn )
	}*/
}

void function PlayRadioDialogueToAll( string alias )
{
	array<entity> players = GetPlayerArray()
	PlayRadioDialogueTo_Internal( alias, players )
}

void function PlayRadioDialogueToTeam( string alias, int teamNum )
{
	array<entity> players = GetPlayerArrayOfTeam( teamNum )
	PlayRadioDialogueTo_Internal( alias, players )
}

void function PlayRadioDialogueToPlayer( string alias, entity player )
{
	PlayRadioDialogueTo_Internal( alias, [player] )
}

void function PlayDialogueForPlayer( string name, entity player, entity speaker, float delay = 0, int dialogueFlags = 0, string responseName = "", entity responseSpeaker = null )
{
	if ( !IsBattleChatterEnabled() )
		return

	if ( !IsValid( player ) )
		return

	if ( !IsValid( speaker )  && ( !( dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS ) ) )
		return

	EndSignal( player, "OnDestroy" )

	if ( !( dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS ) )
		EndSignal( speaker, "OnDestroy" )

	if ( !( name in file.nameToGroupMap ) )
	{
		Warning( "Dialogue line " + name + " is not registered" )
		return
	}

	DialogueEntryGroup group = file.nameToGroupMap[name]
	int aliasID = group.aliasIds.getrandom()

	int responseID = -1
	if ( responseName != "" )
	{
		if ( !( responseName in file.nameToGroupMap ) )
		{
			Warning( "Dialogue line " + responseName + " is not registered" )
		}
		else
		{
			DialogueEntryGroup responseGroup = file.nameToGroupMap[responseName]
			responseID = responseGroup.aliasIds.getrandom()

			Assert( GetLinePriority( responseID ) == PRIORITY_NO_QUEUE, "Can only pass responseName as param if primary dialogue line has 0 priority. Response should be queued instead." )

			if ( ! ShouldPlayDialogueIfSolo( file.registeredDialog[responseID], responseSpeaker ) )
			{
				responseID = -1
			}
		}
	}

	Assert( player.IsPlayer(), "Tried to play dialogue " + name + " to a non-player" )

	if ( delay > 0 )
		wait delay
	
	if( !IsValid( player ) ) 
		return
	
	if ( ! ShouldPlayDialogueIfSolo( file.registeredDialog[aliasID], speaker ) )
	{
		return
	}

	file.dialoguePlaying = true
	file.lastLineRequestPriority = GetLinePriority( aliasID )

	OnThreadEnd(
	function() : ( aliasID )
		{
			file.dialoguePlaying = false
			if ( aliasID in file.waitingOnDialogue )
				delete file.waitingOnDialogue[aliasID]
		}
	)

	if ( !(aliasID in file.waitingOnDialogue) )
		file.waitingOnDialogue[aliasID] <- true

	PlayDialogue_Internal( aliasID, dialogueFlags, player, speaker, responseID, responseSpeaker )

	while ( true )
	{
		table signalData = WaitSignal( level, "DialogueFinishedForID", "AllDialogueFinished" )
		if ( string( signalData.signal ) == "AllDialogueFinished" )
			break
		if ( int( signalData.aliasID ) == aliasID )
			break
		if ( !(aliasID in file.waitingOnDialogue) )
			break
	}
}

bool function ClientCommand_DialogueFinishedForID( entity player, array<string> args )
{
	string aliasID = args[ 0 ]
	table signalData = { aliasID = aliasID }
	if ( int( aliasID ) in file.waitingOnDialogue )
		delete file.waitingOnDialogue[int( aliasID )]
	Signal( level, "DialogueFinishedForID", signalData )
	return true
}

bool function ClientCommand_AllDialogueFinished( entity player, array<string> args )
{
	// This happens when a save is loaded. Server will be waiting to hear back from client that a dialogue alias is finished but client was reset, so we tell the server the line has stopped playing
	Signal( level, "AllDialogueFinished" )
	return true
}

#endif //SERVER


#if(CLIENT)
string function GetAnyDialogueAliasFromName( string name )
{
	int aliasID = GetAnyAliasIdForName( name )
	Assert( aliasID >= 0, "Dialogue line " + name + " is not registered" )
	DialogueData data = GetDataForAliasId( aliasID )
	return data.alias
}


int s_queueItemNextNum = 0
QueueItem function QueueAndWait( int priority, QueueData queueData, int entHandle = -1, string debugRef = "" )
{
	//

	//
	QueueItem queueItem
	queueItem.priority = priority
	queueItem.timeAdded = Time()
	queueItem.entHandle = entHandle
	queueItem.debugRef = debugRef
	queueItem.serialNum = s_queueItemNextNum
	//
	s_queueItemNextNum += 1

	//
	if ( priority == PRIORITY_NO_QUEUE )
		return queueItem

	//
	_AddToQueue( queueItem, queueData )

	//
	table result = WaitSignal( queueItem, "NextInQueue", "RemovedFromQueue" )
	//

	queueItem.success = (result.signal == "NextInQueue")
	//

	//
	return queueItem
}


void function _AddToQueue( QueueItem queueItem, QueueData queueData )
{
	Assert( !queueData.queue.contains( queueItem ) )

	queueData.queue.append( queueItem )
	queueData.queue.sort( QueueSort )

	//
	if ( queueData.queue.len() > 1 )
	{
		for ( int i = queueData.queue.len() - 1; i >= 0; i-- )
		{
			if ( queueData.queue[i].priority >= queueItem.priority )
				continue

			RemoveFromQueue( queueData.queue[i], queueData.queue )

			if ( i == 0 )
				AbortCurrentDialogue()
		}
	}

	//
	Signal( queueData.signalDummy, "QueueUpdated" )
}


void function RemovePlayerDialogueEventsFromMainDialogueQueue( entity player )
{
	if ( !IsValid( player ) )
		return

	array<QueueItem> queue = file.queueDatas[eDialogueQueues.main].queue

	int playerEntHandle = player.GetEncodedEHandle()

	if ( queue.len() >= 1 )
	{
		for ( int i = queue.len() - 1; i >= 0; i-- )
		{
			if ( queue[i].entHandle == -1 )
				continue

			if ( queue[i].entHandle == playerEntHandle )
			{
				RemoveFromQueue( queue[i], queue )

				if ( i == 0 )
					AbortCurrentDialogue()
			}
		}
	}
}


void function RemoveFromQueue( QueueItem queueItem, array<QueueItem> queue )
{
	//
	Signal( queueItem, "RemovedFromQueue" )
	if ( queue.contains( queueItem ) )
		queue.removebyvalue( queueItem )
}


int function QueueSort( QueueItem itemA, QueueItem itemB )
{
	if ( itemA.active )
		return -1
	if ( itemB.active )
		return 1

	if ( itemA.priority > itemB.priority )
		return -1
	if ( itemA.priority < itemB.priority )
		return 1

	if ( itemA.timeAdded < itemB.timeAdded )
		return -1
	if ( itemA.timeAdded > itemB.timeAdded )
		return 1

	if ( itemA.serialNum < itemB.serialNum )
		return -1
	if ( itemA.serialNum > itemB.serialNum )
		return 1

	Assert( itemA == itemB, "Queue items should never have equal sort values." )
	return 0
}


void function QueueThink( QueueData queueData )
{
	QueueItem currentItem
	array<QueueItem> queue = queueData.queue
	while ( true )
	{
		if ( queue.len() == 0 )
		{
			if ( DEBUG_QUEUE_PRINTS )
				printt( "Queue empty - waiting for signal" )
			WaitSignal( queueData.signalDummy, "QueueUpdated" )
			continue
		}

		FlagWaitClear( queueData.flagPauseQueue )

		if ( queue.len() == 0 )
			continue

		currentItem = queue[0]
		Signal( currentItem, "NextInQueue" )

		currentItem.active = true
		if ( DEBUG_QUEUE_PRINTS )
			printt( "waiting for script to clear the queue current item" )
		while ( queue.len() > 0 && currentItem == queue[0] )
		{
			if ( DEBUG_QUEUE_PRINTS )
			{
				printt( "Queue (len = " + queue.len() + "):" )
				foreach ( int i, QueueItem queueItem in queue )
				{
					if ( queueItem.active )
						printt( "  ", i, queueItem.timeAdded, "PRIORITY", queueItem.priority, queueItem.debugRef, "ACTIVE!" )
					else
						printt( "  ", i, queueItem.timeAdded, "PRIORITY", queueItem.priority, queueItem.debugRef )
				}
			}
			WaitFrame()
		}
	}
}


void function PauseMainDialogueQueue()
{
	PauseDialogueQueue( eDialogueQueues.main )
}


void function PauseDialogueQueue( int queueIdx )
{
	Assert( queueIdx < eDialogueQueues._COUNT, "Unknown enum index for eDialogueQueues: " + queueIdx )

	QueueData data = file.queueDatas[ queueIdx ]

	FlagSet( data.flagPauseQueue )
	data.dialoguePauseStackCount++
}


void function ResumeMainDialogueQueue()
{
	ResumeDialogueQueue( eDialogueQueues.main )
}


void function ResumeDialogueQueue( int queueIdx )
{
	Assert( queueIdx < eDialogueQueues._COUNT, "Unknown enum index for eDialogueQueues: " + queueIdx )

	QueueData data = file.queueDatas[ queueIdx ]

	data.dialoguePauseStackCount--
	if ( data.dialoguePauseStackCount <= 0 )
		FlagClear( data.flagPauseQueue )

	Assert( data.dialoguePauseStackCount >= 0, "Warning! ResumeDialogueQueue() called but queue wasn't paused!" )
}


void function SuspendMainDialogueQueueForDurationOfSound( entity player, var soundHandle )
{
	EndSignal( player, "OnDestroy" )

	OnThreadEnd(
		function()
		{
			ResumeMainDialogueQueue()
		}
	)

	PauseMainDialogueQueue()
	WaitSignal( soundHandle, "OnSoundFinished" )
}


void function SCB_PlayDialogueOnEntity( int aliasID, int dialogueFlags, int speakerEHandle )
{
	entity speaker = GetEntityFromEncodedEHandle( speakerEHandle )
	thread PlayClientDialogueOnEntity( aliasID, dialogueFlags, speaker )
}


void function SCB_PlayDialogueAtPosition( int aliasID, int dialogueFlags, vector pos )
{
	thread PlayClientDialogueOnPos( aliasID, dialogueFlags, pos )
}


void function SCB_PlayDialogueOnEnvironmentSpeakers( int aliasID, int numSpeakers, int dialogueFlags, int responseID, entity responseSpeaker )
{
	Assert( dialogueFlags & eDialogueFlags.USE_CUSTOM_QUEUE1, "Environment speaker dialogue must be called using the custom queue." )

	array<EnvironmentSpeaker> nearbySpeakers = SortEnvironmentSpeakersByClosest()
	array<entity> speakerEnts
	foreach ( int i, EnvironmentSpeaker speaker in nearbySpeakers )
	{
		if ( i >= numSpeakers )
			break
		speakerEnts.append( speaker.speakerEnt )
	}

	if ( speakerEnts.len() == 0 )
	{
		Warning( "No speakers found within 10000 units" )
		return
	}
	if ( responseID < 0 )
		thread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, speakerEnts )
	else
		thread PlayClientDialogueInCustomQueue1WithMainQueuedResponse( aliasID, responseID, dialogueFlags, speakerEnts, responseSpeaker, 0.0, 0.0, 0.0 )
}


array<EnvironmentSpeaker> function SortEnvironmentSpeakersByClosest()
{
	entity player    = GetLocalClientPlayer()
	vector playerPos = player.GetOrigin()

	array<EnvironmentSpeaker> nearbySpeakers
	const float maxDistSqr = 10000 * 10000
	foreach( EnvironmentSpeaker speaker in file.environmentSpeakers )
	{
		float distanceSqr = Distance2DSqr( playerPos, speaker.origin )
		if ( distanceSqr > maxDistSqr )
			continue

		speaker.distanceSqr = distanceSqr
		nearbySpeakers.append( speaker )
	}

	nearbySpeakers.sort( DistanceCompareClosestSpeaker )

	return nearbySpeakers
}


int function DistanceCompareClosestSpeaker( EnvironmentSpeaker a, EnvironmentSpeaker b )
{
	if ( a.distanceSqr > b.distanceSqr )
		return 1
	else if ( a.distanceSqr < b.distanceSqr )
		return -1

	return 0
}


void function SCB_PlayDialogueOnCustomSpeakers1( int aliasID, int dialogueFlags )
{
	if ( file.customSpeakers1.len() == 0 )
	{
		if ( Flag( "EntitiesDidLoad" ) )
			printt( "Custom Speakers 1 debug: Entities have loaded." )
		else
			printt( "Custom Speakers 1 debug: Entities have NOT loaded." )

		Assert( 0, "Custom Speakers 1 haven't been registered. Use the function CustomSpeakers1ListInit to create the array of speakers to be used." )
	}

	const float maxDistSqr = 2000.0 * 2000.0

	//
	entity player           = GetLocalClientPlayer()
	vector playerPos        = player.GetOrigin()
	bool playerNearSpeakers = false

	foreach ( entity speaker in file.customSpeakers1 )
	{
		if ( !IsValid( speaker ) )
			continue

		if ( Distance2DSqr( playerPos, speaker.GetOrigin() ) <= maxDistSqr )
		{
			playerNearSpeakers = true
			break
		}
	}

	if ( playerNearSpeakers )
		thread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, file.customSpeakers1 )
}


void function PlayClientDialogue_Internal( int aliasID, int dialogueFlags, array<entity> speakers, vector pos )
{
	if ( !IsBattleChatterEnabled() )
		return
	
	DialogueData data = GetDataForAliasId( aliasID )

	string milesAlias = data.alias

	if ( speakers.len() == 1 && ! ShouldPlayDialogueIfSolo( data, speakers[0] ) )
		return

	string radioDisplayName = data.radioDisplayName
	asset specificImage     = $""
	if ( milesAlias.find( "%" ) >= 0 )
	{
		Assert ( speakers.len() == 1, "Generic audio alias attempted to be made specific from multiple speakers simultaneously." )

		if ( IsValid( speakers[0] ) )
		{
			milesAlias = SpecifyAliasFromGeneric( data, speakers[0] )
		}
		else if ( speakers[0] == null )
		{
			milesAlias = SpecifyRadioDialoguePerspective( data )
			if ( (data.voice.len() > 0) && (data.voice in file.voiceToCachedCharDataMap) )
			{
				CachedCharacterData ccd = file.voiceToCachedCharDataMap[data.voice]
				radioDisplayName = ccd.longName
				specificImage = ccd.portraitImage
			}
		}
		else
		{
			Warning( "Tried to play '%s' with an invalid speaker. Couldn't specify generic alias.", milesAlias )
			return
		}
	}

	if ( DEBUG_QUEUE_PRINTS )
	{
		printt( "Dialogue Added to Queue" )
		printt( "  name:", data.group.groupName )
	}

	int speakerEHandle = -1
	if ( speakers.len() == 1 && IsValid( speakers[0] ) )
		speakerEHandle = speakers[0].GetEncodedEHandle()

	QueueData queueData = file.queueDatas[ eDialogueQueues.main ]

	if ( dialogueFlags & eDialogueFlags.USE_CUSTOM_QUEUE1 )
		queueData = file.queueDatas[ eDialogueQueues.custom1 ]

	QueueItem queueItem = QueueAndWait( data.priority, queueData, speakerEHandle, milesAlias )
	//
	if ( !queueItem.success )
		return

	bool isDevText = ((data.alias == "") && (data.DEV_DialogueText != ""))
	printf( "Playing Dialogue - '%s'#%d -> '%s', priority:%d, from:'%s'  %s", data.group.groupName, data.indexInGroup, milesAlias, data.priority, string( data.group.sourceDataTable ), (isDevText ? " (dev text)" : "") )

	float duration
	float extraWait = 0.0
	string speakerName
	if ( isDevText )
	{
		duration = max( data.DEV_DialogueText.len() * 0.07, 1.5 )
		printt( "len, duration", data.DEV_DialogueText.len(), duration )
		if ( speakers.len() == 0 || !IsValid( speakers[0] ) )
			speakerName = ((radioDisplayName.len() > 0) ? Localize( radioDisplayName ) : "non_NPC")
		else
			speakerName = speakers[0].GetScriptName()
	}
	else
	{
		duration = GetSoundDuration( milesAlias )
	}

	if ( dialogueFlags & eDialogueFlags.SHORT_DELAY_AFTER_PLAYING )
		extraWait = 0.40

	var waveformRUI
	if ( radioDisplayName != "" && file.useVDU )
	{
		waveformRUI = CreateWaveform( radioDisplayName, duration, specificImage, null, data.radioIntercept )
		if ( data.vduVideo != $"" )
			StartVideoOnChannel( file.videoChannel, data.vduVideo, false, 0.0 )
	}

	foreach( entity speaker in speakers )
	{
		if ( IsValid( speaker ) )
		{
			EndSignal( speaker, "OnDeath" )
			EndSignal( speaker, "OnDestroy" )
		}
	}

	entity player = GetLocalClientPlayer()
	EndSignal( player, "AbortCurrentDialogue" )

	OnThreadEnd(
		function() : ( player, aliasID, waveformRUI, queueItem, queueData, dialogueFlags )
		{
			if ( dialogueFlags & eDialogueFlags.MUTE_PLAYER_PINGS_FOR_DURATION )
				SetCommsDialogueEnabled( true )

			//
			if ( IsValid( player ) && !(dialogueFlags & eDialogueFlags.NO_ON_FINISHED_NOTIFY) )
				player.ClientCommand( "DialogueFinishedForID " + aliasID )
			if ( IsValid ( waveformRUI ) )
				thread DestroyWaveform( waveformRUI )
			file.currentDialoguePlayingHandle = null
			file.currentDialoguePlayingHandles = []

			RemoveFromQueue( queueItem, queueData.queue )
		}
	)

	if ( dialogueFlags & eDialogueFlags.MUTE_PLAYER_PINGS_FOR_DURATION )
		SetCommsDialogueEnabled( false )

	if ( !(milesAlias in FORBIDDEN_DIALOGUE_EVENT_NAMES) )
	{
		foreach( entity speaker in speakers )
		{
			if ( IsValid( speaker ) )
			{
				if ( isDevText )
					thread DevDialogueWithoutSoundAlias( speakerName, data.DEV_DialogueText, duration )
				else
					file.currentDialoguePlayingHandle = EmitSoundOnEntity( speaker, milesAlias )
			}
			else if ( pos != <0, 0, 0> )
			{
				if ( isDevText )
					thread DevDialogueWithoutSoundAlias( speakerName, data.DEV_DialogueText, duration )
				else
					file.currentDialoguePlayingHandle = EmitSoundAtPosition( TEAM_UNASSIGNED, pos, milesAlias )
			}
		}
	}

	if ( file.currentDialoguePlayingHandle != null )
	{
		WaitSignal( file.currentDialoguePlayingHandle, "OnSoundFinished" )
		wait extraWait
	}
	else
	{
		//
		wait duration + extraWait
	}

	if ( data.vduVideo != $"" )
		StopVideoOnChannel( 2 )

	if ( SurvivalCommentary_IsEnabled() )
		SurvivalCommentary_ClearCurrentSpeakerPrefix()
}


void function PlayAnyClientSelfDialogueByName( entity self, string name )
{
	int aliasID = GetAnyAliasIdForName( name )
	if ( aliasID < 0 )
	{
		Warning( "Dialogue line " + name + " is not registered" )
		return
	}

	int dialogueFlags = 0
	PlayClientDialogue_Internal( aliasID, dialogueFlags, [self], <0, 0, 0> )
}


void function PlayClientDialogueOnEntity( int aliasID, int dialogueFlags, entity ent )
{
	PlayClientDialogue_Internal( aliasID, dialogueFlags, [ent], <0, 0, 0> )
}


void function PlayClientDialogueOnSpeakers( int aliasID, int dialogueFlags, array<entity> speakers )
{
	PlayClientDialogue_Internal( aliasID, dialogueFlags, speakers, <0, 0, 0> )
}


void function PlayClientDialogueOnPos( int aliasID, int dialogueFlags, vector pos )
{
	PlayClientDialogue_Internal( aliasID, dialogueFlags, [null], pos )
}


void function PlayClientDialogueInCustomQueue1WithMainQueuedResponse( int aliasID, int responseID, int dialogueFlags, array<entity> speakers, entity responseSpeaker, float x, float y, float z )
{
	DialogueData leadingLineData  = GetDataForAliasId( aliasID )
	DialogueData responseLineData = GetDataForAliasId( responseID )

	string leadingMilesAlias  = leadingLineData.alias
	string responseMilesAlias = responseLineData.alias

	waitthread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, speakers )

	if ( IsValid( responseSpeaker ) )
		thread PlayClientDialogueOnEntity( responseID, dialogueFlags & ~eDialogueFlags.USE_CUSTOM_QUEUE1, responseSpeaker )
}


string function SpecifyAliasFromGeneric( DialogueData data, entity speaker )
{
	string milesAlias = data.alias

	string specifiedPerspective
	string extraPerspective = data.perspective

	specifiedPerspective = (speaker == GetLocalViewPlayer()) ? "1p" : "3p"

	if ( extraPerspective == "solo" && GetPlayerArrayOfTeam_Alive( speaker.GetTeam() ).len() == 1 )
	{
		specifiedPerspective = extraPerspective
	}

	if ( milesAlias.find( "%perspective%" ) >= 0 )
	{
		#if DEVELOPER
			Assert( specifiedPerspective != "", "Dialogue with generic perspective specified in CSV alias without specifying intended perspective!" )
		#endif //

		milesAlias = StringReplace( milesAlias, "%perspective%", specifiedPerspective )
	}

	string aliasWithGenericVoice = milesAlias

	string voice = GetPlayerVoice( speaker )
	if ( milesAlias.find( "%voice%" ) >= 0 )
		milesAlias = StringReplace( milesAlias, "%voice%", voice )

	#if DEVELOPER
		if ( ShouldTryToReplaceMissingVoiceWithTempVoice() )
		{
			if ( !DoesAliasExist( milesAlias ) )
			{
				if ( aliasWithGenericVoice.find( "%voice%" ) >= 0 )
				{
					milesAlias = StringReplace( aliasWithGenericVoice, "%voice%", TEMP_VOICE )

					if ( !DoesAliasExist( milesAlias ) )
						Warning( "Attempted to fall back to temp voice \"" + TEMP_VOICE + "\" for alias \"" + data.alias + "\", but resulting alias \"" + milesAlias + "\" does not exist in miles." )
				}
				else
				{
					Warning( "Alias \"" + aliasWithGenericVoice + "\" does not exist, and since there is no generic voice field, we can't fall back to \"" + TEMP_VOICE + "\"." )
				}
			}
		}
	#endif //

	return milesAlias
}


string function SpecifyRadioDialoguePerspective( DialogueData data )
{
	string milesAlias = data.alias
	if ( data.perspective != "radio" )
		return data.alias

	string radioAlias = StringReplace( milesAlias, "%perspective%", data.perspective )

	//
	if ( !DoesAliasExist( radioAlias ) )
		return StringReplace( milesAlias, "%perspective%", "3p" )

	return radioAlias
}


void function SCB_AbortCurrentDialogue()
{
	AbortCurrentDialogue()
}


void function AbortCurrentDialogue()
{
	if ( file.currentDialoguePlayingHandle != null )
	{
		StopSound( file.currentDialoguePlayingHandle )
		Signal( GetLocalClientPlayer(), "AbortCurrentDialogue" )
	}
	else if ( file.currentDialoguePlayingHandles.len() > 0 )
	{
		foreach(handle in file.currentDialoguePlayingHandles)
		{
			StopSound( handle )
		}
		Signal( GetLocalClientPlayer(), "AbortCurrentDialogue" )
	}
}


void function ClientScriptInitForPlayer( entity player )
{
	//
	player.ClientCommand( "AllDialogueFinished" )
}


void function DevDialogueWithoutSoundAlias( string speaker, string text, float duration )
{
	if ( IsValid( file.devTextDialogueRUI ) )
		RuiDestroyIfAlive( file.devTextDialogueRUI )
	file.devTextDialogueRUI = RuiCreate( $"ui/id_dev_text.rpak", clGlobal.topoFullScreen, RUI_DRAW_HUD, 0 )
	RuiSetFloat( file.devTextDialogueRUI, "startTime", Time() )
	RuiSetString( file.devTextDialogueRUI, "speaker", speaker )
	RuiSetString( file.devTextDialogueRUI, "text", text )
	RuiSetFloat( file.devTextDialogueRUI, "duration", duration )
	RuiSetResolutionToScreenSize( file.devTextDialogueRUI )
}


void function SetUseDialogueVDU( bool useVDU )
{
	file.useVDU = useVDU
}
#endif //


#if DEVELOPER
bool function ShouldTryToReplaceMissingVoiceWithTempVoice()
{
	return (GetCurrentPlaylistVarInt( "vo_fallback_to_temp", 0 ) == 1)
}
#endif //


int function GetLinePriorityForAliasId( int aliasId )
{
	DialogueData data = GetDataForAliasId( aliasId )
	return data.priority
}


bool function ShouldPlayDialogueIfSolo( DialogueData data, entity speaker )
{
	if ( data.canPlayIfSolo || AllowPlayersToTalkToThemselves() )
		return true

	if ( !IsValid( speaker ) ) //
		return true

	if ( !speaker.IsPlayer() )
		return true

	return GetPlayerArrayOfTeam_Alive( speaker.GetTeam() ).len() > 1
}
