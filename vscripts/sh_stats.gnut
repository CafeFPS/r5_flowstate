// see sh_stats_internals.gnut for internal stats functions


global function ShStats_LevelInit

#if SERVER
global function StatsHook_OnPlayerOrNPCTookDamage
global function StatsHook_OnPlayerConnected
global function StatsHook_OnPlayerLeft
global function StatsHook_LobbyStart
global function StatsHook_RecordPlacementStats
global function StatsHook_SquadEliminated
global function StatsHook_RoundEnd
global function StatsHook_GameEnd

global function StatsHook_SetPlaneData
global function StatsHook_SetSafeZone
global function StatsHook_SetDeathCircle

global function StatsHook_OnDoomingDamage
global function StatsHook_PlayerRespawnedTeammate
global function StatsHook_PlayerEquip
global function StatsHook_PlayerUsedResource

// Bloodhound
global function StatsHook_AreaSonarScan_EnemyDetected
//global function StatsHook_TrackingVision_OnPOIDetected

// Caustic
global function StatsHook_DirtyBomb_OnDetonate

// Gibraltar
global function StatsHook_BubbleShield_OnDamageAbsorbed
global function StatsHook_GibraltarGunShield_OnDamageAbsorbed

// Lifeline
global function StatsHook_MedicDeployableDrone_OnEntityHealResourceFinished
global function StatsHook_MedicCover_OnDamageAbsorbed

// Mirage
global function StatsHook_HoloPiliot_OnDecoyCreated
global function StatsHook_HoloPiliot_OnDecoyDamaged

// Pathfinder
global function StatsHook_Grapple_OnAttach
global function StatsHook_PlacedZipline_OnUsed
global function StatsHook_SurveyBeacon_OnSurveySuccess

// Wraith
global function StatsHook_PhaseTunnel_EntTraversed
global function StatsHook_PassiveVoices_VoiceHeard
global function StatsHook_Tactical_TimeSpentInPhase

//Bangalore
global function StatsHook_TrackAdrenalineDistance
global function StatsHook_CreepingBarrageDamage
#endif



//////////////////////
//////////////////////
//// Global Types ////
//////////////////////
//////////////////////

#if SERVER || CLIENT || UI
global struct CareerStats
{
	StatTemplate& account_level
	StatTemplate& total_legendary_items
	StatTemplate& num_characters_with_banners_once_filled
	StatTemplate& respawn_dev
	StatTemplate& ea_access_member
	StatTemplate& fashionista
	StatTemplate& weapons_with_legendary_skin
	StatTemplate& well_rounded
	StatTemplate& times_fully_kitted
	StatTemplate& distance_kill
	StatTemplate& placements_win_with_friends
	StatTemplate& placements_win_with_no_witnessess
	StatTemplate& placements_win_with_min_executions_per_person
	StatTemplate& team_work_kill_count
	StatTemplate& max_placement_win_streak_with_premade_squad
	StatTemplate& looted_all_launch_loot_once
	StatTemplate& master_of_all
	StatTemplate& starter_pack
	StatTemplate& founder_pack
	StatTemplate& twitch_pack

	//StatTemplate& owns_all_launch_legenedary_cosmetics
	//StatTemplate& owns_legendary_skin_and_finisher_for_all_launch_characters
	//StatTemplate& equipped_something_in_all_slots_of_all_launch_characters
	StatTemplate& looted_all_nongold_weapons_in_1_match

	StatTemplate& dooms
	StatTemplate& kills
	StatTemplate& times_got_doomed
	StatTemplate& deaths
	//StatTemplate& times_got_respawned
	//StatTemplate& times_recovered_ally_dna
	//StatTemplate& times_respawned_ally
	StatTemplate& winning_kills
	StatTemplate& kills_while_killleader
	StatTemplate& damage_done
	StatTemplate& damage_taken
	StatTemplate& shots
	StatTemplate& hits
	StatTemplate& headshots
	StatTemplate& executions
	StatTemplate& revived_ally
	StatTemplate& games_played
	StatTemplate& placements_win
	StatTemplate& placements_win_with_squad_alive
	StatTemplate& placements_top_3
	StatTemplate& neutral_airdrops_looted
	//StatTemplate& distance_traveled
	StatTemplate& weapon_kills
	StatTemplate& weapon_damage_done
	StatTemplate& weapon_shots
	StatTemplate& weapon_hits
	StatTemplate& weapon_headshots
	StatTemplate& character_kills
	StatTemplate& character_deaths
	StatTemplate& character_winning_kills
	StatTemplate& character_kills_while_killleader
	StatTemplate& character_damage_done
	StatTemplate& character_damage_done_max_single_game
	StatTemplate& character_shots
	StatTemplate& character_hits
	StatTemplate& character_headshots
	StatTemplate& character_executions
	StatTemplate& character_revived_ally
	StatTemplate& character_games_played
	StatTemplate& character_games_with_5_kills
	StatTemplate& character_games_with_20_kills
	StatTemplate& character_most_squad_squad_kills_in_1_game
	StatTemplate& character_placements_win
	StatTemplate& character_placements_win_with_squad_alive
	StatTemplate& character_placements_top_3
	StatTemplate& character_placements_win_with_friends
	StatTemplate& character_placements_win_as_jumpmaster
	StatTemplate& character_placements_win_as_killleader
	StatTemplate& character_placements_win_as_killleader_and_champion
	StatTemplate& character_placements_win_flawless_1
	StatTemplate& character_placements_win_flawless_2
	StatTemplate& character_placements_win_with_5_headshots
	StatTemplate& character_won_last_game
	StatTemplate& character_hot_streaks
	StatTemplate& character_games_with_respawning_both_teammates
	StatTemplate& character_rapid_eliminations
	StatTemplate& character_reinforcement_recalls
	StatTemplate& character_banner_once_filled

	StatTemplate& character_most_wins_in_24h
	StatTemplate& character_neutral_airdrops_looted
	//StatTemplate& character_distance_traveled
	StatTemplate& character_weapon_kills
	StatTemplate& character_weapon_damage_done
	StatTemplate& character_weapon_shots
	StatTemplate& character_weapon_hits
	StatTemplate& character_weapon_headshots
	StatTemplate& character_weaponcategory_kills
	StatTemplate& character_weaponcategory_damage_done
	StatTemplate& character_weaponcategory_shots
	StatTemplate& character_weaponcategory_hits
	StatTemplate& character_weaponcategory_headshots
	//Achievements
	StatTemplate& times_jumpmaster
	StatTemplate& valentines_revives_and_respawns
	// Bangalore

	StatTemplate& bangalore_passive_distance
	StatTemplate& bangalore_tactical_smoke_hits
	StatTemplate& bangalore_ultimate_damage_done

	// Bloodhound
	StatTemplate& bloodhound_tactical_enemies_detected
	StatTemplate& bloodhound_tactical_traps_detected
	StatTemplate& bloodhound_ultimate_kills_while_active
	StatTemplate& bloodhound_passive_clues_discovered

	// Caustic
	StatTemplate& caustic_tactical_barrels_traps_detonated
	StatTemplate& caustic_gas_damage_dealt
	StatTemplate& caustic_passive_enemies_in_gas_killed

	// Gibraltar
	StatTemplate& gibraltar_tactical_bubble_enemy_damage_absorbed
	StatTemplate& gibraltar_ultimate_bombardment_kills
	StatTemplate& gibraltar_passive_gunshield_enemy_damage_absorbed

	// Lifeline
	StatTemplate& lifeline_tactical_drone_healing_given
	StatTemplate& lifeline_ultimate_droppod_items_grabbed_by_allies
	StatTemplate& lifeline_passive_enemy_damage_absorbed

	// Mirage
	StatTemplate& mirage_decoys_created
	StatTemplate& mirage_successful_bamboozles
	StatTemplate& mirage_passive_distance_travelled_while_downed
	StatTemplate& mirage_successful_revives

	// Pathfinder
	StatTemplate& pathfinder_tactical_meters_moved_by_grapple
	StatTemplate& pathfinder_ultimate_ziplines_used_by_allies
	StatTemplate& pathfinder_passive_beacons_scanned

	// Wraith
	StatTemplate& wraith_tactical_phase_walk_distance_traveled
	StatTemplate& wraith_ultimate_phase_tunnel_ally_uses
	StatTemplate& wraith_passive_voices_heard
	StatTemplate& wraith_tactical_time_spent_in_phase
}
global struct MatchStats
{
	//StatTemplate& kills
}
#endif

#if SERVER || CLIENT || UI
global CareerStats CAREER_STATS// = { ... }
global MatchStats MATCH_STATS// = { ... }
#endif



///////////////////////
///////////////////////
//// Private Types ////
///////////////////////
///////////////////////
struct FileStruct_LifetimeLevel
{
	table<string, table<string, bool> > weaponStatCategoryWeaponItemRefSet

	#if SERVER
		table<string, bool> lootWeaponRefIsGold
		int                 countOfKindsOfNonGoldWeapons

		entity mostRecentDoomAttacker = null
		entity mostRecentDoomVictim = null
	#endif
}
FileStruct_LifetimeLevel& fileLevel



/////////////////////////
/////////////////////////
//// Initialiszation ////
/////////////////////////
/////////////////////////

#if SERVER || CLIENT || UI
void function ShStats_LevelInit()
{
	#if SERVER || CLIENT
		PIN_Init()
	#endif

	FileStruct_LifetimeLevel newFileLevel
	fileLevel = newFileLevel

	RegisterAllStats()

	#if SERVER
		AddCallback_GameStateEnter( eGameState.WaitingForPlayers, OnGameState_WaitingForPlayers )
		AddCallback_GameStateEnter( eGameState.Playing, OnGameState_Playing )
		AddCallback_GameStateEnter( eGameState.Postmatch, OnGameState_Postmatch )
		AddCallback_OnWeaponAttack( OnWeaponAttack )
		AddCallback_OnPlayerKilled( OnPlayerKilled )
		AddCallback_OnPlayerRespawned( OnPlayerRespawned )
		AddCallback_OnNPCKilled( OnNPCKilled )
		Bleedout_AddCallback_OnPlayerStartBleedout( OnPlayerStartBleedout )
		Bleedout_AddCallback_OnPlayerGotFirstAid( OnPlayerGotRevived )
		Loot_AddCallback_OnPlayerLootPickup( OnPlayerLootPickup )

		SetupTotalCompleteBannersCalcedStat()
	#endif

}
#endif


#if SERVER || CLIENT || UI
void function RegisterAllStats()
{
	array<ItemFlavor> allCharacters            = GetAllCharacters()
	array<string> allCharacterRefs             = []
	array<ItemFlavor> allWeapons               = GetAllWeaponItemFlavors()
	array<string> allWeaponsRefs               = []
	array<string> allLootWeaponStatsCategories = []

	foreach( ItemFlavor character in allCharacters )
		allCharacterRefs.append( ItemFlavor_GetGUIDString( character ) )

	foreach( ItemFlavor weapon in allWeapons )
	{
		string weaponRef = ItemFlavor_GetGUIDString( weapon )
		allWeaponsRefs.append( weaponRef )
		string category = WeaponItemFlavor_GetStatsCategory( weapon )

		bool isGold = (category == WEAPON_STAT_CATEGORY_GOLD_WEAPON)
		#if SERVER
			fileLevel.lootWeaponRefIsGold[weaponRef] <- isGold
			if ( !isGold )
				fileLevel.countOfKindsOfNonGoldWeapons++
		#endif

		if ( !(category in fileLevel.weaponStatCategoryWeaponItemRefSet) )
		{
			fileLevel.weaponStatCategoryWeaponItemRefSet[category] <- {}
			allLootWeaponStatsCategories.append( category )
		}
		fileLevel.weaponStatCategoryWeaponItemRefSet[category][weaponRef] <- true
	}

	CAREER_STATS.account_level = RegisterExpensiveCalculatedStat_Int( null, "account_level", GetAccountLevelForStat, [] )
	CAREER_STATS.total_legendary_items = RegisterCachedCalculatedStat_Int( null, "total_legendary_items", GetTotalLegendaryItems, [] )
	CAREER_STATS.num_characters_with_banners_once_filled = RegisterCachedCalculatedStat_Int( null, "num_characters_with_banners_once_filled", GetNumCharactersWithBannersOnceFilled, [] )
	CAREER_STATS.ea_access_member = RegisterExpensiveCalculatedStat_Int( null, "ea_access_member", GetEAAccessStatus, [] )
	CAREER_STATS.fashionista = RegisterCachedCalculatedStat_Int( null, "fashionista", GetCountOfCharactersWithLegendarySkinAndExecution, [] )
	CAREER_STATS.weapons_with_legendary_skin = RegisterCachedCalculatedStat_Int( null, "weapons_with_legendary_skin", GetCountOfWeaponsWithLegendarySkins, [] )
	CAREER_STATS.well_rounded = RegisterCachedCalculatedStat_Int( null, "well_rounded", GetCountOfCharactersWithWellRoundedDamage, [] )
	CAREER_STATS.looted_all_launch_loot_once = RegisterCachedCalculatedStat_Int( null, "looted_all_launch_loot_once", GetTreasureHunterStatus, [] )
	CAREER_STATS.master_of_all = RegisterCachedCalculatedStat_Int( null, "master_of_all", GetCountOfCharactersWithTenWins, [] )
	CAREER_STATS.starter_pack = RegisterExpensiveCalculatedStat_Int( null, "starter_pack_owner", GetStarterPackStatus, [] )
	CAREER_STATS.founder_pack = RegisterExpensiveCalculatedStat_Int( null, "founder_pack_owner", GetFounderPackStatus, [] )
	CAREER_STATS.twitch_pack = RegisterExpensiveCalculatedStat_Int( null, "twitch_pack_owner", GetTwitchPackStatus, [] )

	CAREER_STATS.respawn_dev = RegisterAccumulatedStat_Int( null, "respawn_dev" )
	CAREER_STATS.times_fully_kitted = RegisterAccumulatedStat_Int( null, "times_fully_kitted" )
	CAREER_STATS.distance_kill = RegisterAccumulatedStat_Int( null, "distance_kill" )

	//CAREER_STATS.owns_all_launch_legenedary_cosmetics = RegisterAccumulatedStat_Bool( null, "owns_all_launch_legenedary_cosmetics" )
	//CAREER_STATS.equipped_something_in_all_slots_of_all_launch_characters = RegisterAccumulatedStat_Bool( null, "equipped_something_in_all_slots_of_all_launch_characters" )
	CAREER_STATS.times_jumpmaster = RegisterAccumulatedStat_Int( null, "times_jumpmaster" )
	CAREER_STATS.looted_all_nongold_weapons_in_1_match = RegisterAccumulatedStat_Bool( null, "looted_all_nongold_weapons_in_1_match" ) // ✓
	CAREER_STATS.valentines_revives_and_respawns = RegisterAccumulatedStat_Int( null, "valentines_revives_and_respawns" )

	CAREER_STATS.dooms = RegisterAccumulatedStat_Int( null, "dooms" ) // ✓
	CAREER_STATS.kills = RegisterAccumulatedStat_Int( null, "kills" ) // ✓
	//MATCH_STATS.kills = RegisterAccumulatedStat_Int( null, "kills" ) // ✓
	CAREER_STATS.times_got_doomed = RegisterAccumulatedStat_Int( null, "times_got_doomed" ) // ✓
	CAREER_STATS.deaths = RegisterAccumulatedStat_Int( null, "deaths" ) // ✓
	//CAREER_STATS.times_got_respawned = RegisterAccumulatedStat_Int( null, "times_got_respawned" )
	//CAREER_STATS.times_recovered_ally_dna = RegisterAccumulatedStat_Int( null, "times_recovered_ally_dna" )
	//CAREER_STATS.times_respawned_ally = RegisterAccumulatedStat_Int( null, "times_respawned_ally" )
	CAREER_STATS.winning_kills = RegisterAccumulatedStat_Int( null, "winning_kills" ) // ✓
	CAREER_STATS.kills_while_killleader = RegisterAccumulatedStat_Int( null, "kills_while_killleader" )
	CAREER_STATS.damage_done = RegisterAccumulatedStat_Int( null, "damage_done" ) // ✓
	CAREER_STATS.damage_taken = RegisterAccumulatedStat_Int( null, "damage_taken" ) // ✓
	CAREER_STATS.shots = RegisterAccumulatedStat_Int( null, "shots" ) // ✓
	CAREER_STATS.hits = RegisterAccumulatedStat_Int( null, "hits" ) // ✓
	CAREER_STATS.headshots = RegisterAccumulatedStat_Int( null, "headshots" ) // ✓
	CAREER_STATS.executions = RegisterAccumulatedStat_Int( null, "executions" ) // ✓
	CAREER_STATS.revived_ally = RegisterAccumulatedStat_Int( null, "revived_ally" ) // ✓
	CAREER_STATS.games_played = RegisterAccumulatedStat_Int( null, "games_played" ) // ✓
	CAREER_STATS.placements_win = RegisterAccumulatedStat_Int( null, "placements_win" ) // ✓
	CAREER_STATS.placements_win_with_squad_alive = RegisterAccumulatedStat_Int( null, "placements_win_with_squad_alive" ) // ✓
	CAREER_STATS.placements_top_3 = RegisterAccumulatedStat_Int( null, "placements_top_3" ) // ✓
	CAREER_STATS.placements_win_with_friends = RegisterAccumulatedStat_Int( null, "placements_win_with_friends" )
	CAREER_STATS.placements_win_with_no_witnessess = RegisterAccumulatedStat_Int( null, "placements_win_with_no_witnessess" )
	CAREER_STATS.placements_win_with_min_executions_per_person = RegisterAccumulatedStat_Int( null, "placements_win_with_min_executions_per_person" )
	CAREER_STATS.max_placement_win_streak_with_premade_squad = RegisterAccumulatedStat_Int( null, "max_placement_win_streak_with_premade_squad" )
	CAREER_STATS.team_work_kill_count = RegisterAccumulatedStat_Int( null, "team_work_kill_count" )
	CAREER_STATS.neutral_airdrops_looted = RegisterAccumulatedStat_Int( null, "neutral_airdrops_looted" )
	//CAREER_STATS.distance_traveled = RegisterAccumulatedStat_Float( null, "distance_traveled" )

	StatEnumStruct weapon_SES = RegisterStatEnumStruct( null, "weapons", "eWeaponFlavor", allWeaponsRefs ) // ✓
	CAREER_STATS.weapon_kills = RegisterAccumulatedStat_Int( weapon_SES, "kills" ) // ✓
	CAREER_STATS.weapon_damage_done = RegisterAccumulatedStat_Int( weapon_SES, "damage_done" ) // ✓
	CAREER_STATS.weapon_shots = RegisterAccumulatedStat_Int( weapon_SES, "shots" ) // ✓
	CAREER_STATS.weapon_hits = RegisterAccumulatedStat_Int( weapon_SES, "hits" ) // ✓
	CAREER_STATS.weapon_headshots = RegisterAccumulatedStat_Int( weapon_SES, "headshots" ) // ✓

	StatEnumStruct character_SES = RegisterStatEnumStruct( null, "characters", "eCharacterFlavor", allCharacterRefs )
	CAREER_STATS.character_kills = RegisterAccumulatedStat_Int( character_SES, "kills" ) // ✓
	CAREER_STATS.character_deaths = RegisterAccumulatedStat_Int( character_SES, "deaths" ) // ✓
	CAREER_STATS.character_winning_kills = RegisterAccumulatedStat_Int( character_SES, "winning_kills" ) // ✓
	CAREER_STATS.character_kills_while_killleader = RegisterAccumulatedStat_Int( character_SES, "kills_while_killleader" )
	CAREER_STATS.character_damage_done = RegisterAccumulatedStat_Int( character_SES, "damage_done" ) // ✓
	CAREER_STATS.character_damage_done_max_single_game = RegisterAccumulatedStat_Int( character_SES, "character_damage_done_max_single_game" ) // ✓
	CAREER_STATS.character_shots = RegisterAccumulatedStat_Int( character_SES, "shots" ) // ✓
	CAREER_STATS.character_hits = RegisterAccumulatedStat_Int( character_SES, "hits" ) // ✓
	CAREER_STATS.character_headshots = RegisterAccumulatedStat_Int( character_SES, "headshots" ) // ✓
	CAREER_STATS.character_executions = RegisterAccumulatedStat_Int( character_SES, "executions" ) // ✓
	CAREER_STATS.character_revived_ally = RegisterAccumulatedStat_Int( character_SES, "revived_ally" ) // ✓
	CAREER_STATS.character_games_played = RegisterAccumulatedStat_Int( character_SES, "games_played" ) // ✓
	CAREER_STATS.character_games_with_5_kills = RegisterAccumulatedStat_Int( character_SES, "games_with_5_kills" ) // ✓
	CAREER_STATS.character_games_with_20_kills = RegisterAccumulatedStat_Int( character_SES, "games_with_20_kills" ) // ✓
	CAREER_STATS.character_games_with_respawning_both_teammates = RegisterAccumulatedStat_Int( character_SES, "character_games_with_respawning_both_teammates" ) // ✓
	CAREER_STATS.character_rapid_eliminations = RegisterAccumulatedStat_Int( character_SES, "character_rapid_eliminations" ) // ✓
	CAREER_STATS.character_most_squad_squad_kills_in_1_game = RegisterAccumulatedStat_Int( character_SES, "most_squad_squad_kills_in_1_game" )
	CAREER_STATS.character_placements_win = RegisterAccumulatedStat_Int( character_SES, "placements_win" ) // ✓
	CAREER_STATS.character_placements_win_with_squad_alive = RegisterAccumulatedStat_Int( character_SES, "placements_win_with_squad_alive" ) // ✓
	CAREER_STATS.character_placements_top_3 = RegisterAccumulatedStat_Int( character_SES, "placements_top_3" ) // ✓
	CAREER_STATS.character_placements_win_as_jumpmaster = RegisterAccumulatedStat_Int( character_SES, "character_placements_win_as_jumpmaster" ) // ✓
	CAREER_STATS.character_placements_win_as_killleader = RegisterAccumulatedStat_Int( character_SES, "character_placements_win_as_killleader" ) // ✓
	CAREER_STATS.character_placements_win_as_killleader_and_champion = RegisterAccumulatedStat_Int( character_SES, "character_placements_win_as_killleader_and_champion" ) // ✓
	CAREER_STATS.character_placements_win_flawless_1 = RegisterAccumulatedStat_Int( character_SES, "character_placements_win_flawless_1" ) // ✓
	CAREER_STATS.character_placements_win_flawless_2 = RegisterAccumulatedStat_Int( character_SES, "character_placements_win_flawless_2" ) // ✓
	CAREER_STATS.character_placements_win_with_5_headshots = RegisterAccumulatedStat_Int( character_SES, "character_placements_win_with_5_headshots" ) // ✓
	//Hot_Streak Badges
	CAREER_STATS.character_won_last_game = RegisterVariableStat_Bool( character_SES, "character_won_last_game" ) // ✓
	CAREER_STATS.character_hot_streaks = RegisterAccumulatedStat_Int( character_SES, "character_hot_streaks" ) // ✓
	CAREER_STATS.character_reinforcement_recalls = RegisterAccumulatedStat_Int( character_SES, "character_reinforcement_recalls" ) // ✓
	CAREER_STATS.character_banner_once_filled = RegisterAccumulatedStat_Bool( character_SES, "character_banner_once_filled" ) // ✓

	//CAREER_STATS.character_most_wins_in_24h = RegisterAccumulatedStat_Int( character_SES, "most_wins_in_24h" )
	CAREER_STATS.character_neutral_airdrops_looted = RegisterAccumulatedStat_Int( character_SES, "neutral_airdrops_looted" )
	//CAREER_STATS.character_distance_traveled = RegisterAccumulatedStat_Float( character_SES, "distance_traveled" )

	StatEnumStruct character_weapon_SES = RegisterStatEnumStruct( character_SES, "weapons", "eWeaponFlavor", allWeaponsRefs ) // ✓
	CAREER_STATS.character_weapon_kills = RegisterAccumulatedStat_Int( character_weapon_SES, "kills" ) // ✓
	CAREER_STATS.character_weapon_damage_done = RegisterAccumulatedStat_Int( character_weapon_SES, "damage_done" ) // ✓
	CAREER_STATS.character_weapon_shots = RegisterAccumulatedStat_Int( character_weapon_SES, "shots" ) // ✓
	CAREER_STATS.character_weapon_hits = RegisterAccumulatedStat_Int( character_weapon_SES, "hits" ) // ✓
	CAREER_STATS.character_weapon_headshots = RegisterAccumulatedStat_Int( character_weapon_SES, "headshots" ) // ✓

	StatEnumStruct character_weaponcategory_SES = RegisterStatEnumStruct( character_SES, "weaponcategories", "eWeaponStatCategory", allLootWeaponStatsCategories )

	StatTemplate temp_var_until_R5DEV_35088_is_fixed

	temp_var_until_R5DEV_35088_is_fixed = CAREER_STATS.character_weapon_kills
	CAREER_STATS.character_weaponcategory_kills = RegisterExpensiveCalculatedStat_Int( character_weaponcategory_SES, "kills",
		SetupCharacterWeaponCategoryStatSumEntryFunc_Int, [temp_var_until_R5DEV_35088_is_fixed] ) // ✓

	temp_var_until_R5DEV_35088_is_fixed = CAREER_STATS.character_weapon_damage_done
	CAREER_STATS.character_weaponcategory_damage_done = RegisterExpensiveCalculatedStat_Int( character_weaponcategory_SES, "damage_done",
		SetupCharacterWeaponCategoryStatSumEntryFunc_Int, [temp_var_until_R5DEV_35088_is_fixed] ) // ✓

	temp_var_until_R5DEV_35088_is_fixed = CAREER_STATS.character_weapon_shots
	CAREER_STATS.character_weaponcategory_shots = RegisterExpensiveCalculatedStat_Int( character_weaponcategory_SES, "shots",
		SetupCharacterWeaponCategoryStatSumEntryFunc_Int, [temp_var_until_R5DEV_35088_is_fixed] ) // ✓

	temp_var_until_R5DEV_35088_is_fixed = CAREER_STATS.character_weapon_hits
	CAREER_STATS.character_weaponcategory_hits = RegisterExpensiveCalculatedStat_Int( character_weaponcategory_SES, "hits",
		SetupCharacterWeaponCategoryStatSumEntryFunc_Int, [temp_var_until_R5DEV_35088_is_fixed] ) // ✓

	temp_var_until_R5DEV_35088_is_fixed = CAREER_STATS.character_weapon_headshots
	CAREER_STATS.character_weaponcategory_headshots = RegisterExpensiveCalculatedStat_Int( character_weaponcategory_SES, "headshots",
		SetupCharacterWeaponCategoryStatSumEntryFunc_Int, [temp_var_until_R5DEV_35088_is_fixed] ) // ✓

	CAREER_STATS.bloodhound_tactical_enemies_detected = RegisterAccumulatedStat_Int( null, "bloodhound_tactical_enemies_detected" )
	CAREER_STATS.bloodhound_tactical_traps_detected = RegisterAccumulatedStat_Int( null, "bloodhound_tactical_traps_detected" )
	CAREER_STATS.bloodhound_ultimate_kills_while_active = RegisterAccumulatedStat_Int( null, "bloodhound_ultimate_kills_while_active" )
	CAREER_STATS.bloodhound_passive_clues_discovered = RegisterAccumulatedStat_Int( null, "bloodhound_passive_clues_discovered" )
	CAREER_STATS.caustic_tactical_barrels_traps_detonated = RegisterAccumulatedStat_Int( null, "caustic_tactical_barrels_traps_detonated" )
	CAREER_STATS.caustic_gas_damage_dealt = RegisterAccumulatedStat_Int( null, "caustic_gas_damage_dealt" )
	CAREER_STATS.caustic_passive_enemies_in_gas_killed = RegisterAccumulatedStat_Int( null, "caustic_passive_enemies_in_gas_killed" )
	CAREER_STATS.gibraltar_tactical_bubble_enemy_damage_absorbed = RegisterAccumulatedStat_Int( null, "gibraltar_tactical_bubble_enemy_damage_absorbed" )
	CAREER_STATS.gibraltar_ultimate_bombardment_kills = RegisterAccumulatedStat_Int( null, "gibraltar_ultimate_bombardment_kills" )
	CAREER_STATS.gibraltar_passive_gunshield_enemy_damage_absorbed = RegisterAccumulatedStat_Int( null, "gibraltar_passive_gunshield_enemy_damage_absorbed" )
	CAREER_STATS.lifeline_tactical_drone_healing_given = RegisterAccumulatedStat_Int( null, "lifeline_tactical_drone_healing_given" )
	CAREER_STATS.lifeline_ultimate_droppod_items_grabbed_by_allies = RegisterAccumulatedStat_Int( null, "lifeline_ultimate_droppod_items_grabbed_by_allies" )
	CAREER_STATS.lifeline_passive_enemy_damage_absorbed = RegisterAccumulatedStat_Int( null, "lifeline_passive_enemy_damage_absorbed" )
	CAREER_STATS.mirage_decoys_created = RegisterAccumulatedStat_Int( null, "mirage_decoys_created" )
	CAREER_STATS.mirage_successful_bamboozles = RegisterAccumulatedStat_Int( null, "mirage_successful_bamboozles" )
	CAREER_STATS.mirage_successful_revives = RegisterAccumulatedStat_Int( null, "mirage_successful_revives" )
	CAREER_STATS.mirage_passive_distance_travelled_while_downed = RegisterAccumulatedStat_Float( null, "mirage_passive_distance_travelled_while_downed" )
	CAREER_STATS.pathfinder_tactical_meters_moved_by_grapple = RegisterAccumulatedStat_Float( null, "pathfinder_tactical_meters_moved_by_grapple" )
	CAREER_STATS.pathfinder_ultimate_ziplines_used_by_allies = RegisterAccumulatedStat_Int( null, "pathfinder_ultimate_ziplines_used_by_allies" )
	CAREER_STATS.pathfinder_passive_beacons_scanned = RegisterAccumulatedStat_Int( null, "pathfinder_passive_beacons_scanned" )
	CAREER_STATS.wraith_tactical_phase_walk_distance_traveled = RegisterAccumulatedStat_Float( null, "wraith_tactical_phase_walk_distance_traveled" )
	CAREER_STATS.wraith_ultimate_phase_tunnel_ally_uses = RegisterAccumulatedStat_Int( null, "wraith_ultimate_phase_tunnel_ally_uses" ) // ✓
	CAREER_STATS.wraith_passive_voices_heard = RegisterAccumulatedStat_Int( null, "wraith_passive_voices_heard" ) // ✓
	CAREER_STATS.wraith_tactical_time_spent_in_phase = RegisterAccumulatedStat_Float( null, "wraith_tactical_time_spent_in_phase" ) // ✓
	CAREER_STATS.bangalore_passive_distance = RegisterAccumulatedStat_Int( null, "bangalore_passive_distance" ) // ✓
	CAREER_STATS.bangalore_tactical_smoke_hits = RegisterAccumulatedStat_Int( null, "bangalore_tactical_smoke_hits" ) // ✓
	CAREER_STATS.bangalore_ultimate_damage_done = RegisterAccumulatedStat_Int( null, "bangalore_ultimate_damage_done" ) // ✓
}
#endif



///////////////////
///////////////////
//// Internals ////
///////////////////
///////////////////
#if SERVER
bool function ShouldGatherStats( entity player )
{
	Assert( IsValid( player ) )

	#if R5DEV
		if ( !GetCurrentPlaylistVarBool( "enable_stats", true ) )
			return false
	#endif

	// todo(dw): optimize this to just return the state of a file-level flag
	if ( GameRules_GetGameMode() == SURVIVAL && !Survival_HasPlayerJumpedOutOfPlane( player ) )
		return false

	return true
}
#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Non-player specific game state events ///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if SERVER
void function StatsHook_LobbyStart()
{
	Assert( IsLobby() )
	PIN_GameStart()
}
void function OnGameState_WaitingForPlayers()
{
	Assert( !IsLobby() )
	PIN_GameStart()
}
void function StatsHook_SetPlaneData( vector startPos, vector endPos, float duration )
{
	PIN_PlanePath( startPos, endPos, duration )
}
void function OnGameState_Playing()
{
	PIN_SetGameStartTime()
	foreach( entity player in GetPlayerArray() )
		PIN_GameStartedForPlayer( player )
}
void function StatsHook_SetDeathCircle( vector origin, float radius, string pinAction )
{
	PIN_CircleLocation( "death_circle", origin, radius, pinAction )
}
void function StatsHook_SetSafeZone( vector origin, float radius )
{
	PIN_CircleLocation( "safe_circle", origin, radius, "end_circle_close" )
}
void function OnGameState_Postmatch()
{
	//
}
void function StatsHook_RecordPlacementStats( entity player )
{
	Assert( !player.p.placementStatsRecorded )
	player.p.placementStatsRecorded = true

	int rank = Survival_GetCurrentRank( player )
	Assert( rank > 0 )
	GameSummarySquadData gameSummaryData = GameSummary_GetPlayerData( player )

	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	string characterRef  = ItemFlavor_GetGUIDString( character )

	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.games_played ), 1 )
	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_games_played, characterRef ), 1 )

	if ( gameSummaryData.kills >= 5 )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_games_with_5_kills, characterRef ), 1 )
	if ( gameSummaryData.kills >= 20 )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_games_with_20_kills, characterRef ), 1 )
	int oldMaxDamage = GetStat_Int( player, ResolveStatEntry( CAREER_STATS.character_damage_done_max_single_game, characterRef ), false )
	if ( gameSummaryData.damageDealt > oldMaxDamage )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_damage_done_max_single_game, characterRef ), gameSummaryData.damageDealt - oldMaxDamage )

	if ( GetGameState() >= eGameState.WinnerDetermined )
	{
		int winningTeam                = GetWinningTeam()
		array<entity> connectedWinners = GetPlayerArrayOfTeam( winningTeam )

		if ( player.GetTeam() == winningTeam )
		{
			if ( rank == 1 )
			{
				__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_win ), 1 )
				__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win, characterRef ), 1 )
				UpdateCalculatedStatCachedValue( player, ResolveStatEntry( CAREER_STATS.master_of_all ) )

				int count = 0
				foreach( ItemFlavor legend in GetAllCharacters() )
				{
					if ( GetStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win, ItemFlavor_GetGUIDString( legend ) ) ) > 0 )
						count++
				}
				if ( count >= 8 )
					UnlockAchievement( player, achievements.APEX_LEGEND )

				bool anyDead          = false
				int teamWorkKillCount = 0
				int teamKillCount     = 0
				bool noWitnessess     = true
				bool groupTheatrics   = true
				int teamDeathCount    = 0
				int teamDownedCount   = 0
				foreach( entity winner in connectedWinners)
				{
					if ( !IsAlive( winner ) )
					{
						anyDead = true
						break
					}
					GameSummarySquadData gsd = GameSummary_GetPlayerData( winner )
					teamWorkKillCount = int( max( teamWorkKillCount, gsd.kills ) )
					teamKillCount += gsd.kills
					if ( noWitnessess )
						noWitnessess = winner.p.noWitnessess
					if ( groupTheatrics )
						groupTheatrics = winner.p.executions > 0
					teamDeathCount += gsd.deaths
					teamDownedCount += winner.p.timesDowned
				}
				if ( teamKillCount < 15 )
					noWitnessess = false

				if ( teamDeathCount == 0 )
				{
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_flawless_1, characterRef ), 1 )
					if ( teamDownedCount == 0 )
						__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_flawless_2, characterRef ), 1 )
				}

				if ( player.p.headshotKills >= 5 )
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_with_5_headshots, characterRef ), 1 )

				int oldTeamWorkKillCount = GetStat_Int( player, ResolveStatEntry( CAREER_STATS.team_work_kill_count ), false )
				if ( teamWorkKillCount > oldTeamWorkKillCount )
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_win_with_squad_alive ), teamWorkKillCount - oldTeamWorkKillCount )

				if ( connectedWinners.len() == 3 && !anyDead )
				{
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_win_with_squad_alive ), 1 )
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_with_squad_alive, characterRef ), 1 )
				}

				bool fullPremadeSquad = player.GetPartySize() == 3
				if ( fullPremadeSquad )
				{
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_win_with_friends ), 1 )
					if ( noWitnessess )
						__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_win_with_no_witnessess ), 1 )
					if ( groupTheatrics )
						__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_win_with_min_executions_per_person ), 1 )
				}

				if ( GetStat_Bool( player, ResolveStatEntry( CAREER_STATS.character_won_last_game, characterRef ) ) )
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_hot_streaks, characterRef ), 1 )
				__SetStat_Bool( player, ResolveStatEntry( CAREER_STATS.character_won_last_game, characterRef ), true )

				if ( player.GetEncodedEHandle() == SurvivalCommentary_GetKillLeaderEEH() )
				{
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_as_killleader, characterRef ), 1 )
					if ( player.GetTeam() == SurvivalCommentary_GetChampionTeam() )
						__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_as_killleader_and_champion, characterRef ), 1 )
				}

				entity jumpMasterPlayer = GetJumpmasterForTeam( player.GetTeam() )
				if ( jumpMasterPlayer == player )
					__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win_as_jumpmaster, characterRef ), 1 )
			}

			if ( player == fileLevel.mostRecentDoomAttacker )
			{
				// this player got the winning "kill"

				__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.winning_kills ), 1 )
				__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_winning_kills, characterRef ), 1 )
			}
		}
	}

	if ( rank > 1 )
	{
		__SetStat_Bool( player, ResolveStatEntry( CAREER_STATS.character_won_last_game, characterRef ), false )
	}

	if ( rank <= 3 )
	{
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.placements_top_3 ), 1 )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_top_3, characterRef ), 1 )
	}

	int oldMaxSquadWipes = GetStat_Int( player, ResolveStatEntry( CAREER_STATS.character_most_squad_squad_kills_in_1_game, characterRef ), false )
	if ( player.p.squadWipes > oldMaxSquadWipes )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_most_squad_squad_kills_in_1_game, characterRef ), player.p.squadWipes - oldMaxSquadWipes )
}

void function StatsHook_SquadEliminated( array<entity> connectedSquadMembers )
{
	// todo(dw): I think this logic is wrong.
	if ( connectedSquadMembers.len() >= 3 )
	{
		bool squadWipe      = true
		entity lastAttacker = connectedSquadMembers[0].p.doomedAttacker
		if ( IsValid( lastAttacker ) ) //Squads can die by jumping off cliffs.
		{
			foreach( squadMember in connectedSquadMembers )
			{
				if ( lastAttacker != squadMember.p.doomedAttacker )
				{
					squadWipe = false
					break
				}
			}
			if ( squadWipe )
				lastAttacker.p.squadWipes++
		}
	}
}

void function StatsHook_RoundEnd( int roundNum )
{
	PIN_RoundEnd( roundNum )
}
void function StatsHook_GameEnd()
{
	PIN_GameEnd()
}
#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Core player lifecycle events ////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if SERVER
void function StatsHook_OnPlayerConnected( entity player )
{
	PIN_AddPlayer( player )

	// Triggered in lobby and maps
	int installTime = expect int( player.GetPersistentVar( "installUnixTime" ) )
	if ( installTime <= 0 )
		player.SetPersistentVar( "installUnixTime", GetUnixTimestamp() )
}
/*
'end_reason':'Disconnect by user.'
'end_reason':'Game Shutting Down'
'end_reason':'#DISCONNECT_TIMEDOUT
'end_reason':'Bot marked as ' leaving'
'end_reason':'Kicked by Console'
'end_reason':'Server running for more than a day. Disconnecting because we can' t handle running much longer'
'end_reason':'kick_all_bots'
'end_reason':'bye bye bot'
'end_reason':'#DISCONNECT_IDLE'
'end_reason':'#DISCONNECT_OUT_OF_SYNC'
*/
void function StatsHook_OnPlayerLeft( entity player, string reason )
{
	string pinReason = reason

	if ( reason.find( "Disconnect by user" ) != -1 )
		pinReason = "leave"
	else if ( reason.find( "Game Shutting Down" ) != -1 )
		pinReason = "error"
	else if ( reason.find( "DISCONNECT_TIMEDOUT" ) != -1 )
		pinReason = "error"
	else if ( reason.find( "Bot marked as" ) != -1 )
		pinReason = "leave"
	else if ( reason.find( "Server running for more than a day" ) != -1 )
		pinReason = "error"
	else if ( reason.find( "kick_all_bots" ) != -1 )
		pinReason = "kicked"
	else if ( reason.find( "bye bye bot" ) != -1 )
		pinReason = "kicked"
	else if ( reason.find( "DISCONNECT_IDLE" ) != -1 )
		pinReason = "kicked"
	else if ( reason.find( "DISCONNECT_OUT_OF_SYNC" ) != -1 )
		pinReason = "error"

	PIN_PlayerLeft( player, pinReason )
}
#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Kill, death, bleedout and respawn player events /////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if SERVER
void function OnPlayerRespawned( entity player )
{
	PIN_PlayerSpawned( player )
}

void function StatsHook_OnDoomingDamage( entity victim, entity attacker, var damageInfo )
{
	if ( !ShouldGatherStats( victim ) )
		return

	__IncrementStat_Int( victim, ResolveStatEntry( CAREER_STATS.times_got_doomed ), 1 )
	victim.p.timesDowned++

	if ( IsValid( attacker ) && attacker.IsPlayer() )
	{
		if ( victim != attacker )
		{
			fileLevel.mostRecentDoomAttacker = attacker
			victim.p.doomedAttacker = attacker
			fileLevel.mostRecentDoomVictim = victim
		}

		__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.dooms ), 1 )

		float distance = DamageInfo_GetDistFromAttackOrigin( damageInfo )
		distance = distance / 12
		distance *= 0.3048 //Convert to meters
		int newDistance    = int( distance )
		int oldMaxDistance = GetStat_Int( attacker, ResolveStatEntry( CAREER_STATS.distance_kill ), false )
		if ( newDistance > oldMaxDistance )
			__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.distance_kill ), newDistance )

		if ( IsValidHeadShot( damageInfo, victim ) )
		{
			__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.headshots ), 1 )
			attacker.p.headshotKills++
		}
	}
}
void function OnPlayerStartBleedout( entity victim, entity attacker, var damageInfo )
{
	Assert( victim.IsPlayer() )

	PIN_PlayerDowned( victim, attacker, damageInfo )
}
void function OnPlayerGotRevived( entity injured, entity healer )
{
	PIN_PlayerRevived( injured, healer )

	if ( !ShouldGatherStats( healer ) )
		return

	if ( IsValid( injured.p.doomedAttacker ) )
	{
		injured.p.doomedAttacker.p.noWitnessess = false
		injured.p.doomedAttacker = null
	}
	__IncrementStat_Int( healer, ResolveStatEntry( CAREER_STATS.revived_ally ), 1 )

	if ( GetCurrentPlaylistVarInt( "valentines_event", 0 ) > 0 )
		__IncrementStat_Int( healer, ResolveStatEntry( CAREER_STATS.valentines_revives_and_respawns ), 1 )

	if ( PlayerHasPassive( injured, ePassives.PAS_MIRAGE ) )
		__IncrementStat_Int( injured, ResolveStatEntry( CAREER_STATS.mirage_successful_revives ), 1 )

	ItemFlavor healerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( healer ), Loadout_CharacterClass() )
	string healerCharacterRef  = ItemFlavor_GetGUIDString( healerCharacter )
	__IncrementStat_Int( healer, ResolveStatEntry( CAREER_STATS.character_revived_ally, healerCharacterRef ), 1 )
}
void function OnPlayerKilled( entity victim, entity attacker, var attackerDamageInfo )
{
	Assert( IsValid( victim ) )
	Assert( IsValid( attacker ) )
	//Assert( attacker == DamageInfo_GetAttacker( attackerDamageInfo ) )
	Assert( victim.IsPlayer() )

	//entity weapon = DamageInfo_GetWeapon( attackerDamageInfo )
	//Assert( IsValid( weapon ) )
	PIN_PlayerKilled( victim, attacker, attackerDamageInfo ) // todo(dw): use attacker or credited killer for PIN?

	if ( !ShouldGatherStats( victim ) )
		return

	__IncrementStat_Int( victim, ResolveStatEntry( CAREER_STATS.deaths ), 1 )

	ItemFlavor victimCharacter = LoadoutSlot_GetItemFlavor( ToEHI( victim ), Loadout_CharacterClass() )
	string victimCharacterRef  = ItemFlavor_GetGUIDString( victimCharacter )
	__IncrementStat_Int( victim, ResolveStatEntry( CAREER_STATS.character_deaths, victimCharacterRef ), 1 )

	if ( attacker == victim )
		return // don't record kill stats for suicides

	ItemFlavor attackerCharacter
	if ( attacker.IsPlayer() )
	{
		attackerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( attacker ), Loadout_CharacterClass() )
		if ( DamageInfo_GetDamageType( attackerDamageInfo ) == DMG_MELEE_EXECUTION )
		{
			__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.executions ), 1 )
			__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_executions, ItemFlavor_GetGUIDString( attackerCharacter ) ), 1 )
			attacker.p.executions++
		}
	}

	bool haveKiller = false
	entity killer
	ItemFlavor killerCharacter
	//var killerDamageInfo
	ScriptDamageInfoClone killerDIC

	if ( Bleedout_IsBleedingOut( victim ) )
	{
		// todo(dw): find out who execution kills should be credited to
		entity bleedoutAttacker = Bleedout_GetBleedoutAttacker( victim )
		if ( IsValid( bleedoutAttacker ) && bleedoutAttacker.IsPlayer() )
		{
			haveKiller = true
			killer = bleedoutAttacker
			killerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( killer ), Loadout_CharacterClass() )
			//killerDamageInfo = Bleedout_GetBleedoutDamageInfo( victim )
			killerDIC = Bleedout_GetBleedoutDamageInfo( victim )
		}
	}

	if ( !haveKiller && attacker.IsPlayer() )
	{
		haveKiller = true
		killer = attacker
		killerCharacter = attackerCharacter
		//killerDamageInfo = attackerDamageInfo
		killerDIC = CloneScriptDamageInfo( attackerDamageInfo ) // todo(dw): aaaaaaaaaAAAAAAAA
	}

	if ( haveKiller )
	{
		if ( !ShouldGatherStats( killer ) )
			return

		string killerCharacterRef = ItemFlavor_GetGUIDString( killerCharacter )

		// player killed player
		//IncrementStat_Int( killer, ResolveStatEntry( MATCH_STATS.kills ), 1 )
		__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.kills ), 1 )
		__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.character_kills, killerCharacterRef ), 1 )

		if ( Time() < victim.p.lastRespawnTouchGroundTime + 10.0 || victim.p.lastRespawnTouchGroundTime < victim.p.lastRespawnTime )
			__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.character_reinforcement_recalls, killerCharacterRef ), 1 )

		RemoveInvalidRapidElimKills( killer )
		killer.p.rapidElimTracker.append( Time() )
		if ( killer.p.rapidElimTracker.len() == 4 )
		{
			__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.character_rapid_eliminations, killerCharacterRef ), 1 )
			ClearRapidElimKills( killer )
		}

		if ( killer.GetEncodedEHandle() == SurvivalCommentary_GetKillLeaderEEH() )
		{
			__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.kills_while_killleader ), 1 )
			__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.character_kills_while_killleader, killerCharacterRef ), 1 )
		}

		string ornull killerWeaponClassNameOrNull = GetWeaponClassNameFromDamageInfoClone( killerDIC )

		if ( killerWeaponClassNameOrNull != null )
		{
			ItemFlavor ornull killerWeaponFlavorOrNull = GetWeaponItemFlavorByClass( expect string(killerWeaponClassNameOrNull) )
			if ( killerWeaponFlavorOrNull != null )
			{
				string killerWeaponRef = ItemFlavor_GetGUIDString( expect ItemFlavor(killerWeaponFlavorOrNull) )

				__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.weapon_kills, killerWeaponRef ), 1 )

				__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.character_weapon_kills, killerCharacterRef, killerWeaponRef ), 1 )
			}
			else
			{
				//Warning( "Stats not being recorded for weapon: %s", weaponClassName )
			}
		}
		else
		{
			//Warning( "Unable to detect weapon from player death: %s %S", string(victim), string(DamageInfo_GetDamageSourceIdentifier( damageInfo ) ) )
		}

		int killerDamageSourceId = killerDIC.damageSourceIdentifier
		StatsHook_HuntMode_OnKill( killer )
		StatsHook_GasTraps_OnKill( killer, victim, killerCharacter )
		StatsHook_DefensiveBombardment_OnKill( killer, killerDamageSourceId )
	}
}
void function RemoveInvalidRapidElimKills( entity killer )
{
	for ( int i = killer.p.rapidElimTracker.len() - 1; i >= 0; i-- )
	{
		if ( Time() - killer.p.rapidElimTracker[ i ] > 20.0 )
			killer.p.rapidElimTracker.remove( i )
	}
}

void function ClearRapidElimKills( entity killer )
{
	for ( int i = killer.p.rapidElimTracker.len() - 1; i >= 0; i-- )
	{
		killer.p.rapidElimTracker.remove( i )
	}
}

void function OnNPCKilled( entity victim, entity attacker, var damageInfo )
{
	// todo(dw): do this section
}
void function StatsHook_PlayerRespawnedTeammate( entity respawnCaller, entity respawningPlayer )
{
	if ( GetCurrentPlaylistVarInt( "valentines_event", 0 ) > 0 )
		__IncrementStat_Int( respawnCaller, ResolveStatEntry( CAREER_STATS.valentines_revives_and_respawns ), 1 )

	if ( !(respawnCaller.p.playersRespawned.contains( respawningPlayer )) )
	{
		respawnCaller.p.playersRespawned.append( respawningPlayer )
		if ( respawnCaller.p.playersRespawned.len() == 2 )
		{
			ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( respawnCaller ), Loadout_CharacterClass() )
			string characterRef  = ItemFlavor_GetGUIDString( character )
			__IncrementStat_Int( respawnCaller, ResolveStatEntry( CAREER_STATS.character_games_with_respawning_both_teammates, characterRef ), 1 )
		}
	}

	respawningPlayer.p.lastRespawnTime = Time()

	if ( IsValid( respawningPlayer.p.doomedAttacker ) )
	{
		respawningPlayer.p.doomedAttacker.p.noWitnessess = false
		respawningPlayer.p.doomedAttacker = null
	}
}
#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Weapon-fire and damage player events ////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if SERVER
void function OnWeaponAttack( entity player, entity weapon, string weaponName, int ammoUsed, vector attackOrigin, vector attackDir )
{
	Assert( IsValid( player ) )
	Assert( player.IsPlayer() )
	Assert( IsValid( weapon ) )

	if ( !ShouldGatherStats( player ) )
		return

	ItemFlavor ornull weaponFlavorOrNull = GetWeaponItemFlavorByClass( weaponName )
	if ( weaponFlavorOrNull != null )
	{
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.shots ), 1 )

		ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
		string playerCharacterRef  = ItemFlavor_GetGUIDString( playerCharacter )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_shots, playerCharacterRef ), 1 )

		string weaponFlavorRef = ItemFlavor_GetGUIDString( expect ItemFlavor(weaponFlavorOrNull) )

		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.weapon_shots, weaponFlavorRef ), 1 )

		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.character_weapon_shots, playerCharacterRef, weaponFlavorRef ), 1 )
	}
	else
	{
		//Warning()
	}
}
void function StatsHook_OnPlayerOrNPCTookDamage( entity attacker, entity victim, var damageInfo, int healthDamage, int shieldDamage )
{
	//Assert( IsValid( attacker ) )
	Assert( IsValid( victim ) )

	int damageAmount = healthDamage + shieldDamage
	if ( IsValid( attacker ) )
		PIN_DamageDone( attacker, victim, float(damageAmount) )

	if ( attacker == victim )
		return // don't track self-inflicted damage

	if ( IsValid( attacker ) && attacker.IsPlayer() )
	{
		if ( !ShouldGatherStats( attacker ) )
			return

		if ( victim.IsPlayer() )
		{
			bool isHeadshot = !Bleedout_IsBleedingOut( victim ) && IsValidHeadShot( damageInfo, victim )

			// track damage done for all things
			__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.damage_done ), damageAmount )

			ItemFlavor attackerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( attacker ), Loadout_CharacterClass() )
			string attackerCharacterRef  = ItemFlavor_GetGUIDString( attackerCharacter )
			__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_damage_done, attackerCharacterRef ), damageAmount )
			UpdateCalculatedStatCachedValue( attacker, ResolveStatEntry( CAREER_STATS.well_rounded ) )

			string ornull weaponClassNameOrNull = GetWeaponClassNameFromDamageInfo( damageInfo )
			if ( weaponClassNameOrNull != null )
			{
				PIN_DamageDoneToPlayerForWeapon( attacker, expect string( weaponClassNameOrNull ), float(damageAmount), isHeadshot )

				ItemFlavor ornull weaponFlavorOrNull = GetWeaponItemFlavorByClass( expect string(weaponClassNameOrNull) )
				if ( weaponFlavorOrNull != null )
				{
					// todo(dw): hits and headshots will be incorrectly inflated by DoT grenades and abilities

					// track hits and headshots only for certain weapons
					__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.hits ), 1 )
					if ( isHeadshot )
						__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.headshots ), 1 )

					__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_hits, attackerCharacterRef ), 1 )
					if ( isHeadshot )
						__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_headshots, attackerCharacterRef ), 1 )

					string weaponFlavorRef = ItemFlavor_GetGUIDString( expect ItemFlavor(weaponFlavorOrNull) )

					__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.weapon_damage_done, weaponFlavorRef ), damageAmount )
					__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.weapon_hits, weaponFlavorRef ), 1 )
					if ( isHeadshot )
						__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.weapon_headshots, weaponFlavorRef ), 1 )

					__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_weapon_damage_done, attackerCharacterRef, weaponFlavorRef ), damageAmount )
					__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_weapon_hits, attackerCharacterRef, weaponFlavorRef ), 1 )
					if ( isHeadshot )
						__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.character_weapon_headshots, attackerCharacterRef, weaponFlavorRef ), 1 )
				}
				else
				{
					//Warning()
				}
			}

			int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
			StatsHook_GasDamage_OnPlayerTookDamage( attacker, damageSourceId, damageAmount )
			StatsHook_SmokeHits_OnPlayerTookDamage( attacker, damageSourceId )
		}
	}

	if ( victim.IsPlayer() )
	{
		__IncrementStat_Int( victim, ResolveStatEntry( CAREER_STATS.damage_taken ), damageAmount )
	}
}
#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Loot player events //////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if SERVER
void function OnPlayerLootPickup( entity user, entity lootPickup, string ref, bool willDestroy )
{
	Assert( IsValid( user ) && user.IsPlayer() && IsValid( lootPickup ) )

	if ( !ShouldGatherStats( user ) )
		return

	if ( !(ref in user.p.lootRefPickupCounts) )
	{
		user.p.lootRefPickupCounts[ref] <- 0

		ItemFlavor ornull killerWeaponFlavorOrNull = GetWeaponItemFlavorByClass( ref )
		if ( killerWeaponFlavorOrNull != null )
		{
			string weaponItemFlavorRef = ItemFlavor_GetGUIDString( expect ItemFlavor(killerWeaponFlavorOrNull) )
			if ( (weaponItemFlavorRef in fileLevel.lootWeaponRefIsGold) && (!fileLevel.lootWeaponRefIsGold[weaponItemFlavorRef]) )
			{
				user.p.kindsOfNonGoldWeaponsLooted++
				if ( user.p.kindsOfNonGoldWeaponsLooted == fileLevel.countOfKindsOfNonGoldWeapons )
				{
					__SetStat_Bool( user, ResolveStatEntry( CAREER_STATS.looted_all_nongold_weapons_in_1_match ), true )
				}
			}
		}
	}
	user.p.lootRefPickupCounts[ref]++

	StatsHook_MedicCarePackage_OnPlayerLootPickup( user, lootPickup )

	if ( lootPickup.e.spawnSource == eSpawnSource.DROPPOD )
	{
		entity droppod = lootPickup.GetParent()
		if ( IsValid( droppod ) && droppod.e.sourceWeaponClassname == "" )
		{
			if ( !(user in droppod.e.stats_usersSet) )
			{
				ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( user ), Loadout_CharacterClass() )
				string characterRef  = ItemFlavor_GetGUIDString( character )

				__IncrementStat_Int( user, ResolveStatEntry( CAREER_STATS.neutral_airdrops_looted ), 1 )
				__IncrementStat_Int( user, ResolveStatEntry( CAREER_STATS.character_neutral_airdrops_looted, characterRef ), 1 )
			}
			droppod.e.stats_usersSet[user] <- true
		}
	}

	LootData data = SURVIVAL_Loot_GetLootDataByRef( ref )
	if ( data.lootType == eLootType.MAINWEAPON )
	{
		array<entity> weapons = GetWeaponArray( false )
		int fullyKittedCount  = 0
		foreach ( weapon in weapons )
		{
			LootData wData = SURVIVAL_GetLootDataFromWeapon( weapon )
			if ( SURVIVAL_Weapon_IsFullyKitted( wData.ref ) )
				fullyKittedCount++
		}
		if ( fullyKittedCount >= 2 )
			__IncrementStat_Int( user, ResolveStatEntry( CAREER_STATS.times_fully_kitted ), 1 )
	}
}
void function StatsHook_PlayerEquip( entity player )
{
	PIN_PlayerEquip( player )
}
void function StatsHook_PlayerUsedResource( entity player, entity itemEnt, string itemRef )
{
	PIN_PlayerUse( player, itemRef )

	if ( SURVIVAL_NumItemsInInventory( player, itemRef ) == 0 )
		PIN_PlayerOutResource( player, itemRef )
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class-specific events ///////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if SERVER

// Bloodhound
void function StatsHook_AreaSonarScan_EnemyDetected( entity player, entity ent )
{
	if ( !ShouldGatherStats( player ) )
		return

	if ( ent.IsPlayer() )
	{
		Assert( IsEnemyTeam( player.GetTeam(), ent.GetTeam() ) )
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.bloodhound_tactical_enemies_detected ), 1 )
	}
	else
	{
		__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.bloodhound_tactical_traps_detected ), 1 )
	}
}

void function StatsHook_HuntMode_OnKill( entity killer )
{
	// called from OnPlayerKilled in this file

	if ( StatusEffect_GetSeverity( killer, eStatusEffect.hunt_mode ) > 0.0 )
		__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.bloodhound_ultimate_kills_while_active ), 1 )
}
//void function StatsHook_TrackingVision_OnPOIDetected( entity player )
//{
//	if ( !ShouldGatherStats( player ) )
//		return
//
//	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.bloodhound_passive_clues_discovered ), 1 )
//}

// Caustic
void function StatsHook_DirtyBomb_OnDetonate( entity owner, entity attacker )
{
	if ( !ShouldGatherStats( owner ) )
		return

	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.caustic_tactical_barrels_traps_detonated ), 1 )
}
void function StatsHook_GasDamage_OnPlayerTookDamage( entity attacker, int damageSourceId, int damageAmount )
{
	// called from StatsHook_OnPlayerOrNPCTookDamage above

	if ( damageSourceId == eDamageSourceId.damagedef_grenade_gas || damageSourceId == eDamageSourceId.damagedef_gas_exposure )
		__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.caustic_gas_damage_dealt ), damageAmount )
}
void function StatsHook_GasTraps_OnKill( entity killer, entity victim, ItemFlavor killerCharacter )
{
	// called from OnPlayerKilled in this file

	if ( StatusEffect_GetSeverity( victim, eStatusEffect.gas_cloud ) > 0.0
			&& killerCharacter == GetItemFlavorByAsset( $"settings/itemflav/character/caustic.rpak" ) )
		__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.caustic_passive_enemies_in_gas_killed ), 1 ) // todo(dw)
}

// Gibraltar
void function StatsHook_BubbleShield_OnDamageAbsorbed( entity owner, var damageInfo )
{
	if ( !ShouldGatherStats( owner ) )
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) || !attacker.IsPlayer() || !IsEnemyTeam( owner.GetTeam(), attacker.GetTeam() ) )
		return

	// todo(dw): find out if there's a particular kind of damage that shouldn't be counted
	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.gibraltar_tactical_bubble_enemy_damage_absorbed ), int(DamageInfo_GetDamage( damageInfo )) )
}
void function StatsHook_DefensiveBombardment_OnKill( entity killer, int damageSourceId )
{
	// called from OnPlayerKilled in this file

	if ( damageSourceId == eDamageSourceId.damagedef_defensive_bombardment )
		__IncrementStat_Int( killer, ResolveStatEntry( CAREER_STATS.gibraltar_ultimate_bombardment_kills ), 1 )
}
void function StatsHook_GibraltarGunShield_OnDamageAbsorbed( entity owner, entity attacker, int damageAmount )
{
	if ( !ShouldGatherStats( owner ) )
		return

	Assert( IsValid( attacker ) && attacker.IsPlayer() && IsEnemyTeam( owner.GetTeam(), attacker.GetTeam() ) )

	// todo(dw): find out if there's a particular kind of damage that shouldn't be counted
	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.gibraltar_passive_gunshield_enemy_damage_absorbed ), damageAmount )
}

// Lifeline
void function StatsHook_MedicDeployableDrone_OnEntityHealResourceFinished( entity receiver, int healAmount, string refName, entity provider )
{
	Assert( IsValid( receiver ) )
	if ( refName != "mp_weapon_deployable_medic" || !receiver.IsPlayer() || !IsValid( provider ) || !provider.IsPlayer() )
		return

	if ( !ShouldGatherStats( provider ) )
		return

	__IncrementStat_Int( provider, ResolveStatEntry( CAREER_STATS.lifeline_tactical_drone_healing_given ), healAmount )
}
void function StatsHook_MedicCarePackage_OnPlayerLootPickup( entity user, entity lootPickup )
{
	// called from OnPlayerLootPickup above

	if ( lootPickup.e.spawnSource != eSpawnSource.DROPPOD )
		return

	entity droppod = lootPickup.GetParent()
	if ( !IsValid( droppod ) || droppod.e.sourceWeaponClassname != "mp_ability_care_package" )
		return

	entity owner = droppod.GetOwner()
	if ( !IsValid( owner ) )
		return
	Assert( owner.IsPlayer() )
	if ( owner == user || !IsFriendlyTeam( owner.GetTeam(), user.GetTeam() ) )
		return

	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.lifeline_ultimate_droppod_items_grabbed_by_allies ), 1 )
}
void function StatsHook_MedicCover_OnDamageAbsorbed( entity owner, var damageInfo )
{
	if ( !ShouldGatherStats( owner ) )
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) || !attacker.IsPlayer() || !IsEnemyTeam( owner.GetTeam(), attacker.GetTeam() ) )
		return

	// todo(dw): find out if there's a particular kind of damage that shouldn't be counted
	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.lifeline_passive_enemy_damage_absorbed ), int(DamageInfo_GetDamage( damageInfo )) )
}

// Mirage
void function StatsHook_HoloPiliot_OnDecoyCreated( entity owner )
{
	if ( !ShouldGatherStats( owner ) )
		return

	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.mirage_decoys_created ), 1 )
}
void function StatsHook_HoloPiliot_OnDecoyDamaged( entity decoy, entity owner, entity attacker, var damageInfo )
{
	if ( !ShouldGatherStats( owner ) )
		return

	if ( attacker in decoy.e.stats_usersSet )
		return
	decoy.e.stats_usersSet[attacker] <- true

	// if a decoy is damaged, count it as a bamboozle
	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.mirage_successful_bamboozles ), 1 )
}
// mirage_passive_distance_travelled_while_downed

// Pathfinder
void function StatsHook_Grapple_OnAttach( entity player )
{
	thread StatsHook_Grapple_Think( player )
}
void function StatsHook_Grapple_Think( entity player )
{
	EndSignal( player, "OnDestroy" )
	EndSignal( player, "OnDeath" )
	//EndSignal( player, "OnGrappleDetach" )

	const float MAX_GRAPPLE_AIR_TIME_TO_COUNT = 5.0

	float totalDistance = 0.0
	vector prevPos      = player.GetOrigin()
	bool wasGrappling   = true
	float forcedEndTime = 0.0
	while ( wasGrappling || Time() < forcedEndTime )
	{
		if ( player.IsOnGround() && !wasGrappling )
			break // todo(dw): if you grapple onto a zipline, it counts as grapple distance but shouldn't

		vector pos = player.GetOrigin()
		totalDistance += Distance( prevPos, pos )
		prevPos = pos

		bool isGrappling = player.IsGrappleActive()
		if ( wasGrappling && !isGrappling )
			forcedEndTime = Time() + MAX_GRAPPLE_AIR_TIME_TO_COUNT
		wasGrappling = isGrappling

		WaitFrame()
	}

	__IncrementStat_Float( player, ResolveStatEntry( CAREER_STATS.pathfinder_tactical_meters_moved_by_grapple ), totalDistance )
}
void function StatsHook_PlacedZipline_OnUsed( entity zipline, entity owner, entity user )
{
	if ( owner == user || !IsFriendlyTeam( owner.GetTeam(), user.GetTeam() ) )
		return // only count friendly uses

	if ( user in zipline.e.stats_usersSet )
		return // only count the first use by each ally for each zipline
	zipline.e.stats_usersSet[user] <- true

	__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.pathfinder_ultimate_ziplines_used_by_allies ), 1 )
}
void function StatsHook_SurveyBeacon_OnSurveySuccess( entity player )
{
	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.pathfinder_passive_beacons_scanned ), 1 )
}

// Wraith
//StatTemplate& wraith_tactical_phase_walk_distance_traveled
void function StatsHook_PassiveVoices_VoiceHeard( entity player )
{
	if ( !ShouldGatherStats( player ) )
		return

	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.wraith_passive_voices_heard ), 1 )
}

void function StatsHook_PhaseTunnel_EntTraversed( entity ent, entity tunnelEnt, bool entHasUsedTunnelBefore )
{
	if ( entHasUsedTunnelBefore )
		return

	if ( !ent.IsPlayer() )
		return

	entity owner = tunnelEnt.GetOwner()
	if ( !IsValid( owner ) || !owner.IsPlayer() )
		return

	if ( !ShouldGatherStats( owner ) )
		return

	if ( ent != owner && ent.GetTeam() == owner.GetTeam() )
		__IncrementStat_Int( owner, ResolveStatEntry( CAREER_STATS.wraith_ultimate_phase_tunnel_ally_uses ), 1 )
}

void function StatsHook_Tactical_TimeSpentInPhase( entity player, float duration )
{
	if ( !ShouldGatherStats( player ) )
		return

	__IncrementStat_Float( player, ResolveStatEntry( CAREER_STATS.wraith_tactical_time_spent_in_phase ), duration )
}

//Bangalore
void function StatsHook_TrackAdrenalineDistance( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDestroy" )

	if ( !ShouldGatherStats( player ) )
		return

	int startDistance = player.GetPlayerStateStats()["d_pilot"]

	while( StatusEffect_GetSeverity( player, eStatusEffect.speed_boost ) > 0 )
	{
		wait 1.0
	}

	int endDistance = player.GetPlayerStateStats()["d_pilot"]
	float distance  = (endDistance - startDistance) / 12.0
	distance *= 0.3048 //Convert to meters
	int newDistance = int( distance )

	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.bangalore_passive_distance ), newDistance )
}

//Smoke hits is in postdamage callbacks because its using the shared inflictor technique to prevent double hits.
void function StatsHook_SmokeHits_OnPlayerTookDamage( entity attacker, int damageSourceId )
{
	if ( damageSourceId == eDamageSourceId.damagedef_bangalore_smoke_explosion )
	{
		__IncrementStat_Int( attacker, ResolveStatEntry( CAREER_STATS.bangalore_tactical_smoke_hits ), 1 )
	}
}

void function StatsHook_CreepingBarrageDamage( entity player, int damageDone )
{
	__IncrementStat_Int( player, ResolveStatEntry( CAREER_STATS.bangalore_ultimate_damage_done ), damageDone )
}
#endif

/////////////////////////////////////////////
/////////////////////////////////////////////
//// Calculated stat functions callbacks ////
/////////////////////////////////////////////
/////////////////////////////////////////////
#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetAccountLevelForStat( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		int xpProgress   = GetPlayerAccountXPProgress( ToEHI( player ) )
		int accountLevel = GetAccountLevelForXP( xpProgress )
		return minint( accountLevel, 100 )
	})

	return info
}
#endif


#if SERVER || CLIENT || UI
StatCalcFuncInfo function SetupCharacterWeaponCategoryStatSumEntryFunc_Int( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatTemplate sourceTemplate = sourceTemplates[0]

	StatCalcFuncInfo info

	string calcCharacter      = calcEntry.enumKeys[0]
	string calcWeaponCategory = calcEntry.enumKeys[1]

	foreach( string weaponItemRefInCategory, bool unused in fileLevel.weaponStatCategoryWeaponItemRefSet[calcWeaponCategory] )
	{
		info.sourceEntries.append( ResolveStatEntry( sourceTemplate, calcCharacter, weaponItemRefInCategory ) )
	}

	info.calcFunc_Int = CalcStatSum_Int

	return info
}
#endif


#if SERVER || CLIENT || UI
int function CalcStatSum_Int( entity player, array<StatEntry> sourceEntries, bool atStart )
{
	int sum = 0
	foreach( StatEntry sourceEntry in sourceEntries )
		sum += GetStat_Int( player, sourceEntry, atStart )
	return sum
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetTotalLegendaryItems( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		if ( !GRX_IsInventoryReady( player ) )
			return -1

		int count = 0
		foreach ( ItemFlavor flav in GetAllItemFlavors() )
		{
			if ( ItemFlavor_GetGRXMode( flav ) != eItemFlavorGRXMode.REGULAR )
				continue

			if ( !ItemFlavor_HasQuality( flav ) || ItemFlavor_GetQuality( flav ) < eQuality.LEGENDARY )
				continue

			if ( GRX_IsItemOwnedByPlayer_AllowOutOfDateData( flav, player ) )
				count++
		}

		return count
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetNumCharactersWithBannersOnceFilled( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		int count = 0

		foreach( ItemFlavor character in GetAllCharacters() )
		{
			if ( GetStat_Bool( player, ResolveStatEntry( CAREER_STATS.character_banner_once_filled, ItemFlavor_GetGUIDString( character ) ), atStart ) )
				count++
		}
		return count
	})

	return info
}
#if SERVER
void function SetupTotalCompleteBannersCalcedStat()
{
	foreach ( ItemFlavor character in GetAllCharacters() )
	{
		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_GladiatorCardFrame( character ), void function( entity player, ItemFlavor unused ) : ( character ) {
			OnPlayerModifiedBannerSlot( player, character )
		} )
		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_GladiatorCardStance( character ), void function( entity player, ItemFlavor unused ) : ( character ) {
			OnPlayerModifiedBannerSlot( player, character )
		} )

		for ( int iterBadgeIndex = 0; iterBadgeIndex < GLADIATOR_CARDS_NUM_BADGES; iterBadgeIndex++ )
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_GladiatorCardBadge( character, iterBadgeIndex ), void function( entity player, ItemFlavor unused ) : ( character ) {
				OnPlayerModifiedBannerSlot( player, character )
			} )

		for ( int iterTrackerIndex = 0; iterTrackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; iterTrackerIndex++ )
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_GladiatorCardStatTracker( character, iterTrackerIndex ), void function( entity player, ItemFlavor unused ) : ( character ) {
				OnPlayerModifiedBannerSlot( player, character )
			} )
	}
}
void function OnPlayerModifiedBannerSlot( entity player, ItemFlavor character )
{
	if ( GetEHIScriptStruct( player ).HACK_wasJustValidated )
		return // only update stat when they actually change their selection

	array<LoadoutEntry> slots = [
		Loadout_GladiatorCardFrame( character ),
		Loadout_GladiatorCardStance( character ),
	]

	for ( int iterBadgeIndex = 1; iterBadgeIndex < GLADIATOR_CARDS_NUM_BADGES; iterBadgeIndex++ )
		slots.append( Loadout_GladiatorCardBadge( character, iterBadgeIndex ) )

	for ( int iterTrackerIndex = 1; iterTrackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; iterTrackerIndex++ )
		slots.append( Loadout_GladiatorCardStatTracker( character, iterTrackerIndex ) )

	bool allSlotsFilled = true
	foreach ( LoadoutEntry entry in slots )
	{
		if ( !LoadoutSlot_IsReady( ToEHI( player ), entry ) )
			return // todo(dw): not sure if this is really needed

		if ( LoadoutSlot_GetItemFlavor( ToEHI( player ), entry ) == GetDefaultItemFlavorForLoadoutSlot( ToEHI( player ), entry ) )
		{
			allSlotsFilled = false
			break
		}
	}
	if ( allSlotsFilled )
		__SetStat_Bool( player, ResolveStatEntry( CAREER_STATS.character_banner_once_filled, ItemFlavor_GetGUIDString( character ) ), true )

	UpdateCalculatedStatCachedValue( player, ResolveStatEntry( CAREER_STATS.num_characters_with_banners_once_filled ) )
}
#endif
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetStarterPackStatus( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart )
	{
		return PlayerHasStarterPack( player ) ? 1 : 0
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetFounderPackStatus( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart )
	{
		return PlayerHasFoundersPack( player ) ? 1 : 0
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetTwitchPackStatus( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		#if SERVER
			return player.HasTwitchPrimeRewards() ? 1 : 0
		#endif
		#if UI
			return GetConVarInt( "twitch_prime_linked " ) > 0 ? 1 : 0
		#endif
		#if CLIENT
			return GetConVarInt( "twitch_prime_linked " ) > 0 ? 1 : 0
		#endif
	})

	return info
}
#endif


#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetEAAccessStatus( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		#if SERVER
			return IsEAAccessMember( player ) ? 1 : 0
		#endif
		#if UI
			return Script_UserHasEAAccess() ? 1 : 0
		#endif
		#if CLIENT
			return 1 // todo(dw)
		#endif
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetCountOfCharactersWithLegendarySkinAndExecution( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		if ( !GRX_IsInventoryReady( player ) )
			return -1

		int count = 0
		foreach( ItemFlavor character in GetAllCharacters() )
		{
			bool hasLegendarySkin     = false
			bool hasLegendaryFinisher = false

			array<ItemFlavor> characterSkins = GetValidItemFlavorsForLoadoutSlot( ToEHI( player ), Loadout_CharacterSkin( character ) )
			foreach ( skin in characterSkins )
			{
				if ( GRX_IsItemOwnedByPlayer_AllowOutOfDateData( skin, player ) && ItemFlavor_HasQuality( skin ) && ItemFlavor_GetQuality( skin ) >= eQuality.LEGENDARY )
				{
					hasLegendarySkin = true
					break
				}
			}

			array<ItemFlavor> executions = GetValidItemFlavorsForLoadoutSlot( ToEHI( player ), Loadout_CharacterExecution( character ) )
			foreach ( execution in executions )
			{
				if ( GRX_IsItemOwnedByPlayer_AllowOutOfDateData( execution, player ) && ItemFlavor_HasQuality( execution ) && ItemFlavor_GetQuality( execution ) >= eQuality.LEGENDARY )
				{
					hasLegendaryFinisher = true
					break
				}
			}

			if ( hasLegendarySkin && hasLegendaryFinisher )
				count++
		}

		return count
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetCountOfWeaponsWithLegendarySkins( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		if ( !GRX_IsInventoryReady( player ) )
			return -1

		int count = 0
		foreach( ItemFlavor weapon in GetAllWeaponItemFlavors() )
		{
			array<ItemFlavor> weaponSkins = GetValidItemFlavorsForLoadoutSlot( ToEHI( player ), Loadout_WeaponSkin( weapon ) )
			foreach ( skin in weaponSkins )
			{
				if ( GRX_IsItemOwnedByPlayer_AllowOutOfDateData( skin, player ) && ItemFlavor_HasQuality( skin ) && ItemFlavor_GetQuality( skin ) >= eQuality.LEGENDARY )
				{
					count++
					break
				}
			}
		}
		return count
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetCountOfCharactersWithWellRoundedDamage( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		int count = 0
		foreach( char in GetAllCharacters() )
		{
			string characterRef = ItemFlavor_GetGUIDString( char )
			int damageDone      = GetStat_Int( player, ResolveStatEntry( CAREER_STATS.character_damage_done, characterRef ), atStart )
			if ( damageDone > 20000 )
				count++
		}
		return count
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetTreasureHunterStatus( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		//TODO Times Looted Status
		return 0
	})

	return info
}
#endif

#if SERVER || CLIENT || UI
StatCalcFuncInfo function GetCountOfCharactersWithTenWins( StatEntry calcEntry, array<StatTemplate> sourceTemplates )
{
	StatCalcFuncInfo info

	info.calcFunc_Int = (int function ( entity player, array<StatEntry> sourceEntries, bool atStart ) {
		int count = 0
		foreach( ItemFlavor character in GetAllCharacters() )
		{
			if ( GetStat_Int( player, ResolveStatEntry( CAREER_STATS.character_placements_win, ItemFlavor_GetGUIDString( character ) ), atStart ) >= 10 )
				count++
		}

		return count
	})

	return info
}
#endif


