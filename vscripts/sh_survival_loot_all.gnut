global function SURVIVAL_Loot_All_InitShared

global function SURVIVAL_Loot_GetLootDataTable
global function SURVIVAL_Loot_GetLootDataByIndex
global function SURVIVAL_Loot_IsLootIndexValid
global function SURVIVAL_Loot_GetLootDataByRef
global function SURVIVAL_Loot_IsRefValid
global function SURVIVAL_Loot_IsRefDisabled
global function SURVIVAL_Loot_GetByType
global function SURVIVAL_Loot_GetLootTypeFromString
global function SURVIVAL_Loot_GetByTier

global function SURVIVAL_Loot_IsUniqueAmmoWeapon
global function GetCustomHopupArray

#if CLIENT
global function GetRarityColor
#endif

#if CLIENT && DEVELOPER
global function DumpModdedKeyColors
global function DiffKeyColors
#endif

global function GetFXRarityColorForTier // use this for in game loot
global function GetFXRarityColorForUnlockable
global function IsCustomAttachment
global function IsCustomWeapon

global enum eLootTier
{
	NONE
	COMMON
	RARE
	EPIC
	LEGENDARY
	HEIRLOOM

	_count
}

global struct CustomHopupData
{
	string className,
	string displayName,
	string desc,
	int tier,
	asset icon,
	asset model = $"mdl/weapons_r5/loot/_master/w_loot_wep_mods_chip.rmdl",
	string attachmentSlot = "hopup",
	float lowWeight = 5.0,
	float medWeight = 10.0,
	float highWeight = 25.0
}

global struct LootData
{
	string ref
	int tier
	int index = -1
	int inventorySlotCount
	int pingCommsAction
	asset model
	int skinOverride
	asset hudIcon
	asset emptyImage
	string attachSound
	string pickupSound_1p
	string pickupSound_3p
	string carrySound
	string pickupString
	string desc
	string specialCaseInvalidReason
	int countPerDrop
	int lootType
	string netInt
	array<string> supportedAttachments
	array<string> lootTags
	string        ammoType
	float         minInWorld
	bool          isActive = false
	int           passive = -1
	string        attachmentStyle = ""
	int           scrapValue
	bool          droppodRotate = false
	bool          isDynamic = false
	bool          conditional = false

	string baseWeapon
	array<string> baseMods

	asset fakeAmmoIcon
	array<string> fakeMods
}

global enum eLootType
{
	MAINWEAPON
	AMMO
	HEALTH
	ARMOR
	INCAPSHIELD
	JUMPKIT
	ORDNANCE
	ATTACHMENT
	CUSTOMPICKUP
	BACKPACK
	HELMET
	BLANK
	#if(true)
		DATAKNIFE
	#endif
	RESOURCE

	_count
}

global const int HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND = 3

#if(false)




#endif

#if(false)

#endif


#if(true)
global struct OverrideDeathBoxRUI_NetworkOptimizedStruct
{
	string name
	string hardware
	string playerID
	int    characterIndex
	int    skinIndex
	int    frameIndex
	int    stanceIndex
	int    firstBadgeIndex
	int    firstBadgeDataInt
	int    secondBadgeIndex
	int    secondBadgeDataInt
	int    thirdBadgeIndex
	int    thirdBadgeDataInt

	bool isValid = false
}
#endif


struct
{
	table< string, LootData > lootData
	array<string>             lootIndexToString
	bool                      initialized
	array<string>             disabledRefs
	array<string>             uniqueAmmoWeaponRefs
	array<CustomHopupData>	  customHopups = []

	#if(true)
		table<EHI, array< OverrideDeathBoxRUI_NetworkOptimizedStruct > > EHIToOverrideDeathBoxRUIProfilesTable
		table<string, EHI>                                               corpseToEHITable
		array< OverrideDeathBoxRUI_NetworkOptimizedStruct >              handcraftedProfiles
		array< OverrideDeathBoxRUI_NetworkOptimizedStruct >              handcraftedProfilesMasterList //
	#endif

	#if(UI)
		bool                                                      overrideDeathBoxRUI_Initialized = false
		table<string, OverrideDeathBoxRUI_NetworkOptimizedStruct> overrideDeathBoxRUIProfilesTable
		int                                                       profilesSent = 0
	#endif
} file


struct CustomGrenadeData
{
	string className,
	int countPerDrop,
	int stackSize,
	int tier,
	float chance,
	float carePackageChance
}

array<string> attachmentSortOrder = ["barrel", "mag", "sight", "grip", "hopup"]

array<CustomHopupData> function GetCustomHopupArray()
{
	return file.customHopups
} 

string function GetLootTableString( string ref, var datatable, int rowIndex, string columnName )
{
	string val = GetDataTableString( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarString( (ref + "_dt_override_" + columnName), val )
}


asset function GetLootTableAsset( string ref, var datatable, int rowIndex, string columnName )
{
	return GetDataTableAsset( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
}


int function GetLootTableInt( string ref, var datatable, int rowIndex, string columnName )
{
	int val = GetDataTableInt( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarInt( (ref + "_dt_override_" + columnName), val )
}


bool function GetLootTableBool( string ref, var datatable, int rowIndex, string columnName )
{
	bool val = GetDataTableBool( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarBool( (ref + "_dt_override_" + columnName), val )
}


float function GetLootTableFloat( string ref, var datatable, int rowIndex, string columnName )
{
	float val = GetDataTableFloat( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarFloat( (ref + "_dt_override_" + columnName), val )
}

	// Need these here so they get included in bulids

void function SURVIVAL_Loot_All_InitShared()
{
	#if(!UI)
		//
	#endif
	var dt = GetDataTable( $"datatable/survival_loot.rpak" )
	file.lootIndexToString.clear()
	file.lootData.clear()

	var attachmentTable = GetDataTable( $"datatable/survival_weapon_mods.rpak" )

	file.disabledRefs.clear()
	string disabledRefs = GetCurrentPlaylistVarString( "survival_disabled_loot", " " )
	file.disabledRefs = split( disabledRefs, " " )

	array<string> icons = []
	int numRows = GetDatatableRowCount( dt )
	for ( int i = 0; i < numRows; i++ )
	{
		LootData data
		data.ref = GetDataTableString( dt, i, GetDataTableColumnByName( dt, "ref" ) )
		string featureFlagRef = GetLootTableString( data.ref, dt, i, "featureFlag" )
		if ( featureFlagRef != "" && !GetFeatureFlagByString( featureFlagRef ) )
		{
			printf( "Skipping loot ref %s because feature flag %s is off.", data.ref, featureFlagRef )
			printf( "Loot ref %s: feature flag %s is off", data.ref, featureFlagRef )
			continue
		}

		string pingCommsActionName = GetLootTableString( data.ref, dt, i, "pingCommsAction" )

		#if SERVER || CLIENT
		data.pingCommsAction = GetCommsActionForName( pingCommsActionName )
		#endif

		string lootType = GetLootTableString( data.ref, dt, i, "type" )

		data.baseWeapon = GetLootTableString( data.ref, dt, i, "baseWeapon" )

		if ( data.baseWeapon == "" )
		{
			data.baseWeapon = data.ref
		}

		data.fakeAmmoIcon = GetLootTableAsset( data.ref, dt, i, "fakeAmmoIcon" )
		if (data.fakeAmmoIcon != "") printt("Fake ammo icon for", data.ref, "-", data.fakeAmmoIcon)

		data.baseMods = split( GetLootTableString( data.ref, dt, i, "baseMods" ), " " )

		data.model = GetLootTableAsset( data.ref, dt, i, "pickupModel" )
		data.skinOverride = GetLootTableInt( data.ref, dt, i, "skinOverride" )
		data.hudIcon = GetLootTableAsset( data.ref, dt, i, "icon" )
		data.attachSound = GetLootTableString( data.ref, dt, i, "attachSound" )
		data.pickupSound_3p = GetLootTableString( data.ref, dt, i, "pickupSound_3p" )
		data.pickupSound_1p = GetLootTableString( data.ref, dt, i, "pickupSound_1p" )
		data.carrySound = GetLootTableString( data.ref, dt, i, "carrySound" )
		data.scrapValue = GetLootTableInt( data.ref, dt, i, "scrapValue" )
		data.droppodRotate = GetLootTableBool( data.ref, dt, i, "droppodRotate" )
		data.isDynamic = GetLootTableBool( data.ref, dt, i, "isDynamic" )
		data.conditional = GetLootTableBool( data.ref, dt, i, "conditional" )

		data.pickupString = GetLootTableString( data.ref, dt, i, "pickupString" )
		data.desc = GetLootTableString( data.ref, dt, i, "desc" )

		data.countPerDrop = GetLootTableInt( data.ref, dt, i, "countPerDrop" )
		data.tier = GetLootTableInt( data.ref, dt, i, "tier" )

		string supportedAttachmentsString  = GetLootTableString( data.ref, dt, i, "supportedAttachments" )
		array<string> supportedAttachments = split( supportedAttachmentsString, " " )
		supportedAttachments.sort(
			int function( string attachmentA, string attachmentB ) : ()
			{
				int aIndex = attachmentSortOrder.find( attachmentA )
				int bIndex = attachmentSortOrder.find( attachmentB )
				if ( aIndex > bIndex )
					return 1
				else if ( aIndex < bIndex )
					return -1

				return 0
			}
		)
		data.supportedAttachments = supportedAttachments

		printt(data.ref, "| model:", string(GetLootTableAsset( data.ref, dt, i, "pickupModel" )))
		data.lootTags = split( GetLootTableString( data.ref, dt, i, "lootTags" ), " " )

		data.lootType = SURVIVAL_Loot_GetLootTypeFromString( lootType )
		data.netInt = GetLootTableString( data.ref, dt, i, "netInt" )
		data.inventorySlotCount = GetLootTableInt( data.ref, dt, i, "inventorySlotCount" )

		#if SERVER || CLIENT
		data.minInWorld = GetLootTableFloat( data.ref, dt, i, "minInWorld" )
		if ( IsTestMap() )
			data.minInWorld = max( -1, data.minInWorld )
		//Not ideal - The minInWorld concept is unlikely the right way to do ( now ) map specific items.

		if ( data.ref == "data_knife" && GetMapName() != "mp_rr_desertlands_64k_x_64k" )
			data.minInWorld = 0.0
		#endif

		string passiveRef = GetLootTableString( data.ref, dt, i, "passive" )
		if ( passiveRef == "" )
		{
			data.passive = ePassives.INVALID
		}
		else
		{
			Assert( passiveRef in ePassives )
			data.passive = ePassives[passiveRef]
			#if CLIENT || UI
				Assert( data.passive in PASSIVE_NAME_MAP )
				Assert( data.passive in PASSIVE_DESCRIPTION_SHORT_MAP )
			#endif
		}

		switch ( data.lootType )
		{
			case eLootType.MAINWEAPON:
				RegisterWeaponForUse( data.baseWeapon )
				RegisterCustomAttachments(GetCustomHopupsForWeapon(data.baseWeapon))
				data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
				data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
				data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
				data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
				if ( GetWeaponInfoFileKeyField_Global( data.baseWeapon, "ammo_pool_type" ) != null )
					data.ammoType = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "ammo_pool_type" )
				else
					data.ammoType = ""

				if ( data.fakeAmmoIcon != "" )
				{
					file.uniqueAmmoWeaponRefs.append( data.ref )
				}

				ItemFlavor ornull weaponFlavor = GetWeaponItemFlavorByClass( data.baseWeapon )
				if ( weaponFlavor != null )
				{
					expect ItemFlavor( weaponFlavor )

					int availableState = ItemFlavor_GetPlaylistOpinion( weaponFlavor )
					bool shouldBeEnabled
					if ( availableState == eItemFlavorPlaylistOpinion.FORCE_UNLOCK_FOR_SPECIAL_EVENT )
						shouldBeEnabled = true
					else if ( availableState == eItemFlavorPlaylistOpinion.HIDDEN )
						shouldBeEnabled = false
					else if ( availableState == eItemFlavorPlaylistOpinion.DISABLED )
						shouldBeEnabled = false
					else
						shouldBeEnabled = ItemFlavor_IsActiveForEdition( weaponFlavor, GetConVarInt( "mtx_svEdition" ) )

					if ( !shouldBeEnabled )
						file.disabledRefs.append( data.ref )
				}
				break

			case eLootType.ORDNANCE:
				RegisterWeaponForUse( data.baseWeapon )
				data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
				data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
				data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
				break

			case eLootType.AMMO:
				data.countPerDrop = int( GetCurrentPlaylistVarFloat( "loot_ammo_scale_per_drop", 1.0 ) * float( data.countPerDrop ) )
				data.inventorySlotCount = int( GetCurrentPlaylistVarFloat( "inventory_ammo_scale_stacksize", 1.0 ) * float( data.inventorySlotCount ) )
				break

			case eLootType.ATTACHMENT:
				int row = GetDataTableRowMatchingStringValue( attachmentTable, GetDataTableColumnByName( attachmentTable, "mod" ), data.ref )
				data.pickupString = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "name" ) )
				data.desc = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "description" ) )

				data.ammoType = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "ammoType" ) )
				data.hudIcon = GetLootTableAsset( data.ref, dt, i, "icon" )
				data.specialCaseInvalidReason = ""//
				if ( data.hudIcon == $"" )
					data.hudIcon = GetDataTableAsset( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "image" ) )

				string attachmentPoint = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "attachmentPoint" ) )
				data.attachmentStyle = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "type" ) )
				data.emptyImage = GetDataTableAsset( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "emptyImage" ) )

				#if SERVER || CLIENT
				RegisterAttachmentPoint( attachmentPoint )
				#endif
				break
		}

		{
			data.index = file.lootIndexToString.len()
			file.lootIndexToString.append( data.ref )
			file.lootData[ data.ref ] <- data

			#if SERVER
				SURVIVAL_AddSpawnPointGroup( data.ref )
			#endif
		}

		#if !UI
			if ( data.model != $"" )
				PrecacheModel( data.model )
		#endif
	}

	foreach(string icon in icons)
	{

	}
	RegisterCustomWeapons()

	#if(UI)
		RegisterSignal( "GatherFriendInfo" )
		RegisterSignal( "GatheredEnoughFriendInfo" )
		SURVIVAL_UIInit_Override_DeathBox_RUI()
	#endif

	file.initialized = true
}

struct CustomWeaponData
{
	string className,
	int tier,
	array<string> baseMods,
	array<string> supportedAttachments,
	string pickupSound1p,
	string pickupSound3p,
	string weaponType,
	float lowWeaponChance,
	float medWeaponChance,
	float highWeaponChance,
	bool isCP
}

void function RegisterCustomWeapons()
{
	array<string> customWeaponClassNames = split(GetCurrentPlaylistVarString("custom_weapon_list", ""), " ")
	foreach (string className in customWeaponClassNames)
	{
		CustomWeaponData data
		// Class name - the file name of the weapon, excluding extension
		data.className = className
		// Tier - the displayed rarity of the weapon
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		// equip these mods on pickup.
		data.baseMods = split(GetCurrentPlaylistVarString(className + "_base_mods", ""), " ")
		// what attachments does the weapon support
		data.supportedAttachments = split(GetCurrentPlaylistVarString(className + "_attachments", "barrel mag sight grip"), " ")
		// pickup sounds
		data.pickupSound1p = GetCurrentPlaylistVarString(className + "_pickup_sound_1p", "survival_loot_pickup_weapon_rspn101")
		data.pickupSound3p = GetCurrentPlaylistVarString(className + "_pickup_sound_3p", "survival_loot_pickup_3p_weapon_rspn101")
		// weapon type - used for attachments.
		// weaponTypes: assault, smg, lmg, sniper, shotgun, pistol
		data.weaponType = GetCurrentPlaylistVarString(className + "_class", "assault")
		// weights for weapon to appear on ground.
		// the game sets the chances to a sum of 100 normally.
		// the actual chance is dependent on all other weapons.
		data.lowWeaponChance = GetCurrentPlaylistVarFloat(className + "_low_chance", 5.0)
		data.medWeaponChance = GetCurrentPlaylistVarFloat(className + "_med_chance", 10.0)
		data.highWeaponChance = GetCurrentPlaylistVarFloat(className + "_high_chance", 25.0)

		data.isCP = GetCurrentPlaylistVarBool(className + "_cp_weapon", false)
		RegisterWeapon(data)
		RegisterCustomAttachments(GetCustomHopupsForWeapon(className))
	}
	
	array<string> customGrenadeClassNames = split(GetCurrentPlaylistVarString("custom_grenade_list", ""), " ")
	foreach(string className in customGrenadeClassNames)
	{
		CustomGrenadeData data
		data.className = className
		data.countPerDrop = GetCurrentPlaylistVarInt(className + "_count_per_drop", 1)
		data.stackSize = GetCurrentPlaylistVarInt(className + "_stack_size", 2)
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		data.chance = GetCurrentPlaylistVarFloat(className + "_chance", 0)
		data.carePackageChance = GetCurrentPlaylistVarFloat(className + "_cp_chance", 0)
		RegisterCustomGrenade(data)
	}

	array<string> customConsumableClassNames = split(GetCurrentPlaylistVarString("custom_consumable_list", ""), " ")
	foreach(string className in customConsumableClassNames)
	{
		printt("CLASS NAME:", className)
		CustomGrenadeData data
		data.className = className
		data.countPerDrop = GetCurrentPlaylistVarInt(className + "_count_per_drop", 1)
		data.stackSize = GetCurrentPlaylistVarInt(className + "_stack_size", 2)
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		data.chance = GetCurrentPlaylistVarFloat(className + "_chance", 0)
		data.carePackageChance = GetCurrentPlaylistVarFloat(className + "_cp_chance", 0)
		RegisterCustomConsumable(data)
	}
	
	#if SERVER
		AddClientCommandCallback( "SetNextCustomConsumable", ClientCallback_SetNextCustomConsumable )
	#endif
}

bool function IsCustomAttachment(LootData data)
{
	printt(data.ref)
	foreach (CustomHopupData d in file.customHopups)
	{
		if (d.className == data.ref) return true
	}
	return false
}

bool function IsCustomWeapon(LootData data)
{
	var weaponMatrix = GetDataTable( $"datatable/weapon_attachment_matrix.rpak" )

	int col = GetDataTableColumnByName( weaponMatrix, data.baseWeapon )

	return col == -1
}

void function RegisterCustomAttachments(array<string> refs)
{
	foreach(string className in refs){
		CustomHopupData data
		// class name - the name of the mod to be added to a weapon once this hopup is equipped.
		data.className = className
		// display name - the name displayed on pop-ups of this hop-up.
		data.displayName = GetCurrentPlaylistVarString(className + "_name", "Custom Hopup")
		// description.
		data.desc = GetCurrentPlaylistVarString(className + "_desc", "Hop up desc")
		// Tier - the displayed rarity of the hop-up
		data.tier = GetCurrentPlaylistVarInt(className + "_tier", 1)
		// icon - the icon of the hop-up. defaults to the Choke Hop-up Icon.
		#if !UI
		data.icon = CastStringToAsset(GetCurrentPlaylistVarString(className + "_icon", "rui/pilot_loadout/mods/hopup_em_choke"))
		// model - the appearance of the hop-up on the ground.
		data.model = CastStringToAsset(GetCurrentPlaylistVarString(className + "_model", "mdl/weapons_r5/loot/_master/w_loot_wep_mods_chip.rmdl"))
		#endif
		// The weight of the hop-up in Basic Tier Loot areas
		data.lowWeight = GetCurrentPlaylistVarFloat(className + "_low_chance", 5.0)
		// The weight of the hop-up in Mid Tier Loot areas
		data.medWeight = GetCurrentPlaylistVarFloat(className + "_med_chance", 10.0)
		// The weight of the hop-up in High Tier Loot areas
		data.highWeight = GetCurrentPlaylistVarFloat(className + "_high_chance", 25.0)
		// slot
		data.attachmentSlot = GetCurrentPlaylistVarString(className + "_slot", "hopup")
		// create the hopup...
		CreateCustomHopup(data)
	}
}

array<string> function GetCustomHopupsForWeapon(string className)
{
	array<string> result = []
	foreach(string mod in GetWeaponMods_Global(className))
	{
		if (SURVIVAL_Loot_IsRefValid(mod)) continue;

		if (GetCurrentPlaylistVarString(mod + "_slot", "") == "") continue;
		result.append(mod)
	}
	return result
}

void function RegisterCustomGrenade(CustomGrenadeData grenadeData) {
	LootData data
	data.ref = grenadeData.className
	data.baseWeapon = grenadeData.className
	#if !UI
	PrecacheWeapon( data.baseWeapon )
	#endif
	data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
	data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
	data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
	data.tier = grenadeData.tier
	data.countPerDrop = grenadeData.countPerDrop
	data.inventorySlotCount = grenadeData.stackSize
	data.lootType = eLootType.ORDNANCE
	data.pickupSound_1p = "survival_loot_pickup_ordanance"
	data.pickupSound_3p = "survival_loot_pickup_3p_ordanance"

	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data

	#if !UI
	AddCustomItemToLootPool( data.ref, "ordnance", grenadeData.chance)
	AddCustomItemToLootPool( data.ref, "ordnance_drops", grenadeData.carePackageChance)
	#endif
}

void function RegisterCustomConsumable(CustomGrenadeData grenadeData)
{
	LootData data
	data.ref = grenadeData.className
	data.baseWeapon = grenadeData.className
	#if !UI
		PrecacheWeapon( data.baseWeapon )
	#endif
	data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
	data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
	// this is so playermodel can still be empty handed if we choose so.
	data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "pickupmodel" )
	data.tier = grenadeData.tier
	data.countPerDrop = grenadeData.countPerDrop
	data.inventorySlotCount = grenadeData.stackSize
	data.lootType = eLootType.CUSTOMPICKUP
	data.pickupSound_1p = "survival_loot_pickup_ordanance"
	data.pickupSound_3p = "survival_loot_pickup_3p_ordanance"

	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data
	#if CLIENT
		RegisterUseFunctionForItem( data.ref, FireCustomConsumable )
	#endif

	#if !UI
	AddCustomItemToLootPool( data.ref, "ordnance", grenadeData.chance)
	AddCustomItemToLootPool( data.ref, "ordnance_drops", grenadeData.carePackageChance)
	#endif
}

#if CLIENT
void function FireCustomConsumable(entity player, string ref)
{
	player.ClientCommand( "SetNextCustomConsumable " + ref )
	ActivateOffhandWeaponByIndex(OFFHAND_EQUIPMENT)
}
#endif

#if SERVER
bool function ClientCallback_SetNextCustomConsumable( entity player, array<string> args )
{
	if (!SURVIVAL_Loot_IsRefValid(args[0])) return true
	if (SURVIVAL_CountItemsInInventory(player, args[0]) <= 0) return true

	printt("setting next consumable: ", args[0])
	
	if (IsValid(player.GetOffhandWeapon(OFFHAND_EQUIPMENT)) && player.GetOffhandWeapon(OFFHAND_EQUIPMENT).GetWeaponClassName() != args[0])
	{
		player.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
		player.GiveOffhandWeapon( args[0], OFFHAND_EQUIPMENT )
	}
	else if (!IsValid(player.GetOffhandWeapon(OFFHAND_EQUIPMENT))) 
	{
		player.GiveOffhandWeapon( args[0], OFFHAND_EQUIPMENT )
	}
	return true
}
#endif

void function RegisterWeapon( CustomWeaponData weaponData )
{
	LootData data
	
	data.ref = weaponData.className
	// have no idea why we do this, but it's needed.
	data.baseWeapon = weaponData.className

	// We don't use this as custom weapons don't have an eDamageSourceId.
	// This means that kills with the weapon will show up as
	// Attacker [Killed] Victim.
	// This would be nice if changed, but it's good as is for now,
	// as the game is not fully functioning yet.
	//RegisterWeaponForUse( data.baseWeapon )

	// precache the weapon, obviously.
	#if !UI
		PrecacheWeapon(weaponData.className)
		//RegisterCustomWeaponDamageSource(weaponData.className)
	#endif
	// rarity
	data.tier = weaponData.tier
	// Copy pasted from SURVIVAL_Loot_All_InitShared
	data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
	data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
	data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
	data.countPerDrop = 1

	// Pickup sounds. 
	data.pickupSound_3p = weaponData.pickupSound3p
	data.pickupSound_1p = weaponData.pickupSound1p
	// Ammo type - also will FINALLY show up on HUD when you equip the weapon :D
	if ( GetWeaponInfoFileKeyField_Global( data.baseWeapon, "ammo_pool_type" ) != null )
		data.ammoType = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "ammo_pool_type" )

	// loot tags is just weapon type in disguise.
	data.lootTags = [ weaponData.weaponType ]
	data.lootType = eLootType.MAINWEAPON
	
	// sort the attachments so it appears like vanilla and not messed up
	// if it's typed incorrectly in playlists
	weaponData.supportedAttachments.sort(
		int function( string attachmentA, string attachmentB ) : ()
		{
			int aIndex = attachmentSortOrder.find( attachmentA )
			int bIndex = attachmentSortOrder.find( attachmentB )
			if ( aIndex > bIndex )
				return 1
			else if ( aIndex < bIndex )
				return -1
			return 0
		}
	)
	


	data.supportedAttachments = weaponData.supportedAttachments
	// base mods, come with the weapon.
	data.baseMods = weaponData.baseMods
	
	// index goes above 100 with custom items, this is why we extended the remote function.
	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data

	#if SERVER
		SURVIVAL_AddSpawnPointGroup( data.ref )
	#endif
	
	#if !UI
		if ( data.model != $"" )
			PrecacheModel( data.model )
		// Add the item to the loot pool
		if (!weaponData.isCP)
		{
			AddCustomItemToLootPool(data.ref, "weapon_low", weaponData.lowWeaponChance)
			AddCustomItemToLootPool(data.ref, "weapon_medium", weaponData.medWeaponChance)
			AddCustomItemToLootPool(data.ref, "weapon_high", weaponData.highWeaponChance)
		}
		else 
		{
			AddCustomItemToLootPool(data.ref, "crate_weapons_earlygame", weaponData.lowWeaponChance)
			AddCustomItemToLootPool(data.ref, "crate_weapons_midgame", weaponData.medWeaponChance)
			AddCustomItemToLootPool(data.ref, "crate_weapons_lategame", weaponData.highWeaponChance)
		}
	#endif
	// Not needed to appear in the dev menu.
	//#if CLIENT
	//RunUIScript( "SetupDevCommand", "Spawn " + data.pickupString, "script SpawnGenericLoot( \"" + data.ref + "\", gp()[0].GetOrigin(), <-1,-1,-1>, 1 )" )
	//#endif
}

void function CreateCustomHopup(CustomHopupData hopupData)
{
	LootData data

	data.ref = hopupData.className
	data.pickupString = hopupData.displayName
	data.desc = hopupData.desc
	data.hudIcon = hopupData.icon
	data.model = hopupData.model
	data.tier = hopupData.tier

	// can be hardcoded since this is an attachment, no need for custom pickup sounds.
	data.pickupSound_1p = "survival_loot_pickup_attachments"
	data.pickupSound_3p = "survival_loot_pickup_3p_attachments"

	// needs to be setup, otherwise you won't be able to pick up the attachment
	data.countPerDrop = 1
	data.inventorySlotCount = 1
	data.attachmentStyle = "hopup"

	data.lootTags = []
	data.lootType = eLootType.ATTACHMENT


	// index goes above 100 with custom items, this is why we extended the remote function.
	data.index = file.lootIndexToString.len()
	file.lootIndexToString.append( data.ref )
	file.lootData[ data.ref ] <- data

	#if !UI
		// add custom item to loot pool.
		AddCustomItemToLootPool(data.ref, "attachment_low", hopupData.lowWeight)
		AddCustomItemToLootPool(data.ref, "attachment_medium", hopupData.medWeight)
		AddCustomItemToLootPool(data.ref, "attachment_high", hopupData.highWeight)
	#endif
	file.customHopups.append(hopupData)
}

table< string, LootData > function SURVIVAL_Loot_GetLootDataTable()
{
	return file.lootData
}

array<LootData> function SURVIVAL_Loot_GetByType( int lootType )
{
	array<LootData> lootOfType = []
	foreach ( string lootRef, LootData lootData in file.lootData )
	{
		if ( lootData.lootType != lootType )
			continue

		lootOfType.append( lootData )
	}

	return lootOfType
}


array<LootData> function SURVIVAL_Loot_GetByTier( int tier )
{
	array<LootData> lootOfTier = []
	foreach ( string lootRef, LootData lootData in file.lootData )
	{
		if ( lootData.tier!= tier )
			continue

		if ( SURVIVAL_Loot_IsRefDisabled( lootData.ref ) )
			continue

		printt( lootData.ref )

		lootOfTier.append( lootData )
	}

	return lootOfTier
}


int function SURVIVAL_Loot_GetLootTypeFromString( string lootTypeString )
{
	Assert( lootTypeString != "", "Loot Type has null type defined in survival_loot.csv" )

	switch( lootTypeString )
	{
		case "main_weapon":
			return eLootType.MAINWEAPON

		case "ammo":
			return eLootType.AMMO

		case "health":
			return eLootType.HEALTH

		case "armor":
			return eLootType.ARMOR

		case "incapshield":
			return eLootType.INCAPSHIELD

		case "jumpkit":
			return eLootType.JUMPKIT

		case "ordnance":
			return eLootType.ORDNANCE

		case "attachment":
			return eLootType.ATTACHMENT

		case "backpack":
			return eLootType.BACKPACK

		case "custom_pickup":
			return eLootType.CUSTOMPICKUP

		case "helmet":
			return eLootType.HELMET

#if SERVER



#endif

		case "data_knife":
			return eLootType.DATAKNIFE


		case "blank":
			return eLootType.BLANK

		case "resource":
			return eLootType.RESOURCE

#if SERVER



#endif

#if SERVER



#endif

#if SERVER



#endif

		default:
			//
			Warning( "Error Building LootData Struct: Unknown loot type string: " + lootTypeString )
			return eLootType.BLANK
	}

	unreachable
}

LootData function SURVIVAL_Loot_GetLootDataByIndex( int index )
{
	#if CLIENT
	try
	{
		return file.lootData[ file.lootIndexToString[ index ] ]
	}
	catch (error)
	{
		RunUIScript("OpenErrorDialog", "Client loot table out of sync (code:items)\n\nMake sure you have the custom weapon framework installed and your weapon files match.")
		GetLocalClientPlayer().ClientCommand("disconnect")
		printt(error)
		return file.lootData[ file.lootIndexToString[0] ]
	}
	unreachable
	#else
	// Server is always right, therefore this must exist.
	return file.lootData[ file.lootIndexToString[ index ] ]
	#endif
}
bool function SURVIVAL_Loot_IsLootIndexValid( int index )
{
	return ( index in file.lootIndexToString )
}
LootData function SURVIVAL_Loot_GetLootDataByRef( string ref )
{
	return file.lootData[ ref ]
}
bool function SURVIVAL_Loot_IsRefValid( string ref )
{
	return (ref in file.lootData)
}

bool function SURVIVAL_Loot_IsRefDisabled( string ref )
{
	return file.disabledRefs.contains( ref )
}

#if CLIENT
vector function GetRarityColor( entity ent )
{
	int lootIndex = ent.GetSurvivalInt()
	Assert( lootIndex >= 0 )
	LootData lootData = SURVIVAL_Loot_GetLootDataByIndex( lootIndex )

	return GetKeyColor( COLORID_TEXT_LOOT_TIER0, lootData.tier )
}
#endif

#if SERVER
//HACK: Resurrection of loot color consts for when the server picks a color
const int RARE_R = 58
const int RARE_G = 133
const int RARE_B = 176

const int EPIC_R = 136
const int EPIC_G = 63
const int EPIC_B = 162

const int LEGENDARY_R = 220
const int LEGENDARY_G = 185
const int LEGENDARY_B = 39

const vector LOOT_COLOR_NONE = <0, 0, 0>
const vector LOOT_COLOR_COMMON = <192, 192, 192>
const vector LOOT_COLOR_RARE = <RARE_R, RARE_G, RARE_B>
const vector LOOT_COLOR_EPIC = <EPIC_R, EPIC_G, EPIC_B>
const vector LOOT_COLOR_LEGENDARY = <LEGENDARY_R, LEGENDARY_G, LEGENDARY_B>
const vector LOOT_COLOR_HEIRLOOM = <255, 0, 0>
#endif

// use this for in game loot
vector function GetFXRarityColorForTier( int tier )
{
#if SERVER
	//Warning( "Server is attempting to get a loot rarity color. This does not support accessibility features such as color blind mode." )
	switch ( tier )
	{
		case eLootTier.NONE:
			return LOOT_COLOR_NONE

		case eLootTier.COMMON:
			return LOOT_COLOR_COMMON

		case eLootTier.RARE:
			return LOOT_COLOR_RARE

		case eLootTier.EPIC:
			return LOOT_COLOR_EPIC

		case eLootTier.LEGENDARY:
			return LOOT_COLOR_LEGENDARY

		default:
			return <255, 255, 255>
	}
#endif

#if !SERVER
	return GetKeyColor( COLORID_FX_LOOT_TIER0, tier )
#endif

	unreachable
}

// use this for lootbox loot
vector function GetFXRarityColorForUnlockable( int tier )
{
#if SERVER
		Warning( "Server is attempting to get a loot rarity color. This does not support accessibility features such as color blind mode." )
		switch ( tier )
		{
			case eLootTier.NONE:
				return LOOT_COLOR_NONE

			case eLootTier.COMMON:
				return LOOT_COLOR_COMMON

			case eLootTier.RARE:
				return LOOT_COLOR_RARE

			case eLootTier.EPIC:
				return LOOT_COLOR_EPIC

			case eLootTier.LEGENDARY:
				return LOOT_COLOR_LEGENDARY

			case eLootTier.HEIRLOOM:
				return LOOT_COLOR_HEIRLOOM

			default:
				return <255, 255, 255>
		}
#endif

#if !SERVER
	return GetKeyColor( COLORID_FX_LOOT_TIER0, tier + 1 )
#endif

	unreachable
}

#if CLIENT && DEVELOPER
void function DumpModdedKeyColors( int colorID, float modVal )
{
	for ( int index = 0; index < 6; index++ )
	{
		vector color = ColorPalette_GetColorFromID( colorID + index ) / 255.0
		color = SrgbToLinear( color )
		color *= modVal
		color = LinearToSrgb( color ) * 255.0

		printt( index + ", ", int( color.x ) + " ", int( color.y ) + " ", int( color.z ) )
	}
}
#endif

#if CLIENT && DEVELOPER
void function DiffKeyColors( int baseColorID, int colorID )
{
	var datatable = GetDataTable( $"datatable/colorpalette_table.rpak" )
	for ( int index = 0; index < 6; index++ )
	{
		vector baseColor = ColorPalette_GetColorFromID( baseColorID + index )
		vector otherColor = ColorPalette_GetColorFromID( colorID + index )

		float deltaX = (baseColor.x - otherColor.x) / 255.0
		float deltaY = (baseColor.y - otherColor.y) / 255.0
		float deltaZ = (baseColor.z - otherColor.z) / 255.0

		vector protanColor = GetDataTableVector( datatable, baseColorID + index, 2 )
		vector deuterColor = GetDataTableVector( datatable, baseColorID + index, 3 )
		vector tritanColor = GetDataTableVector( datatable, baseColorID + index, 4 )

		printt( index + ", ", deltaX + " ", deltaY + " ", deltaZ )
	}
}
#endif


bool function SURVIVAL_Loot_IsUniqueAmmoWeapon( string ref )
{
	return file.uniqueAmmoWeaponRefs.contains( ref )
}


#if(UI)
void function SURVIVAL_UIInit_Override_DeathBox_RUI()
{
	if ( !IsConnected() )
		return

	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) != 1 )
		return

	if ( !file.overrideDeathBoxRUI_Initialized ) //
	{
		AddUICallback_OnLevelInit( SURVIVAL_UI_OnLevelInit )
		AddCallbackAndCallNow_UserInfoUpdated( HAS_DEATHBOX_OVERRIDE_OnUserInfoUpdated )
	}

	file.overrideDeathBoxRUI_Initialized = true
}
#endif


#if(UI)
void function SURVIVAL_UI_OnLevelInit()
{
	if ( IsLobby() )
	{
		return
	}

	if ( GetCurrentPlaylistVarInt( "enableFlyers", 1 ) != 1 )
		return

	thread SURVIVAL_UI_GatherFriendInfo()
}
#endif


#if(UI)
void function SURVIVAL_UI_GatherFriendInfo()
{
	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) <= 0 )
		return

	Signal( uiGlobal.signalDummy, "GatherFriendInfo" )
	EndSignal( uiGlobal.signalDummy, "GatherFriendInfo" )
	EndSignal( uiGlobal.signalDummy, "GatheredEnoughFriendInfo" )


	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) == 0 )
		return

	file.overrideDeathBoxRUIProfilesTable.clear()
	file.profilesSent = 0

	FriendsData fData = GetFriendsData()

	while( fData.friends.len() > 0 )
	{
		int randomIndex = RandomInt( fData.friends.len() )
		Friend friend   = fData.friends[ randomIndex  ]
		fData.friends.fastremove( randomIndex )

		if ( friend.ingame == true ) //
			continue

		OverrideDeathBoxRUI_NetworkOptimizedStruct profileData

		file.overrideDeathBoxRUIProfilesTable[ friend.hardware + friend.id  ] <- profileData

		CommunityUserInfo ornull cui = GetUserInfo( friend.hardware, friend.id ) //

		if ( !file.overrideDeathBoxRUIProfilesTable[ friend.hardware + friend.id  ].isValid ) //
		{
			wait 2.0 //
		}
	}
}
#endif


#if(UI)
void function HAS_DEATHBOX_OVERRIDE_OnUserInfoUpdated( string hardware, string id )
{
	if ( !IsConnected()  ) //
		return

	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) != 1 )
		return

	if ( IsLobby() )
		return

	if ( hardware == "" && id == "" )
		return

	CommunityUserInfo ornull cui = GetUserInfo( hardware, id )

	if ( cui == null )
		return

	if ( !((hardware + id) in file.overrideDeathBoxRUIProfilesTable) ) //
		return

	expect CommunityUserInfo( cui )

	if ( !HasCommunityUserPlayedApex( cui ) )
		return

	if ( file.profilesSent >= GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) )
		return

	OverrideDeathBoxRUI_NetworkOptimizedStruct profileData
	profileData.name = cui.name
	profileData.hardware = cui.hardware
	profileData.playerID = cui.uid

	ItemFlavor character               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.CHARACTER, eItemType.character )
	LoadoutEntry characterLoadoutEntry = Loadout_CharacterClass()
	profileData.characterIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( characterLoadoutEntry, character )

	ItemFlavor skin               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.CHARACTER_SKIN, eItemType.character_skin )
	LoadoutEntry skinLoadoutEntry = Loadout_CharacterSkin( character )
	profileData.skinIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( skinLoadoutEntry, skin )

	ItemFlavor frame               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.BANNER_FRAME, eItemType.gladiator_card_frame )
	LoadoutEntry frameLoadoutEntry = Loadout_GladiatorCardFrame( character )
	profileData.frameIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( frameLoadoutEntry, frame )

	ItemFlavor stance               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.BANNER_STANCE, eItemType.gladiator_card_stance )
	LoadoutEntry stanceLoadoutEntry = Loadout_GladiatorCardStance( character )
	profileData.stanceIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( stanceLoadoutEntry, stance )

	ItemFlavor firstBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 0 )
	LoadoutEntry firstBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 0 )
	profileData.firstBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( firstBadgeLoadoutEntry, firstBadge )

	int firstBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 0 )
	profileData.firstBadgeDataInt = firstBadgeDataInt

	ItemFlavor secondBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 1 )
	LoadoutEntry secondBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 1 )
	profileData.secondBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( secondBadgeLoadoutEntry, secondBadge )

	int secondBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 1 )
	profileData.secondBadgeDataInt = secondBadgeDataInt

	ItemFlavor thirdBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 2 )
	LoadoutEntry thirdBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 2 )
	profileData.thirdBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( thirdBadgeLoadoutEntry, thirdBadge )

	int thirdBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 2 )
	profileData.thirdBadgeDataInt = thirdBadgeDataInt

	profileData.isValid = true

	file.overrideDeathBoxRUIProfilesTable[ hardware + id  ] = profileData

	//
	string clientCommandString = "ClientCommand_RUIProfileList "
	clientCommandString += profileData.name
	clientCommandString += " "
	clientCommandString += profileData.hardware
	clientCommandString += " "
	clientCommandString += profileData.playerID
	clientCommandString += " "
	clientCommandString += profileData.characterIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.skinIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.frameIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.stanceIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.firstBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.firstBadgeDataInt.tostring()
	clientCommandString += " "
	clientCommandString += profileData.secondBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.secondBadgeDataInt.tostring()
	clientCommandString += " "
	clientCommandString += profileData.thirdBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.thirdBadgeDataInt.tostring()

	//
	ClientCommand( clientCommandString )

	if ( ++file.profilesSent >= GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) )
	{
		Signal( uiGlobal.signalDummy, "GatheredEnoughFriendInfo" ) //
	}
}
#endif
