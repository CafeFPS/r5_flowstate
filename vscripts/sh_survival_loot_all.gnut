global function SURVIVAL_Loot_All_InitShared

global function SURVIVAL_Loot_GetLootDataTable
global function SURVIVAL_Loot_GetLootDataByIndex
global function SURVIVAL_Loot_IsLootIndexValid
global function SURVIVAL_Loot_GetLootDataByRef
global function SURVIVAL_Loot_IsRefValid
global function SURVIVAL_Loot_IsRefDisabled
global function SURVIVAL_Loot_GetByType
global function SURVIVAL_Loot_GetLootTypeFromString
global function SURVIVAL_Loot_GetByTier

global function SURVIVAL_Loot_IsUniqueAmmoWeapon

#if CLIENT
global function GetRarityColor
#endif

#if CLIENT && R5DEV
global function DumpModdedKeyColors
global function DiffKeyColors
#endif

global function GetFXRarityColorForTier // use this for in game loot
global function GetFXRarityColorForUnlockable

global enum eLootTier
{
	NONE
	COMMON
	RARE
	EPIC
	LEGENDARY
	HEIRLOOM

	_count
}

global struct LootData
{
	string ref
	int tier
	int index = -1
	int inventorySlotCount
	int pingCommsAction
	asset model
	int skinOverride
	asset hudIcon
	asset emptyImage
	string attachSound
	string pickupSound_1p
	string pickupSound_3p
	string carrySound
	string pickupString
	string desc
	string specialCaseInvalidReason
	int countPerDrop
	int lootType
	string netInt
	array<string> supportedAttachments
	array<string> lootTags
	string        ammoType
	float         minInWorld
	bool          isActive = false
	int           passive = -1
	string        attachmentStyle = ""
	int           scrapValue
	bool          droppodRotate = false
	bool          isDynamic = false
	bool          conditional = false

	string baseWeapon
	array<string> baseMods

	asset fakeAmmoIcon
	array<string> fakeMods
}

global enum eLootType
{
	MAINWEAPON
	AMMO
	HEALTH
	ARMOR
	INCAPSHIELD
	JUMPKIT
	ORDNANCE
	ATTACHMENT
	CUSTOMPICKUP
	BACKPACK
	HELMET
	BLANK
	#if(true)
		DATAKNIFE
	#endif
	RESOURCE

	_count
}

global const int HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND = 3

#if(false)




#endif

#if(false)

#endif


#if(true)
global struct OverrideDeathBoxRUI_NetworkOptimizedStruct
{
	string name
	string hardware
	string playerID
	int    characterIndex
	int    skinIndex
	int    frameIndex
	int    stanceIndex
	int    firstBadgeIndex
	int    firstBadgeDataInt
	int    secondBadgeIndex
	int    secondBadgeDataInt
	int    thirdBadgeIndex
	int    thirdBadgeDataInt

	bool isValid = false
}
#endif


struct
{
	table< string, LootData > lootData
	array<string>             lootIndexToString
	bool                      initialized
	array<string>             disabledRefs
	array<string>             uniqueAmmoWeaponRefs

	#if(true)
		table<EHI, array< OverrideDeathBoxRUI_NetworkOptimizedStruct > > EHIToOverrideDeathBoxRUIProfilesTable
		table<string, EHI>                                               corpseToEHITable
		array< OverrideDeathBoxRUI_NetworkOptimizedStruct >              handcraftedProfiles
		array< OverrideDeathBoxRUI_NetworkOptimizedStruct >              handcraftedProfilesMasterList //
	#endif

	#if(UI)
		bool                                                      overrideDeathBoxRUI_Initialized = false
		table<string, OverrideDeathBoxRUI_NetworkOptimizedStruct> overrideDeathBoxRUIProfilesTable
		int                                                       profilesSent = 0
	#endif
} file


array<string> attachmentSortOrder = ["barrel", "mag", "sight", "grip", "hopup"]


string function GetLootTableString( string ref, var datatable, int rowIndex, string columnName )
{
	string val = GetDataTableString( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarString( (ref + "_dt_override_" + columnName), val )
}


asset function GetLootTableAsset( string ref, var datatable, int rowIndex, string columnName )
{
	return GetDataTableAsset( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
}


int function GetLootTableInt( string ref, var datatable, int rowIndex, string columnName )
{
	int val = GetDataTableInt( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarInt( (ref + "_dt_override_" + columnName), val )
}


bool function GetLootTableBool( string ref, var datatable, int rowIndex, string columnName )
{
	bool val = GetDataTableBool( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarBool( (ref + "_dt_override_" + columnName), val )
}


float function GetLootTableFloat( string ref, var datatable, int rowIndex, string columnName )
{
	float val = GetDataTableFloat( datatable, rowIndex, GetDataTableColumnByName( datatable, columnName ) )
	return GetCurrentPlaylistVarFloat( (ref + "_dt_override_" + columnName), val )
}

	// Need these here so they get included in bulids

void function SURVIVAL_Loot_All_InitShared()
{
	#if(!UI)
		//
	#endif

	var dt = GetDataTable( $"datatable/survival_loot.rpak" )
	file.lootIndexToString.clear()
	file.lootData.clear()

	var attachmentTable = GetDataTable( $"datatable/survival_weapon_mods.rpak" )

	file.disabledRefs.clear()
	string disabledRefs = GetCurrentPlaylistVarString( "survival_disabled_loot", " " )
	file.disabledRefs = split( disabledRefs, " " )

	int numRows = GetDatatableRowCount( dt )
	for ( int i = 0; i < numRows; i++ )
	{
		LootData data
		data.ref = GetDataTableString( dt, i, GetDataTableColumnByName( dt, "ref" ) )
		string featureFlagRef = GetLootTableString( data.ref, dt, i, "featureFlag" )
		if ( featureFlagRef != "" && !GetFeatureFlagByString( featureFlagRef ) )
		{
			printf( "Skipping loot ref %s because feature flag %s is off.", data.ref, featureFlagRef )
			printf( "Loot ref %s: feature flag %s is off", data.ref, featureFlagRef )
			continue
		}

		string pingCommsActionName = GetLootTableString( data.ref, dt, i, "pingCommsAction" )

		#if SERVER || CLIENT
		data.pingCommsAction = GetCommsActionForName( pingCommsActionName )
		#endif

		string lootType = GetLootTableString( data.ref, dt, i, "type" )

		data.baseWeapon = GetLootTableString( data.ref, dt, i, "baseWeapon" )

		if ( data.baseWeapon == "" )
		{
			data.baseWeapon = data.ref
		}

		data.fakeAmmoIcon = GetLootTableAsset( data.ref, dt, i, "fakeAmmoIcon" )

		data.baseMods = split( GetLootTableString( data.ref, dt, i, "baseMods" ), " " )

		data.model = GetLootTableAsset( data.ref, dt, i, "pickupModel" )
		data.skinOverride = GetLootTableInt( data.ref, dt, i, "skinOverride" )
		data.hudIcon = GetLootTableAsset( data.ref, dt, i, "icon" )
		data.attachSound = GetLootTableString( data.ref, dt, i, "attachSound" )
		data.pickupSound_3p = GetLootTableString( data.ref, dt, i, "pickupSound_3p" )
		data.pickupSound_1p = GetLootTableString( data.ref, dt, i, "pickupSound_1p" )
		data.carrySound = GetLootTableString( data.ref, dt, i, "carrySound" )
		data.scrapValue = GetLootTableInt( data.ref, dt, i, "scrapValue" )
		data.droppodRotate = GetLootTableBool( data.ref, dt, i, "droppodRotate" )
		data.isDynamic = GetLootTableBool( data.ref, dt, i, "isDynamic" )
		data.conditional = GetLootTableBool( data.ref, dt, i, "conditional" )

		data.pickupString = GetLootTableString( data.ref, dt, i, "pickupString" )
		data.desc = GetLootTableString( data.ref, dt, i, "desc" )

		data.countPerDrop = GetLootTableInt( data.ref, dt, i, "countPerDrop" )
		data.tier = GetLootTableInt( data.ref, dt, i, "tier" )

		string supportedAttachmentsString  = GetLootTableString( data.ref, dt, i, "supportedAttachments" )
		array<string> supportedAttachments = split( supportedAttachmentsString, " " )
		supportedAttachments.sort(
			int function( string attachmentA, string attachmentB ) : ()
			{
				int aIndex = attachmentSortOrder.find( attachmentA )
				int bIndex = attachmentSortOrder.find( attachmentB )
				if ( aIndex > bIndex )
					return 1
				else if ( aIndex < bIndex )
					return -1

				return 0
			}
		)
		data.supportedAttachments = supportedAttachments

		data.lootTags = split( GetLootTableString( data.ref, dt, i, "lootTags" ), " " )

		data.lootType = SURVIVAL_Loot_GetLootTypeFromString( lootType )
		data.netInt = GetLootTableString( data.ref, dt, i, "netInt" )
		data.inventorySlotCount = GetLootTableInt( data.ref, dt, i, "inventorySlotCount" )

		#if SERVER || CLIENT
		data.minInWorld = GetLootTableFloat( data.ref, dt, i, "minInWorld" )
		if ( IsTestMap() )
			data.minInWorld = max( -1, data.minInWorld )
		//Not ideal - The minInWorld concept is unlikely the right way to do ( now ) map specific items.

		if ( data.ref == "data_knife" && GetMapName() != "mp_rr_desertlands_64k_x_64k" )
			data.minInWorld = 0.0
		#endif

		string passiveRef = GetLootTableString( data.ref, dt, i, "passive" )
		if ( passiveRef == "" )
		{
			data.passive = ePassives.INVALID
		}
		else
		{
			Assert( passiveRef in ePassives )
			data.passive = ePassives[passiveRef]
			#if CLIENT || UI
				Assert( data.passive in PASSIVE_NAME_MAP )
				Assert( data.passive in PASSIVE_DESCRIPTION_SHORT_MAP )
			#endif
		}

		switch ( data.lootType )
		{
			case eLootType.MAINWEAPON:
				RegisterWeaponForUse( data.baseWeapon )
				data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
				data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
				data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
				data.model = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "playermodel" )
				if ( GetWeaponInfoFileKeyField_Global( data.baseWeapon, "ammo_pool_type" ) != null )
					data.ammoType = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "ammo_pool_type" )
				else
					data.ammoType = ""

				if ( data.fakeAmmoIcon != "" )
				{
					file.uniqueAmmoWeaponRefs.append( data.ref )
				}

				ItemFlavor ornull weaponFlavor = GetWeaponItemFlavorByClass( data.baseWeapon )
				if ( weaponFlavor != null )
				{
					expect ItemFlavor( weaponFlavor )

					int availableState = ItemFlavor_GetPlaylistOpinion( weaponFlavor )
					bool shouldBeEnabled
					if ( availableState == eItemFlavorPlaylistOpinion.FORCE_UNLOCK_FOR_SPECIAL_EVENT )
						shouldBeEnabled = true
					else if ( availableState == eItemFlavorPlaylistOpinion.HIDDEN )
						shouldBeEnabled = false
					else if ( availableState == eItemFlavorPlaylistOpinion.DISABLED )
						shouldBeEnabled = false
					else
						shouldBeEnabled = ItemFlavor_IsActiveForEdition( weaponFlavor, GetConVarInt( "mtx_svEdition" ) )

					if ( !shouldBeEnabled )
						file.disabledRefs.append( data.ref )
				}
				break

			case eLootType.ORDNANCE:
				RegisterWeaponForUse( data.baseWeapon )
				data.pickupString = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "printName" )
				data.desc = GetWeaponInfoFileKeyField_GlobalString( data.baseWeapon, "description" )
				data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( data.baseWeapon, "hud_icon" )
				break

			case eLootType.AMMO:
				data.countPerDrop = int( GetCurrentPlaylistVarFloat( "loot_ammo_scale_per_drop", 1.0 ) * float( data.countPerDrop ) )
				data.inventorySlotCount = int( GetCurrentPlaylistVarFloat( "inventory_ammo_scale_stacksize", 1.0 ) * float( data.inventorySlotCount ) )
				break

			case eLootType.ATTACHMENT:
				int row = GetDataTableRowMatchingStringValue( attachmentTable, GetDataTableColumnByName( attachmentTable, "mod" ), data.ref )
				data.pickupString = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "name" ) )
				data.desc = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "description" ) )

				data.ammoType = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "ammoType" ) )
				data.hudIcon = GetLootTableAsset( data.ref, dt, i, "icon" )
				data.specialCaseInvalidReason = ""//
				if ( data.hudIcon == $"" )
					data.hudIcon = GetDataTableAsset( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "image" ) )

				string attachmentPoint = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "attachmentPoint" ) )
				data.attachmentStyle = GetDataTableString( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "type" ) )
				data.emptyImage = GetDataTableAsset( attachmentTable, row, GetDataTableColumnByName( attachmentTable, "emptyImage" ) )

				#if SERVER || CLIENT
				RegisterAttachmentPoint( attachmentPoint )
				#endif
				break
		}

		{
			data.index = file.lootIndexToString.len()
			file.lootIndexToString.append( data.ref )
			file.lootData[ data.ref ] <- data

			#if SERVER
				SURVIVAL_AddSpawnPointGroup( data.ref )
			#endif
		}

		#if !UI
			if ( data.model != $"" )
				PrecacheModel( data.model )
		#endif
	}



	#if(UI)
		RegisterSignal( "GatherFriendInfo" )
		RegisterSignal( "GatheredEnoughFriendInfo" )
		SURVIVAL_UIInit_Override_DeathBox_RUI()
	#endif

	file.initialized = true
    
}  

table< string, LootData > function SURVIVAL_Loot_GetLootDataTable()
{
	return file.lootData
}

array<LootData> function SURVIVAL_Loot_GetByType( int lootType )
{
	array<LootData> lootOfType = []
	foreach ( string lootRef, LootData lootData in file.lootData )
	{
		if ( lootData.lootType != lootType )
			continue

		lootOfType.append( lootData )
	}

	return lootOfType
}


array<LootData> function SURVIVAL_Loot_GetByTier( int tier )
{
	array<LootData> lootOfTier = []
	foreach ( string lootRef, LootData lootData in file.lootData )
	{
		if ( lootData.tier!= tier )
			continue

		if ( SURVIVAL_Loot_IsRefDisabled( lootData.ref ) )
			continue

		printt( lootData.ref )

		lootOfTier.append( lootData )
	}

	return lootOfTier
}


int function SURVIVAL_Loot_GetLootTypeFromString( string lootTypeString )
{
	Assert( lootTypeString != "", "Loot Type has null type defined in survival_loot.csv" )

	switch( lootTypeString )
	{
		case "main_weapon":
			return eLootType.MAINWEAPON

		case "ammo":
			return eLootType.AMMO

		case "health":
			return eLootType.HEALTH

		case "armor":
			return eLootType.ARMOR

		case "incapshield":
			return eLootType.INCAPSHIELD

		case "jumpkit":
			return eLootType.JUMPKIT

		case "ordnance":
			return eLootType.ORDNANCE

		case "attachment":
			return eLootType.ATTACHMENT

		case "backpack":
			return eLootType.BACKPACK

		case "custom_pickup":
			return eLootType.CUSTOMPICKUP

		case "helmet":
			return eLootType.HELMET

#if SERVER



#endif

		case "data_knife":
			return eLootType.DATAKNIFE


		case "blank":
			return eLootType.BLANK

		case "resource":
			return eLootType.RESOURCE

#if SERVER



#endif

#if SERVER



#endif

#if SERVER



#endif

		default:
			//
			Warning( "Error Building LootData Struct: Unknown loot type string: " + lootTypeString )
			return eLootType.BLANK
	}

	unreachable
}

LootData function SURVIVAL_Loot_GetLootDataByIndex( int index )
{
	return file.lootData[ file.lootIndexToString[ index ] ]
}
bool function SURVIVAL_Loot_IsLootIndexValid( int index )
{
	return ( index in file.lootIndexToString )
}
LootData function SURVIVAL_Loot_GetLootDataByRef( string ref )
{
	return file.lootData[ ref ]
}
bool function SURVIVAL_Loot_IsRefValid( string ref )
{
	return (ref in file.lootData)
}

bool function SURVIVAL_Loot_IsRefDisabled( string ref )
{
	return file.disabledRefs.contains( ref )
}

#if CLIENT
vector function GetRarityColor( entity ent )
{
	int lootIndex = ent.GetSurvivalInt()
	Assert( lootIndex >= 0 )
	LootData lootData = SURVIVAL_Loot_GetLootDataByIndex( lootIndex )

	return GetKeyColor( COLORID_TEXT_LOOT_TIER0, lootData.tier )
}
#endif

#if SERVER
//HACK: Resurrection of loot color consts for when the server picks a color
const int RARE_R = 58
const int RARE_G = 133
const int RARE_B = 176

const int EPIC_R = 136
const int EPIC_G = 63
const int EPIC_B = 162

const int LEGENDARY_R = 220
const int LEGENDARY_G = 185
const int LEGENDARY_B = 39

const vector LOOT_COLOR_NONE = <0, 0, 0>
const vector LOOT_COLOR_COMMON = <192, 192, 192>
const vector LOOT_COLOR_RARE = <RARE_R, RARE_G, RARE_B>
const vector LOOT_COLOR_EPIC = <EPIC_R, EPIC_G, EPIC_B>
const vector LOOT_COLOR_LEGENDARY = <LEGENDARY_R, LEGENDARY_G, LEGENDARY_B>
const vector LOOT_COLOR_HEIRLOOM = <255, 0, 0>
#endif

// use this for in game loot
vector function GetFXRarityColorForTier( int tier )
{
#if SERVER
    //Warning( "Server is attempting to get a loot rarity color. This does not support accessibility features such as color blind mode." )
	switch ( tier )
	{
		case eLootTier.NONE:
			return LOOT_COLOR_NONE

		case eLootTier.COMMON:
			return LOOT_COLOR_COMMON

		case eLootTier.RARE:
			return LOOT_COLOR_RARE

		case eLootTier.EPIC:
			return LOOT_COLOR_EPIC

		case eLootTier.LEGENDARY:
			return LOOT_COLOR_LEGENDARY

		default:
			return <255, 255, 255>
	}
#endif

#if !SERVER
	return GetKeyColor( COLORID_FX_LOOT_TIER0, tier )
#endif

	unreachable
}

// use this for lootbox loot
vector function GetFXRarityColorForUnlockable( int tier )
{
#if SERVER
		Warning( "Server is attempting to get a loot rarity color. This does not support accessibility features such as color blind mode." )
		switch ( tier )
		{
			case eLootTier.NONE:
				return LOOT_COLOR_NONE

			case eLootTier.COMMON:
				return LOOT_COLOR_COMMON

			case eLootTier.RARE:
				return LOOT_COLOR_RARE

			case eLootTier.EPIC:
				return LOOT_COLOR_EPIC

			case eLootTier.LEGENDARY:
				return LOOT_COLOR_LEGENDARY

			case eLootTier.HEIRLOOM:
				return LOOT_COLOR_HEIRLOOM

			default:
				return <255, 255, 255>
		}
#endif

#if !SERVER
	return GetKeyColor( COLORID_FX_LOOT_TIER0, tier + 1 )
#endif

	unreachable
}

#if CLIENT && R5DEV
void function DumpModdedKeyColors( int colorID, float modVal )
{
	for ( int index = 0; index < 6; index++ )
	{
		vector color = ColorPalette_GetColorFromID( colorID + index ) / 255.0
		color = SrgbToLinear( color )
		color *= modVal
		color = LinearToSrgb( color ) * 255.0

		printt( index + ", ", int( color.x ) + " ", int( color.y ) + " ", int( color.z ) )
	}
}
#endif

#if CLIENT && R5DEV
void function DiffKeyColors( int baseColorID, int colorID )
{
	var datatable = GetDataTable( $"datatable/colorpalette_table.rpak" )
	for ( int index = 0; index < 6; index++ )
	{
		vector baseColor = ColorPalette_GetColorFromID( baseColorID + index )
		vector otherColor = ColorPalette_GetColorFromID( colorID + index )

		float deltaX = (baseColor.x - otherColor.x) / 255.0
		float deltaY = (baseColor.y - otherColor.y) / 255.0
		float deltaZ = (baseColor.z - otherColor.z) / 255.0

		vector protanColor = GetDataTableVector( datatable, baseColorID + index, 2 )
		vector deuterColor = GetDataTableVector( datatable, baseColorID + index, 3 )
		vector tritanColor = GetDataTableVector( datatable, baseColorID + index, 4 )

		printt( index + ", ", deltaX + " ", deltaY + " ", deltaZ )
	}
}
#endif


bool function SURVIVAL_Loot_IsUniqueAmmoWeapon( string ref )
{
	return file.uniqueAmmoWeaponRefs.contains( ref )
}


#if(UI)
void function SURVIVAL_UIInit_Override_DeathBox_RUI()
{
	if ( !IsConnected() )
		return

	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) != 1 )
		return

	if ( !file.overrideDeathBoxRUI_Initialized ) //
	{
		AddUICallback_OnLevelInit( SURVIVAL_UI_OnLevelInit )
		AddCallbackAndCallNow_UserInfoUpdated( HAS_DEATHBOX_OVERRIDE_OnUserInfoUpdated )
	}

	file.overrideDeathBoxRUI_Initialized = true
}
#endif


#if(UI)
void function SURVIVAL_UI_OnLevelInit()
{
	if ( IsLobby() )
	{
		return
	}

	if ( GetCurrentPlaylistVarInt( "enableFlyers", 1 ) != 1 )
		return

	thread SURVIVAL_UI_GatherFriendInfo()
}
#endif


#if(UI)
void function SURVIVAL_UI_GatherFriendInfo()
{
	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) <= 0 )
		return

	Signal( uiGlobal.signalDummy, "GatherFriendInfo" )
	EndSignal( uiGlobal.signalDummy, "GatherFriendInfo" )
	EndSignal( uiGlobal.signalDummy, "GatheredEnoughFriendInfo" )


	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) == 0 )
		return

	file.overrideDeathBoxRUIProfilesTable.clear()
	file.profilesSent = 0

	FriendsData fData = GetFriendsData()

	while( fData.friends.len() > 0 )
	{
		int randomIndex = RandomInt( fData.friends.len() )
		Friend friend   = fData.friends[ randomIndex  ]
		fData.friends.fastremove( randomIndex )

		if ( friend.ingame == true ) //
			continue

		OverrideDeathBoxRUI_NetworkOptimizedStruct profileData

		file.overrideDeathBoxRUIProfilesTable[ friend.hardware + friend.id  ] <- profileData

		CommunityUserInfo ornull cui = GetUserInfo( friend.hardware, friend.id ) //

		if ( !file.overrideDeathBoxRUIProfilesTable[ friend.hardware + friend.id  ].isValid ) //
		{
			wait 2.0 //
		}
	}
}
#endif


#if(UI)
void function HAS_DEATHBOX_OVERRIDE_OnUserInfoUpdated( string hardware, string id )
{
	if ( !IsConnected()  ) //
		return

	if ( GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", 1 ) != 1 )
		return

	if ( IsLobby() )
		return

	if ( hardware == "" && id == "" )
		return

	CommunityUserInfo ornull cui = GetUserInfo( hardware, id )

	if ( cui == null )
		return

	if ( !((hardware + id) in file.overrideDeathBoxRUIProfilesTable) ) //
		return

	expect CommunityUserInfo( cui )

	if ( !HasCommunityUserPlayedApex( cui ) )
		return

	if ( file.profilesSent >= GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) )
		return

	OverrideDeathBoxRUI_NetworkOptimizedStruct profileData
	profileData.name = cui.name
	profileData.hardware = cui.hardware
	profileData.playerID = cui.uid

	ItemFlavor character               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.CHARACTER, eItemType.character )
	LoadoutEntry characterLoadoutEntry = Loadout_CharacterClass()
	profileData.characterIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( characterLoadoutEntry, character )

	ItemFlavor skin               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.CHARACTER_SKIN, eItemType.character_skin )
	LoadoutEntry skinLoadoutEntry = Loadout_CharacterSkin( character )
	profileData.skinIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( skinLoadoutEntry, skin )

	ItemFlavor frame               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.BANNER_FRAME, eItemType.gladiator_card_frame )
	LoadoutEntry frameLoadoutEntry = Loadout_GladiatorCardFrame( character )
	profileData.frameIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( frameLoadoutEntry, frame )

	ItemFlavor stance               = GetItemFlavorForCommunityUserInfo( cui, ePlayerStryderCharDataArraySlots.BANNER_STANCE, eItemType.gladiator_card_stance )
	LoadoutEntry stanceLoadoutEntry = Loadout_GladiatorCardStance( character )
	profileData.stanceIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( stanceLoadoutEntry, stance )

	ItemFlavor firstBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 0 )
	LoadoutEntry firstBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 0 )
	profileData.firstBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( firstBadgeLoadoutEntry, firstBadge )

	int firstBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 0 )
	profileData.firstBadgeDataInt = firstBadgeDataInt

	ItemFlavor secondBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 1 )
	LoadoutEntry secondBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 1 )
	profileData.secondBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( secondBadgeLoadoutEntry, secondBadge )

	int secondBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 1 )
	profileData.secondBadgeDataInt = secondBadgeDataInt

	ItemFlavor thirdBadge               = GetBadgeItemFlavorForCommunityUserInfo( cui, character, 2 )
	LoadoutEntry thirdBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 2 )
	profileData.thirdBadgeIndex = ConvertItemFlavorToLoadoutSlotContentsIndex( thirdBadgeLoadoutEntry, thirdBadge )

	int thirdBadgeDataInt = GetBadgeDataIntegerFromCommunityUserInfo( cui, 2 )
	profileData.thirdBadgeDataInt = thirdBadgeDataInt

	profileData.isValid = true

	file.overrideDeathBoxRUIProfilesTable[ hardware + id  ] = profileData

	//
	string clientCommandString = "ClientCommand_RUIProfileList "
	clientCommandString += profileData.name
	clientCommandString += " "
	clientCommandString += profileData.hardware
	clientCommandString += " "
	clientCommandString += profileData.playerID
	clientCommandString += " "
	clientCommandString += profileData.characterIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.skinIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.frameIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.stanceIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.firstBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.firstBadgeDataInt.tostring()
	clientCommandString += " "
	clientCommandString += profileData.secondBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.secondBadgeDataInt.tostring()
	clientCommandString += " "
	clientCommandString += profileData.thirdBadgeIndex.tostring()
	clientCommandString += " "
	clientCommandString += profileData.thirdBadgeDataInt.tostring()

	//
	ClientCommand( clientCommandString )

	if ( ++file.profilesSent >= GetCurrentPlaylistVarInt( "flyer_deathbox_friendlist_rui", HAS_DEATHBOX_OVERRIDE_FRIEND_PROFILES_TO_SEND ) )
	{
		Signal( uiGlobal.signalDummy, "GatheredEnoughFriendInfo" ) //
	}
}
#endif
