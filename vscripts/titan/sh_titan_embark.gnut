untyped

global function TitanEmbark_Init

global function TitanCanStand
global function TitanIsCurrentlyEmbarkableForPlayer
global function PlayerCanEmbarkTitan
global function PlayerCanImmediatelyEmbarkTitan
global function FindBestEmbark
global function GenerateEmbarkActionTable
global function FindEmbarkActionForCriteria
global function GetRandomEmbarkAction
//global function PlayerCanDisembarkTitan
global function IsPlayerDisembarking

#if SERVER
	global function CodeCallback_EmbarkTitan
	global function CodeCallback_EmbarkTitanFromGrapple
	global function ForceScriptedEmbark
	global function PlayerCanEmbarkIntoTitan
	global function IsPlayerEmbarking
	global function PlayerEmbarksTitan
	global function PlayerLungesToEmbark
	global function FindBestEmbarkForNpcAnim
	//global function PlayerDisembarksTitan
	//global function ForcedTitanDisembark
	//global function ForcedTitanDisembarkCustomAnims
	global function OverrideCockpitLightFX
	global function StartCockpitLightThink
	global function CockpitLightStop
	global function Embark_DelayedFadeOut
	global function PlayerIsFarOffTheGround
	global function SetSmallDisembarkFailSafeTeleportVector //TODO: Re-examine this for next game, probably should have different values for SP versus MP
	global function SetLargeDisembarkFailSafeTeleportVector //TODO: Re-examine this for next game, probably should have different values for SP versus MP
	global function SetCustomTitanIsEmbarkableForPlayerFunc
	global function CancelEmbark
	//global function ClientCommand_TitanDisembark
#endif

#if DEVELOPER
	global function SetEmbarkDebugPrint
#endif

const FAST_EMBARK = 1
const SKIP_AHEAD_TIME = 2.0

const EMBARK_FADE_TIME = 0.2

struct
{
	asset cockpitLightFX = $"xo_cockpit_dlight"
	bool embarkDebugPrint = false
	vector smallDisembarkFailSafeTeleportVector = <400,400,200>
	vector largeDisembarkFailSafeTeleportVector = <600,600,600>
	bool functionref( entity, entity ) customTitanIsEmbarkableForPlayer = null
} file

void function TitanEmbark_Init()
{
	if ( reloadingScripts )
		return

	level.pilotDisembarkBounds <- {}
	table end
	end.up <- 50.363811
	end.forward <- 110.146927
	end.right <- 13.045869
	end.yaw <- -8.381051

	table start
	start.up <- 156.750015
	start.forward <- -13.429688
	start.right <- -11.374998
	start.yaw <- 0.409042

	RefreshTitanEmbarkActions()

	level.pilotDisembarkBounds.end <- end
	level.pilotDisembarkBounds.start <- start

	RegisterSignal( "OnComplete" )
	RegisterSignal( "startembark" ) // temp

	RegisterSignal( "DisembarkingTitan" )
	RegisterSignal( "player_embarks_titan" )

	#if SERVER
		// add all the embark anims with this suffix
		AddEmbarkAnims( "titan_atlas", "atlas", true )
		AddEmbarkAnims( "titan_buddy", "buddy", true )
		AddEmbarkAnims( "titan_ogre", "ogre", true )
		AddEmbarkAnims( "titan_stryder", "stryder", true )

		//AddEmbarkAudio( "atlas" )
		//AddEmbarkAudio( "buddy" )
		//AddEmbarkAudio( "ogre" )
		//AddEmbarkAudio( "stryder" )

		RegisterSignal( "titanKneel" )
		RegisterSignal( "titanStand" )
		RegisterSignal( "titanEmbark" )
		RegisterSignal( "CancelEmbark" )
		RegisterSignal( "PhaseEmbarkPhaseStop" )

		RegisterSignal( "CockpitLightStop" )
		PrecacheParticleSystem( $"xo_cockpit_dlight" )

		//AddClientCommandCallback( "TitanDisembark", ClientCommand_TitanDisembark ) //
		//AddClientCommandCallback( "TitanKneel", ClientCommand_TitanKneel ) //
		//AddClientCommandCallback( "TitanStand", ClientCommand_TitanStand ) //
		//AddClientCommandCallback( "TitanNextMode", ClientCommand_TitanNextMode ) //
	#endif
}

void function OverrideCockpitLightFX( asset fx )
{
	file.cockpitLightFX = fx
}

void function AddEmbarkAnims( string titan, string titanSubClass, bool thirdPersonOnly = false )
{
	// anims are string-constructed from these types:
	array<string> Array =
	[
		"kneel_front",
		"kneel_behind",
		"kneel_right",
		"kneel_left",
		"kneel_airgrab",

		"stand_front",
		"stand_right",
		"stand_left",
		"stand_behind",
		"stand_airgrab",

		"above_right",
		"above_left",
		"kneel_above_right",
		"kneel_above_left",
	]


	// force consistency in animation names
	foreach ( item in Array )
	{
		array<string> suffixes = [ "", "_fast" ]
		foreach ( suffix in suffixes )
		{
			//printt( "Adding base " + item + " to " + titan )
			string thirdPersonAlias = "pt_mount_" + item + suffix
			string firstPersonAlias = "ptpov_mount_" + item + suffix
			string thirdPersonAnim = "pt_mount_" + titanSubClass + "_" + item + suffix
			string firstPersonAnim = "ptpov_mount_" + titanSubClass + "_" + item + suffix

			if ( thirdPersonOnly )
				firstPersonAnim = ""

			AddAnimAlias( titanSubClass, thirdPersonAlias, thirdPersonAnim )
			AddAnimAlias( titanSubClass, firstPersonAlias, firstPersonAnim )
		}
	}
}

void function AddEmbarkAudio( string titanSubClass )
{
	// audio files are string-constructed from these types:
	array<string> Array =
	[
		"Kneeling_Front",
		"Kneeling_Behind",
		"Kneeling_Right",
		"Kneeling_Left",
		"Kneeling_AboveRight",
		"Kneeling_AboveLeft",

		"Standing_Front",
		"Standing_Behind",
		"Standing_Airgrab",
		"Standing_AboveRight",
		"Standing_AboveLeft"
	]

	// force consistency in audio file names
	foreach ( item in Array )
	{
		//printt( "Adding base " + item + " to " + titan )
		string thirdPersonAlias = "Embark_" + item + "_3P"
		string firstPersonAlias = "Embark_" + item + "_1P"
		string thirdPersonAnim = titanSubClass + "_Embark_" + item + "_3P"
		string firstPersonAnim = titanSubClass + "_Embark_" + item + "_1P"

		AddAudioAlias( titanSubClass, thirdPersonAlias, thirdPersonAnim )
		AddAudioAlias( titanSubClass, firstPersonAlias, firstPersonAnim )
	}
}

void function RefreshTitanEmbarkActions()
{
	if ( "titanEmbarkActions" in level )
	{
		delete level.titanEmbarkActions
		delete level.titanEmbarkFarthestDistance
	}

	int groundDist = 260

	level.titanEmbarkActions <- []
	level.titanEmbarkFarthestDistance <- 0

	{
		table action

		action =
		{
			direction = <1,0,0>
			distance = groundDist
			embark = "front"
			minDot = 0.4
			priority = 1 // tried after priority 0 actions
			titanCanStandRequired = false
			//onGround = null // either
			useAnimatedRefAttachment = true
			alignFrontEnabled = true
			canSkipAhead = true

			animSet =
			{
				firstPersonKneelingAlias = "ptpov_mount_kneel_front"
				thirdPersonKneelingAlias = "pt_mount_kneel_front"
				firstPersonStandingAlias = "ptpov_mount_stand_front"
				thirdPersonStandingAlias = "pt_mount_stand_front"
				titanKneelingAnim = "at_mount_kneel_front"
				titanStandingAnim = "at_mount_stand_front"
			}

			audioSet =
			{
				firstPersonKneelingAudioAlias = "Embark_Kneeling_Front_1P"
				thirdPersonKneelingAudioAlias = "Embark_Kneeling_Front_3P"
				firstPersonStandingAudioAlias = "Embark_Standing_Front_1P"
				thirdPersonStandingAudioAlias = "Embark_Standing_Front_3P"
			}
		}
		level.titanEmbarkActions.append( action )

		action =
		{
			direction = <1,0,0>
			distance = groundDist
			embark = "front"
			minDot = -1
			priority = 2 // tried after priority 1 actions
			titanCanStandRequired = false
			//onGround = null // either
			useAnimatedRefAttachment = true
			alignFrontEnabled = true
			canSkipAhead = true

			animSet =
			{
				firstPersonKneelingAlias = "ptpov_mount_kneel_front"
				thirdPersonKneelingAlias = "pt_mount_kneel_front"
				firstPersonStandingAlias = "ptpov_mount_stand_front"
				thirdPersonStandingAlias = "pt_mount_stand_front"
				titanKneelingAnim = "at_mount_kneel_front"
				titanStandingAnim = "at_mount_stand_front"
			}

			audioSet =
			{
				firstPersonKneelingAudioAlias = "Embark_Kneeling_Front_1P"
				thirdPersonKneelingAudioAlias = "Embark_Kneeling_Front_3P"
				firstPersonStandingAudioAlias = "Embark_Standing_Front_1P"
				thirdPersonStandingAudioAlias = "Embark_Standing_Front_3P"
			}
		}
		level.titanEmbarkActions.append( action )

		action =
		{
			direction = <0,1,0>
			distance = groundDist
			embark = "left"
			minDot = 0.4
			priority = 1 // tried after priority 0 actions
			titanCanStandRequired = true
			useAnimatedRefAttachment = true
			alignFrontEnabled = true
			canSkipAhead = true
			//onGround = null // either

			animSet =
			{
				firstPersonKneelingAlias = "ptpov_mount_kneel_left"
				thirdPersonKneelingAlias = "pt_mount_kneel_left"
				firstPersonStandingAlias = "ptpov_mount_stand_front"
				thirdPersonStandingAlias = "pt_mount_stand_left"
				titanKneelingAnim = "at_mount_kneel_left"
				titanStandingAnim = "at_mount_stand_left"
			}

			audioSet =
			{
				firstPersonKneelingAudioAlias = "Embark_Kneeling_Left_1P"
				thirdPersonKneelingAudioAlias = "Embark_Kneeling_Left_3P"
				firstPersonStandingAudioAlias = "Embark_Standing_Front_1P"
				thirdPersonStandingAudioAlias = "Embark_Standing_Front_3P"
			}
		}
		level.titanEmbarkActions.append( action )

		action =
		{
			direction = <0,-1,0>
			distance = groundDist
			embark = "right"
			minDot = 0.4
			priority = 1 // tried after priority 0 actions
			titanCanStandRequired = true
			useAnimatedRefAttachment = true
			alignFrontEnabled = true
			canSkipAhead = true
			//onGround = null // either
			animSet =
			{
				firstPersonKneelingAlias = "ptpov_mount_kneel_right"
				thirdPersonKneelingAlias = "pt_mount_kneel_right"
				firstPersonStandingAlias = "ptpov_mount_stand_front"
				thirdPersonStandingAlias = "pt_mount_stand_right"
				titanKneelingAnim = "at_mount_kneel_right"
				titanStandingAnim = "at_mount_stand_right"
			}

			audioSet =
			{
				firstPersonKneelingAudioAlias = "Embark_Kneeling_Right_1P"
				thirdPersonKneelingAudioAlias = "Embark_Kneeling_Right_3P"
				firstPersonStandingAudioAlias = "Embark_Standing_Front_1P"
				thirdPersonStandingAudioAlias = "Embark_Standing_Front_3P"
			}
		}
		level.titanEmbarkActions.append( action )


		action =
		{
			direction = <-1,0,0>
			distance = groundDist
			embark = "behind"
			minDot = 0.4
			priority = 1 // tried after priority 0 actions
			titanCanStandRequired = true
			useAnimatedRefAttachment = true
			canSkipAhead = false
			//onGround = null // either

			animSet =
			{
				firstPersonKneelingAlias = "ptpov_mount_kneel_behind"
				thirdPersonKneelingAlias = "pt_mount_kneel_behind"
				firstPersonStandingAlias = "ptpov_mount_stand_behind"
				thirdPersonStandingAlias = "pt_mount_stand_behind"
				titanKneelingAnim = "at_mount_kneel_behind"
				titanStandingAnim = "at_mount_stand_behind"
			}

			audioSet =
			{
				firstPersonKneelingAudioAlias = "Embark_Kneeling_Behind_1P"
				thirdPersonKneelingAudioAlias = "Embark_Kneeling_Behind_3P"
				firstPersonStandingAudioAlias = "Embark_Standing_Behind_1P"
				thirdPersonStandingAudioAlias = "Embark_Standing_Behind_3P"
			}
		}
		level.titanEmbarkActions.append( action )

		action =
		{
			direction = <0,0,1> // 0 -1 1
			distance = 350
			embark = "above_close"
			minDot = 0.88
			canSkipAhead = false
			priority = 0 // priority actions are checked first

			titanCanStandRequired = true
			useAnimatedRefAttachment = true
			//onGround = false // must be in air

			animSets =
			{
				right =
				{
			 		direction = <0,-1,0> // 0 -1 1
					firstPersonKneelingAlias = "ptpov_mount_kneel_above_right"
					thirdPersonKneelingAlias = "pt_mount_kneel_above_right"
					firstPersonStandingAlias = "ptpov_mount_above_right"
					thirdPersonStandingAlias = "pt_mount_above_right"
					titanKneelingAnim = "at_mount_kneel_above"
					titanStandingAnim = "at_mount_above_right"

					audioSet =   //An annoying exception to how the audioSet is organized, better this than the alternative and having to find the "best audio set"
					{
						firstPersonKneelingAudioAlias = "Embark_Kneeling_AboveRight_1P"
						thirdPersonKneelingAudioAlias = "Embark_Kneeling_AboveRight_3P"
						firstPersonStandingAudioAlias = "Embark_Standing_AboveRight_1P"
						thirdPersonStandingAudioAlias = "Embark_Standing_AboveRight_3P"
					}
				}

				left =
				{
			 		direction = <0,1,0> // 0 -1 1
					firstPersonKneelingAlias = "ptpov_mount_kneel_above_left"
					thirdPersonKneelingAlias = "pt_mount_kneel_above_left"
					firstPersonStandingAlias = "ptpov_mount_above_left"
					thirdPersonStandingAlias = "pt_mount_above_left"
					titanKneelingAnim = "at_mount_kneel_above"
					titanStandingAnim = "at_mount_above_left"

					audioSet = //An annoying exception to how the audioSet is organized, better this than the alternative and having to find the "best audio set"
					{
						firstPersonKneelingAudioAlias = "Embark_Kneeling_AboveLeft_1P"
						thirdPersonKneelingAudioAlias = "Embark_Kneeling_AboveLeft_3P"
						firstPersonStandingAudioAlias = "Embark_Standing_AboveLeft_1P"
						thirdPersonStandingAudioAlias = "Embark_Standing_AboveLeft_3P"
					}
				}
			}
		}
		level.titanEmbarkActions.append( action )

		action =
		{
			direction = <0,0,1>
			distance = 275
			embark = "above_grab"
			minDot = 0.3
			titanCanStandRequired = true
			//onGround = null // false // must be in air
			useAnimatedRefAttachment = true
			//lungeCheck = true
			canSkipAhead = true

			alignFrontEnabled = true

			priority = 0 // priority actions are checked first

			animSet =
			{
				firstPersonKneelingAlias = "ptpov_mount_kneel_airgrab"
				thirdPersonKneelingAlias = "pt_mount_kneel_airgrab"
				titanKneelingAnim = "at_mount_kneel_airgrab"

				firstPersonStandingAlias = "ptpov_mount_stand_airgrab"
				thirdPersonStandingAlias = "pt_mount_stand_airgrab"
				titanStandingAnim = "at_mount_stand_airgrab"
			}

			audioSet =
			{
				firstPersonKneelingAudioAlias = "Embark_Kneeling_Front_1P"
				thirdPersonKneelingAudioAlias = "Embark_Kneeling_Front_3P"
				firstPersonStandingAudioAlias = "Embark_Standing_Front_1P"
				thirdPersonStandingAudioAlias = "Embark_Standing_Front_3P"
			}
		}
		level.titanEmbarkActions.append( action )
	}

	array<string> autoParms = [	"lungeCheck", "alignFrontEnabled" ]

	foreach ( action in level.titanEmbarkActions )
	{
		if ( action.distance > level.titanEmbarkFarthestDistance )
		{
			level.titanEmbarkFarthestDistance = action.distance
		}

		foreach ( parm in autoParms )
		{
			if ( !( parm in action ) )
				action[ parm ] <- false
		}
	}
}

#if SERVER
bool function ClientCommand_TitanKneel( entity player, array<string> args )
{
	entity titan = player.GetPetTitan()
	if ( !IsAlive( titan ) )
		return true

	titan.Signal( "titanKneel" )
	titan.s.standQueued = false
	return true
}

/*bool function ClientCommand_TitanStand( entity player, array<string> args )
{
	entity titan = player.GetPetTitan()
	if ( !IsAlive( titan ) )
		return true

	titan.Signal( "titanStand" )
	titan.s.standQueued = true
	titan.s.kneelQueued = false
	return true
}*/

bool function ClientCommand_TitanNextMode( entity player, array<string> args )
{
	if ( !IsAlive( player ) )
		return true

	entity titan = player.GetPetTitan()
	if ( IsAlive( titan ) )
		NPCTitanNextMode( titan, player )

	return true
}
#endif // SERVER


void function EmbarkLine( entity player, entity titan )
{
	player.EndSignal( "startembark" )
	int ref = player.LookupAttachment( "ref" )
	int hijack = titan.LookupAttachment( "hijack" )
	vector origin
	for ( ;; )
	{
		origin = titan.GetAttachmentOrigin( hijack )
		DebugDrawLine( player.GetOrigin(), origin, 255, 0, 0, true, 0.15 )

		origin = player.GetAttachmentOrigin( ref )
		DebugDrawLine( player.GetOrigin(), origin, 0, 255, 0, true, 0.15 )
		WaitFrame()
	}
}


#if SERVER
void function CodeCallback_EmbarkTitan( entity player, entity titan )
{
	if ( player.Lunge_IsActive() && (titan == player.Lunge_GetTargetEntity()) )
	{
		if ( PlayerCanImmediatelyEmbarkTitan( player, titan ) )
		{
			table embarkDirection = expect table( FindBestEmbark( player, titan ) )
			thread PlayerEmbarksTitan( player, titan, embarkDirection )
		}
	}
}

bool function CodeCallback_EmbarkTitanFromGrapple( entity player, entity titan )
{
	Assert( player.IsHuman() )
	Assert( titan.IsTitan() )

	if ( !PlayerCanEmbarkIntoTitan( player, titan ) )
		return false

	table ornull embarkDirection = expect table ornull( FindBestEmbark( player, titan, false ) )
	if ( !embarkDirection )
		return false

	expect table( embarkDirection )
	thread PlayerEmbarksTitan( player, titan, embarkDirection )

	return true
}

void function PlayerEmbarksTitan( entity player, entity titan, table embark )
{
	//player.SetOrigin( <314.971405,-1826.728638,116.031250> )
	//player.SetAngles( <0,133.945892,0> )
	//titan.SetOrigin( <284.887970,-1622.180542,112.093750> )
	//titan.SetAngles( <0,112.264252,0> )

	entity soul = titan.GetTitanSoul()
	string settings = GetSoulTitanSubClass( soul )
	printt( "TitanEmbarkDebug: Player ", player.GetOrigin(), player.GetAngles(), " Titan ", titan.GetOrigin(), titan.GetAngles(), settings, GetMapName() )


	Assert( IsAlive( titan ) )
	Assert( IsAlive( player ) )

	player.SetInvulnerable()

	player.EndSignal( "OnDeath" )
	player.EndSignal( "TitanEjectionStarted" )
	titan.EndSignal( "OnDeath" )

	titan.Signal( "player_embarks_titan" )
	player.Signal( "player_embarks_titan" )

	//Assert( !InSolid( titan ), titan + " is in solid" )

	DisableCloak( player )

	entity groundEntity = titan.GetGroundEntity()
	vector startOrigin = titan.GetGroundRelativePos()
	vector startAngles = titan.GetAngles()

	OnThreadEnd(
		function() : ( player, groundEntity, startOrigin, startAngles )
		{
			if ( IsValid( player ) )
			{
				player.SetCinematicEventFlags( player.GetCinematicEventFlags() & (~CE_FLAG_EMBARK) )
				TitanEmbark_PlayerCleanup( player )
				player.p.isEmbarking = false

				if ( IsAlive( player ) )
				{
					if ( player.IsTitan() ) //Defensive fix, sometimes in SP (when game is shutting down etc ) this can run without the player being alive
					{
						TitanEmbarkFailsafe( player, null, groundEntity, startOrigin )
						Remote_CallFunction_Replay( player, "ServerCallback_TitanEmbark" )
						LetTitanPlayerShootThroughBubbleShield( player )
					}
					else if ( !player.p.embarkCancelled )
					{
						player.Die() //Defensive fix, sometimes in SP (when game is shutting down etc ) this can run without the player being alive
					}
				}
			}
		}
	)

	// track the embarking player so we can kill him if the titan dies
	titan.s.embarkingPlayer <- player
	player.p.isEmbarking = true
	player.SetCinematicEventFlags( player.GetCinematicEventFlags() | CE_FLAG_EMBARK )

	foreach ( func in svGlobal.onPilotEmbarkingTitanCallbacks )
	{
		func( player, titan )
	}

	waitthread PlayerEmbarksTitan_PlayerBecomesTitan( player, titan, embark )
}

void function PlayerEmbarksTitan_PlayerBecomesTitan( entity player, entity titan, table embark )
{
	// a place to store the player finish time
	table e

	e.threads <- 0
	e.embarkAction <- embark.action
	e.animSet <- embark.animSet
	e.audioSet <- embark.audioSet

	e.canStand <- TitanCanStand( titan )

	e.shouldDoRegularEmbark <- ShouldDoRegularEmbark( titan )

	// player and titan do their anims and wait for each other to finish
	thread TitanEmbark_TitanEmbarks( player, titan, e )
	waitthread TitanEmbark_PlayerEmbarks( player, titan, e )
}

bool function ShouldDoRegularEmbark( entity titan )
{
	return true
}

bool function TitanHasLeftAndRightEmbarkAnims( entity titan )
{
	entity soul = titan.GetTitanSoul()
	asset settings = GetSoulPlayerSettings( soul )
	return GetGlobalSettingsBool( settings, "hasLeftRightEmbarks" )
}

void function TitanEmbark_PlayerCleanup( entity player )
{
	player.SetSyncedEntity( null )
	DeployViewModelAndEnableWeapons( player )
	player.UnforceStand()
	player.UnforceCrouch()
	//printt( "Clearing invulnerable" )
	player.ClearInvulnerable()
	player.ClearParent()
	//Let player jump in air after getting out if he wants to
	player.TouchGround()
	player.Anim_Stop()
}

void function ForceScriptedEmbark( entity player, entity titan )
{
	HolsterViewModelAndDisableWeapons( player )
	ClearPlayerAnimViewEntity( player )
	player.ClearParent()
	PilotBecomesTitan( player, titan )

	thread PlayAnim( player, "cqb_idle_mp" )
	player.Anim_Stop()

	player.SetOrigin( titan.GetOrigin() )
	vector angles = titan.GetAngles()
	angles.z = 0
	angles.x = 0
	player.SetAngles( angles )
	player.SnapEyeAngles( angles )

	SetStanceStand( player.GetTitanSoul() )

	TitanEmbark_PlayerCleanup( player )
	if ( player.ContextAction_IsBusy() )
		player.ContextAction_ClearBusy()

	ScreenFadeFromBlack( player, EMBARK_FADE_TIME, EMBARK_FADE_TIME )
}

void function TitanEmbarkFailsafe( entity player, entity titan, entity groundEnt, vector startOrigin )
{
	if ( GetCurrentPlaylistVarInt( "player_embark_in_solid_checks", 1 ) != 1 )
		return

	#if DEVELOPER
		if ( file.embarkDebugPrint )
		{
			if ( IsValid( titan ) )
				printt( "TitanEmbarkFailsafe, before PutEntityInSafeSpot: player origin: " + player.GetOrigin() + ", titan origin: " + titan.GetOrigin() + " safeStartPoint: " + startOrigin )
			else
				printt( "TitanEmbarkFailsafe, before PutEntityInSafeSpot: player origin: " + player.GetOrigin() + ", null titan, safeStartPoint: " + startOrigin )
		}
	#endif

	if ( !PutEntityInSafeSpot( player, titan, groundEnt, startOrigin, player.GetOrigin() ) )
		player.SetOrigin( startOrigin )

	#if DEVELOPER
		if ( file.embarkDebugPrint )
		{
			if ( IsValid( titan ) )
				printt( "TitanEmbarkFailsafe, after PutEntityInSafeSpot: player origin: " + player.GetOrigin() + ", titan origin: " + titan.GetOrigin() + " safeStartPoint: " + startOrigin )
			else
				printt( "TitanEmbarkFailsafe, after PutEntityInSafeSpot: player origin: " + player.GetOrigin() + ", null titan, safeStartPoint: " + startOrigin )
		}
	#endif
}

void function TitanEmbark_PlayerEmbarks( entity player, entity titan, table e )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "TitanEjectionStarted" )
	titan.EndSignal( "OnDeath" )

	e.threads++
	OnThreadEnd(
		function() : ( player, e )
		{
			if ( IsValid( player ) )
			{
				// ensure these are cleared regardless
				ClearPlayerAnimViewEntity( player )

				if ( player.ContextAction_IsBusy() )
					player.ContextAction_ClearBusy()
			}

			e.threads--
			if ( !e.threads )
			{
				Signal( e, "OnComplete" )
			}
		}
	)

    player.ContextAction_SetBusy()

	bool standing = false

	if ( e.canStand )
	{
		if ( e.shouldDoRegularEmbark )
		{
			player.ForceStand()
			switch ( titan.GetTitanSoul().GetStance() )
			{
				case STANCE_KNEELING:
				case STANCE_KNEEL:
					standing = false
					break

				default:
					standing = true
					break
			}
		}
		else
		{
			standing = false
		}
	}
	else
	{
		player.ForceCrouch()
	}

	HolsterViewModelAndDisableWeapons( player )

	FirstPersonSequenceStruct sequence
	sequence.attachment = "hijack"
	sequence.useAnimatedRefAttachment = expect bool( e.embarkAction.useAnimatedRefAttachment )
	sequence.blendTime = 0.5

	entity soul = titan.GetTitanSoul()
	string settings = GetSoulTitanSubClass( soul )

	bool hasViewCone

	// string thirdPersonAudio
	// string firstPersonAudio

	if ( standing )
	{
		sequence.firstPersonAnim = GetAnimFromAlias( settings, expect string( e.animSet.firstPersonStandingAlias ) )
		sequence.thirdPersonAnim = GetAnimFromAlias( settings, expect string( e.animSet.thirdPersonStandingAlias ) )
		hasViewCone = false
		// thirdPersonAudio = GetAudioFromAlias( settings, e.audioSet.thirdPersonStandingAudioAlias )
		// firstPersonAudio = GetAudioFromAlias( settings, e.audioSet.firstPersonStandingAudioAlias )
	}
	else
	{
		sequence.firstPersonAnim = GetAnimFromAlias( settings, expect string( e.animSet.firstPersonKneelingAlias ) )
		sequence.thirdPersonAnim = GetAnimFromAlias( settings, expect string( e.animSet.thirdPersonKneelingAlias ) )
		hasViewCone = true
		// thirdPersonAudio = GetAudioFromAlias( settings, e.audioSet.thirdPersonKneelingAudioAlias )
		// firstPersonAudio = GetAudioFromAlias( settings, e.audioSet.firstPersonKneelingAudioAlias )
	}

	sequence.thirdPersonAnimIdle = "pt_mount_idle"

	bool doFirstPersonAnim = true

	if ( sequence.firstPersonAnim == "" )
	{// if there is no first person anim, then there must be a third person camera
		sequence.thirdPersonCameraAttachments.append( "VDU" )
		sequence.thirdPersonCameraVisibilityChecks = true
		doFirstPersonAnim = false
	}

	if ( hasViewCone )
	{
		sequence.viewConeFunction = EmbarkViewCone
		thread DelayedClearViewCone( player )
	}

	//thread DelayedDisableEmbarkPlayerHud( player, sequence )

	AddAnimEvent( titan, "cockpit_light_start", CockpitLightStart )
	AddAnimEvent( titan, "cockpit_light_stop", CockpitLightStop )

	player.p.embarkCancelled = false
	player.p.allowCancelEmbark = true

	OnThreadEnd(
	function() : ( player, titan )
		{
			bool embarkCancelled = false

			if ( IsValid( player ) )
			{
				embarkCancelled = player.p.embarkCancelled
				Signal( player, "PhaseEmbarkPhaseStop" )
				DeleteAnimEvent( player, "phase_shift_start" )
				DeleteAnimEvent( player, "phase_shift_stop" )
			}

			if ( IsAlive( titan ) && !embarkCancelled ) //Consider clearing titan.s.embarkingPlayer here?
			{
				titan.Die()
			}
			else if ( IsValid( titan ) )
			{
				CockpitLightStop( titan )
				DeleteAnimEvent( titan, "cockpit_light_start" )
				DeleteAnimEvent( titan, "cockpit_light_stop" )
			}
		}
	)

	thread FirstPersonSequence( sequence, player, titan )
	// EmitDifferentSoundsOnEntityForPlayerAndWorld( firstPersonAudio, thirdPersonAudio, titan, player )

	float animDuration = player.GetSequenceDuration( sequence.thirdPersonAnim )

	if ( ShouldSkipAheadIntoEmbark( standing, player, titan, e ) )
	{
		float duration = player.GetSequenceDuration( sequence.thirdPersonAnim )
		if ( duration >= SKIP_AHEAD_TIME )
		{
			player.Anim_SetInitialTime( duration - SKIP_AHEAD_TIME )
			entity viewModel = player.GetFirstPersonProxy()

			if ( IsValid( viewModel ) && EntHasModelSet( viewModel ) && doFirstPersonAnim ) //JFS: Defensive fix for player not having view models sometimes
				viewModel.Anim_SetInitialTime( duration - SKIP_AHEAD_TIME )

			animDuration = SKIP_AHEAD_TIME
		}
	}

	thread Embark_DelayedFadeOut( player, titan, animDuration )

	WaittillAnimDone( player )

	Signal( player, "PhaseEmbarkPhaseStop" )
	ClearPlayerAnimViewEntity( player )

	if ( !player.p.embarkCancelled )
	{
		PilotBecomesTitan( player, titan )

		thread PlayAnim( player, "cqb_idle_mp" )
		player.Anim_Stop()
		player.SetVelocity( <0,0,0> )

		player.SetOrigin( titan.GetOrigin() )
		vector angles = titan.GetAngles()
		angles.z = 0
		angles.x = 0
		player.SetAngles( angles )
		player.SnapEyeAngles( angles )

		// soul stuff should be from anim event
		Assert( IsServer() )
		SetStanceStand( player.GetTitanSoul() )
		titan.Destroy()
	}
}

void function CancelEmbark( entity player )
{
	if ( !IsPlayerEmbarking( player ) )
		return

	if ( !player.p.allowCancelEmbark )
		return

	player.p.embarkCancelled = true
	player.Signal( "CancelEmbark" )
	player.Signal( "ScriptAnimStop" )
	player.Anim_Stop()
}

void function Embark_DelayedFadeOut( entity player, entity titan, float delay )
{
	if ( !IsAlive( player ) )
		return

	if ( !IsValid( titan ) )
		return

	player.EndSignal( "OnDeath" )
	player.EndSignal( "CancelEmbark" )
	titan.EndSignal( "OnDestroy" )

	wait delay - EMBARK_FADE_TIME

	player.p.allowCancelEmbark = false

	ScreenFadeToBlack( player, EMBARK_FADE_TIME, EMBARK_FADE_TIME + 0.2 ) // a little extra so we stay black
	wait EMBARK_FADE_TIME
	ScreenFadeFromBlack( player, EMBARK_FADE_TIME, EMBARK_FADE_TIME )
}

void function PlayStartupSounds( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	entity player = soul.GetBossPlayer()
	if ( !IsValid( player ) )
		return

	player.EndSignal( "OnDeath" )

	asset titanSettings = GetSoulPlayerSettings( soul )
	string startupSound = GetGlobalSettingsString( titanSettings, "startup_sound" )

	if ( startupSound != "" )
		EmitSoundOnEntityOnlyToPlayer( player, player, startupSound )
}


void function CockpitLightStart( entity titan )
{
	thread StartCockpitLightThink( titan, 5.0 )
}

void function StartCockpitLightThink( entity titan, float timeout )
{
	titan.EndSignal( "OnDestroy" )
	titan.EndSignal( "CockpitLightStop" )

	int attachID = titan.LookupAttachment( "HIJACK" )
	int fxID = GetParticleSystemIndex( file.cockpitLightFX )
	entity fx = StartParticleEffectOnEntity_ReturnEntity( titan, fxID, FX_PATTACH_POINT_FOLLOW, attachID )

	OnThreadEnd(
	function() : ( fx )
		{
			if ( IsValid( fx ) )
				EffectStop( fx )
		}
	)

	if ( timeout < 0 )
		WaitForever()
	else
		wait timeout
}

void function CockpitLightStop( entity titan )
{
	titan.Signal( "CockpitLightStop" )
}

bool function ShouldSkipAheadIntoEmbark( bool standing, entity player, entity titan, e )
{
	if ( !standing )
		return false

	if ( !e.embarkAction.canSkipAhead )
		return false

	vector playerEye = player.EyePosition()
	vector titanOrg = titan.GetOrigin()
	vector vec = playerEye - titanOrg
	vec.Norm()
	vec.z = 0
	vector start = playerEye
	vector end = playerEye + vec * 24

	if ( Distance( player.GetOrigin(), titan.GetOrigin() ) >= 145 )
		return false

	int mask = TRACE_MASK_PLAYERSOLID
	TraceResults result = TraceLine( start, end, [ titan, player ], mask, TRACE_COLLISION_GROUP_NONE )
	//DebugDrawLine( start, result.endPos, 0, 255, 0, true, 10.0 )
	//DebugDrawLine( result.endPos, end, 255, 0, 0, true, 10.0 )
	return result.fraction < 1.0
}
#endif // SERVER

void function DelayedDisableEmbarkPlayerHud( entity player, FirstPersonSequenceStruct sequence )
{
	player.EndSignal( "OnDeath" )

	float duration = player.GetSequenceDuration( sequence.thirdPersonAnim )
	wait duration - 1.0
	player.SetCinematicEventFlags( player.GetCinematicEventFlags() | CE_FLAG_EMBARK )
}

#if SERVER
void function DelayedClearViewCone( entity player )
{
	player.EndSignal( "OnDeath" )
	wait 1.0
	player.PlayerCone_SetLerpTime( 0.5 )
	player.PlayerCone_FromAnim()
	player.PlayerCone_SetMinYaw( 0 )
	player.PlayerCone_SetMaxYaw( 0 )
	player.PlayerCone_SetMinPitch( 0 )
	player.PlayerCone_SetMaxPitch( 0 )
}

void function EmbarkViewCone( entity player )
{
	player.PlayerCone_FromAnim()
	player.PlayerCone_SetMinYaw( -70 )
	player.PlayerCone_SetMaxYaw( 60 )
	player.PlayerCone_SetMinPitch( -80 )
	player.PlayerCone_SetMaxPitch( 30 )
}

void function TitanEmbark_TitanEmbarks( entity player, entity titan, table e )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "TitanEjectionStarted" )
	player.EndSignal( "CancelEmbark" )
	titan.EndSignal( "OnDeath" )

	titan.ContextAction_SetBusy()

	AddAnimEvent( titan, "play_startup_sound", PlayStartupSounds )

	e.threads++
	OnThreadEnd(
		function() : ( e, player, titan )
		{
			e.threads--
			if ( !e.threads )
			{
				Signal( e, "OnComplete" )
			}

			if ( (!IsAlive( player ) || player.p.embarkCancelled ) && IsAlive( titan ) )
			{
				titan.Anim_Stop()
				titan.ContextAction_ClearBusy()
				delete titan.s.embarkingPlayer
				DeleteAnimEvent( titan, "play_startup_sound" )
			}
		}
	)

	// dont let other players get in

	string animation
	//bool waittillAnimDone
	bool alignFront
	bool standing = false

	if ( e.canStand )
	{
		if ( e.shouldDoRegularEmbark )
		{
			// default
			switch ( titan.GetTitanSoul().GetStance() )
			{
				case STANCE_KNEELING:
				case STANCE_KNEEL:
					animation = expect string( e.animSet.titanKneelingAnim )
					alignFront = false
					break

				default:
					animation = expect string( e.animSet.titanStandingAnim )
					if ( TitanHasLeftAndRightEmbarkAnims( titan ) )
						alignFront = false
					else
						alignFront = true
					standing = true
					break
			}
		}
		else
		{
			// special for BT if he is in casual mode
			animation = expect string( e.animSet.titanKneelingAnim )
			alignFront = false
		}
	}
	else
	{
		animation = "at_mount_kneel_without_standing"
		alignFront = false
		//waittillAnimDone = false
	}

	//sequence.blendTime = 0.5

    printt( "This is mount animation name: " + animation )
	if ( e.embarkAction.alignFrontEnabled && alignFront )
	{
		vector titanOrg = titan.GetOrigin()
		vector vec = player.GetOrigin() - titanOrg
		vector angles = VectorToAngles( vec )
		angles.x = 0
		angles.z = 0
		thread PlayAnimGravityClientSyncing( titan, animation, titanOrg, angles )
	}
	else
	{
		thread PlayAnimGravityClientSyncing( titan, animation )
	}

	if ( ShouldSkipAheadIntoEmbark( standing, player, titan, e ) )
	{
		float duration = titan.GetSequenceDuration( animation )

		if ( duration >= SKIP_AHEAD_TIME ) // failsafe
			titan.Anim_SetInitialTime( duration - SKIP_AHEAD_TIME )
	}

	// titan will become player now
	WaitForever()
}

//bool function ClientCommand_TitanDisembark( entity player, array<string> args )
//{
//	if ( !PlayerCanDisembarkTitan( player ) )
//		return true
//
//	ScreenFade( player, 0, 1, 0, 255, 0.2, 0.2, FFADE_IN | FFADE_PURGE )
//	player.CockpitStartDisembark()
//	Remote_CallFunction_Replay( player, "ServerCallback_TitanDisembark" )
//	thread PlayerDisembarksTitan( player )
//
//	return true
//}

//void function ForcedTitanDisembark( entity player )
//{
//	Assert( PlayerCanDisembarkTitan( player ) )
//
//	player.CockpitStartDisembark()
//	Remote_CallFunction_Replay( player, "ServerCallback_TitanDisembark" )
//
//	waitthread PlayerDisembarksTitan( player )
//}

//void function ForcedTitanDisembarkCustomAnims( entity player, FirstPersonSequenceStruct functionref( entity, entity ) playerSequenceFunc, FirstPersonSequenceStruct functionref( entity, entity ) titanSequenceFunc )
//{
//	Assert( PlayerCanDisembarkTitan( player ) )
//
//	player.CockpitStartDisembark()
//	Remote_CallFunction_Replay( player, "ServerCallback_TitanDisembark" )
//
//	player.p.isCustomDisembark = true
//	waitthread PlayerDisembarksTitanWithSequenceFuncs( player, playerSequenceFunc, titanSequenceFunc )
//	player.p.isCustomDisembark = false
//}
#endif // SERVER

//bool function PlayerCanDisembarkTitan( entity player )
//{
//	if ( !player.IsTitan() )
//		return false
//
//	if ( !IsAlive( player ) )
//		return false
//
//	if ( IsValid( player.GetParent() ) )
//		return false
//
//	if ( Riff_TitanExitEnabled() == eTitanExitEnabled.Never )
//		return false
//
//	if ( !CanDisembark( player ) )
//		return false
//
//	#if SERVER
//		if ( player.IsNoclipping() )
//			return false
//		// client doesn't know these things
//		if ( IsPlayerDisembarking( player ) )
//			return false
//		if ( IsPlayerEmbarking( player ) )
//			return false
//	#endif
//
//	if ( !HasSoul( player ) )
//		return false
//
//	entity soul = player.GetTitanSoul()
//	if ( soul.IsEjecting() )
//		return false
//
//	Assert( soul == player.GetTitanSoul() )
//
//	return true
//}

#if SERVER
//void function PlayerDisembarksTitan( entity player )
//{
//	PlayerDisembarksTitanWithSequenceFuncs( player, GetDisembarkSequenceForPlayer, GetDisembarkSequenceForTitan )
//}

//void function PlayerDisembarksTitanWithSequenceFuncs( entity player, FirstPersonSequenceStruct functionref( entity, entity ) playerSequenceFunc, FirstPersonSequenceStruct functionref( entity, entity ) titanSequenceFunc )
//{
//	//printt( "Player disembarking with origin " + player.GetOrigin() + " and yaw " + player.GetAngles().y )
//
//  	//player.SetOrigin( <420.847626,-5214.960938,173.789520> )
//  	//player.SetAngles( <0,179.572052,0> )
//
//	printt( "TitanDisembarkDebug: Player ", player.GetOrigin(), player.GetAngles(), GetMapName() )
//
//	player.EndSignal( "OnDeath" )
//	player.Signal( "DisembarkingTitan" )
//
//	//Assert( !InSolid( player ), player + " is in solid" )
//
//	table e
//	e.titan <- null
//	e.pilotCleanUpDone <- false
//	e.startOrigin <- player.GetOrigin()
//	//e.startAngles <- player.GetAngles()
//
//	player.p.isDisembarking = true
//	player.SetCinematicEventFlags( player.GetCinematicEventFlags() | CE_FLAG_DISEMBARK )
//
//	bool wasCustomDisembark = player.p.isCustomDisembark
//
//	player.ContextAction_SetBusy()
//
//	OnThreadEnd(
//		function() : ( player, e )
//		{
//			if ( IsValid( player ) )
//			{
//				PlayerEndsDisembark( player, e )
//
//				entity titan = expect entity( e.titan )
//				if ( !IsValid( titan ) )
//					titan = null
//			}
//
//			if ( IsAlive( expect entity( e.titan ) ) )
//			{
//				if ( IsAlive( player ) )
//				{
//					thread PlayerOwnsTitanUntilSeparation( player, expect entity( e.titan ), 80 )
//				}
//
//				delete e.titan.s.disembarkingPlayer
//				// ClearInvincible( expect entity( e.titan ) )
//
//
//				//Make Titan get up immediately if he's kneeling and can stand
//				//If he can't get up, well, then since the titan doesn't move when crouched he's going to be stuck...
//				if ( !( "embarkingPlayer" in e.titan.s ) )
//				{
//					thread TitanNPC_Think( expect entity( e.titan ) ) //titan.s.disableAutoTitanConversation is deleted inside here
//				}
//			}
//		}
//	)
//
//	bool standing = player.IsStanding()
//
//	player.SetInvulnerable()
//	player.SnapFeetToEyes()
//
//	entity titan = CreateAutoTitanForPlayer_ForTitanBecomesPilot( player )
//	DispatchSpawn( titan )
//	e.titan = titan
//
//	if ( !PlayerIsFarOffTheGround( player, [ player,titan ] ) ) //PlayerIsFarOffTheGround() necessary now for R2 because we have Titans that can jump/geo where Titans can fall down from large heights. Without check, mid-air disembarking will cause player to be teleported to the ground
//	{
//		vector ornull clampedPos = NavMesh_ClampPointForAIWithExtents( titan.GetOrigin(), titan, file.smallDisembarkFailSafeTeleportVector )
//		if ( clampedPos == null )
//			clampedPos = NavMesh_ClampPointForAIWithExtents( titan.GetOrigin(), titan, file.largeDisembarkFailSafeTeleportVector )
//
//		if ( clampedPos != null )
//		{
//			expect vector( clampedPos )
//			vector titanOrigin = titan.GetOrigin()
//
//			array<entity> ignoreEnts = [ titan ]
//			TraceResults result = TraceHull( titanOrigin, titanOrigin, titan.GetBoundingMins(), titan.GetBoundingMaxs(), ignoreEnts, TRACE_MASK_TITANSOLID, TRACE_COLLISION_GROUP_NONE )
//
//			// expensive checks to make sure titan doesn't teleport to navmesh on other side of wall usually in invalid places
//			if ( result.startSolid ||
//				 TraceLineSimple( titanOrigin + <0,0,128>, clampedPos + <0,0,0>, titan ) == 1.0 ||
//			     TraceLineSimple( titanOrigin + <0,0,200>, clampedPos + <0,0,0>, titan ) == 1.0 ||
//			     TraceLineSimple( titanOrigin + <0,0,200>, clampedPos + <0,0,128>, titan ) == 1.0 )
//			{
//				#if DEVELOPER
//					if ( file.embarkDebugPrint )
//					{
//						printt( "PlayerDisembarksTitanWithSequenceFuncs, player origin: " + player.GetOrigin()+ ", titan origin: " + titan.GetOrigin() + ", clampedPos: " + clampedPos )
//					}
//				#endif
//				titan.SetOrigin( clampedPos )
//				titan.ForceCheckGroundEntity()
//			}
//		}
//	}
//	else
//	{
//		#if DEVELOPER
//			if ( file.embarkDebugPrint )
//			{
//				printt( "PlayerIsFarOffGround() returned true, skip doing NavMesh_ClampPointForAIWithExtents checks" )
//			}
//		#endif
//	}
//
//	titan.s.disembarkingPlayer <- player
//	titan.EndSignal( "OnDeath" )
//
//	player.SetSyncedEntity( titan )
//	titan.e.disableAutoTitanConversation = true
//
//	Assert( titan.IsTitan() )
//	Assert( IsAlive( player ) )
//	Assert( player.IsTitan() )
//	//Set player to be temporarily invulnerable. Will be removed at end of animation
//	//printt( "Set player invulnerable" )
//	HolsterViewModelAndDisableWeapons( player )  //Holstering weapon before becoming pilot so we don't play the holster animation as a pilot. Player as Titan won't play the holster animation either since it'll be interrupted by the disembark animation
//
//	TitanBecomesPilot( player, titan )
//
//	string titanSubClass = GetSoulTitanSubClass( titan.GetTitanSoul() )
//	switch ( titanSubClass )
//	{
//		case "ogre":
//			ShowMainTitanWeapons( titan ) //JFS: Because we hide the Titan's weapons upon kneeling for ogre
//			break
//	}
//
//	titan.s.disembarkTime <- Time() // disembark debounce
//
//	// compound strings into these animations:
//	// pt_dismount_atlas_stand
//	// pt_dismount_ogre_stand
//	// pt_dismount_stryder_stand
//	// pt_dismount_atlas_crouch
//	// pt_dismount_ogre_crouch
//	// pt_dismount_stryder_crouch
//	// ptpov_dismount_atlas_stand
//	// ptpov_dismount_ogre_stand
//	// ptpov_dismount_stryder_stand
//	// ptpov_dismount_atlas_crouch
//	// ptpov_dismount_ogre_crouch
//	// ptpov_dismount_stryder_crouch
//
//	FirstPersonSequenceStruct playerSequence = playerSequenceFunc( player, titan )
//	FirstPersonSequenceStruct titanSequence = titanSequenceFunc( player, titan )
//
//	#if SERVER
//		StatusEffect_StopAllOfType( player, eStatusEffect.lockon_detected_titan )
//	#endif
//
//	player.ForceStand()
//	player.IgnoreEntityForMovementUntilNotTouching( titan )
//
//	thread FirstPersonSequence( titanSequence, titan )
//	thread FirstPersonSequence( playerSequence, player, titan )
//
//	if ( !wasCustomDisembark )
//		thread ClearParentBeforeIntersect( player, titan, e )
//
//	if ( !standing )
//	{
//		SetStanceKneel( titan.GetTitanSoul() )
//	}
//
//	//player.Anim_EnablePlanting()
//
//	WaittillAnimDone( player )
//}

bool function PlayerIsFarOffTheGround( entity player, array<entity> ignoreEnts )
{
	vector boundingMaxs = player.GetBoundingMaxs()
	float halfHeight =  boundingMaxs.z / 2.0

	vector startpos = player.GetOrigin()
	vector endpos = startpos
	endpos.z -= halfHeight

	TraceResults result = TraceHull( startpos, endpos, player.GetBoundingMins(), player.GetBoundingMaxs(), ignoreEnts, TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER )
	//PrintTraceResults( result )

	if ( result.startSolid )
		return false

	if ( result.allSolid )
		return false

	return ( result.fraction >= 1.0 )
}

FirstPersonSequenceStruct function GetDisembarkSequenceForPlayer( entity player, entity titan )
{
	string titanSubClass = GetSoulTitanSubClass( titan.GetTitanSoul() )

	string player3pAnim, player1pAnim
	if ( player.IsStanding() )
	{
		player3pAnim = "pt_dismount_" + titanSubClass + "_stand"
		player1pAnim = "ptpov_dismount_" + titanSubClass + "_stand"
	}
	else
	{
		player3pAnim = "pt_dismount_" + titanSubClass + "_crouch"
		player1pAnim = "ptpov_dismount_" + titanSubClass + "_crouch"
	}

	if ( PlayerHasFastEmbark( player ) )
	{
		player1pAnim += "_fast"
		player3pAnim += "_fast"
	}

	FirstPersonSequenceStruct playerSequence
	playerSequence.blendTime = 0
	playerSequence.teleport = true
	playerSequence.attachment = "hijack"
	playerSequence.thirdPersonAnim = player3pAnim
	playerSequence.firstPersonAnim = player1pAnim
	playerSequence.useAnimatedRefAttachment = true

	return playerSequence
}

FirstPersonSequenceStruct function GetDisembarkSequenceForTitan( entity player, entity titan )
{
	bool standing = player.IsStanding()

	string titanDisembarkAnim
	if ( standing )
		titanDisembarkAnim = "at_dismount_stand"
	else
		titanDisembarkAnim = "at_dismount_crouch"

	if ( PlayerHasFastEmbark( player ) )
		titanDisembarkAnim += "_fast"

	vector origin = titan.GetOrigin()
	vector angles = titan.EyeAngles()
	angles.z = 0
	angles.x = 0

	FirstPersonSequenceStruct titanSequence
	titanSequence.blendTime = 0.3
	titanSequence.thirdPersonAnim = titanDisembarkAnim
	if ( !standing )
		titanSequence.thirdPersonAnimIdle = "at_MP_embark_idle_blended"
	titanSequence.gravity = true
	titanSequence.origin = origin
	titanSequence.angles = angles

	return titanSequence
}

void function DelayedSafePlayerLocationForDisembark( entity player, entity titan )
{
	float currentTime = Time()
	float allowedTime = player.p.isCustomDisembark ? 10.0 : 2.0

	player.EndSignal( "OnDestroy" )

	while ( IsPlayerDisembarking( player ) )
	{
		Assert( Time() - currentTime < allowedTime ) // Failsafe of waiting 2 seconds in case SOMETHING REALLY GOES WRONG.
		if ( !IsAlive( player ) )
			return

		WaitFrame()
	}

	if ( player.ContextAction_IsActive() ) //Immediately after disembarking player might have gotten pulled into another context action e.g. embarking into evac dropship
		return

	player.ClearParent()
	player.PlayerCone_Disable()
	player.ViewOffsetEntity_Clear()
	player.GetFirstPersonProxy().HideFirstPersonProxy()

	vector safeStartPoint

	if ( IsValid( titan ) )
	{
		vector titanBoundingMaxs = titan.GetBoundingMaxs()
		float halfTitanHeight = titanBoundingMaxs.z * 0.5
		safeStartPoint = titan.GetOrigin() + < 0, 0, halfTitanHeight > //Let the start point of PutEntityInSafeSpot be closer to where the player is when disebmarking instead of the ground origin
	}
	else
	{
		titan = null
		safeStartPoint = player.GetOrigin()
	}

	#if DEVELOPER
		if ( file.embarkDebugPrint )
			printt( "DelayedSafePlayerLocationForDisembark, before PutEntityInSafeSpot: player origin: " + player.GetOrigin() + ", titan origin: " + titan.GetOrigin() + " safeStartPoint: " + safeStartPoint )
	#endif



	if ( !PutEntityInSafeSpot( player, titan, null, safeStartPoint, player.GetOrigin() ) )
		player.SetOrigin( safeStartPoint )

	#if DEVELOPER
		if ( file.embarkDebugPrint )
			printt( "DelayedSafePlayerLocationForDisembark, after PutEntityInSafeSpot: player origin: " + player.GetOrigin() + ", titan origin: " + titan.GetOrigin() + " safeStartPoint: " + safeStartPoint )
	#endif
}

void function ClearParentBeforeIntersect( entity player, entity titan, table e )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnAnimationDone" )
	player.EndSignal( "OnAnimationInterrupted" )
	//vector mins = player.GetBoundingMins()
	//vector maxs = player.GetBoundingMaxs()

	OnThreadEnd(
		function() : ( player, e )
		{
			if ( IsValid( player ) )
				thread DelayedSafePlayerLocationForDisembark( player, expect entity( e.titan ) )
		}
	)

	wait 0.25

	vector lastOrigin = player.GetOrigin()
	for ( ;; )
	{
		if ( EntityInSolid( player, titan, 24 ) )
			break

		lastOrigin = player.GetOrigin()
		WaitFrame()
	}

	player.SetAbsOrigin( lastOrigin )
}

void function LockedViewCone( entity human )
{
	human.PlayerCone_FromAnim()
	human.PlayerCone_SetMinYaw( 0 )
	human.PlayerCone_SetMaxYaw( 0 )
	human.PlayerCone_SetMinPitch( 0 )
	human.PlayerCone_SetMaxPitch( 0 )
}

void function PlayerOwnsTitanUntilSeparation( entity player, entity titan, int dist )
{
	titan.SetOwner( player )

	player.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDeath" )

	OnThreadEnd(
		function () : ( player, titan )
		{
			if ( !IsValid( titan ) )
				return

			titan.SetOwner( null )
		}
	)

	// wait until player moves away
	int distSqr = dist * dist
	for ( ;; )
	{
		if ( DistanceSqr( titan.GetOrigin(), player.GetOrigin() ) > distSqr )
			break

		wait 0.5
	}
}

void function PlayerEndsDisembark( entity player, table e )
{
	thread PlayerEndsDisembarkThread( player, e )
}

void function PlayerEndsDisembarkThread( entity player, table e )
{
	player.EndSignal( "OnDestroy" )

	if ( e.pilotCleanUpDone )
		return

	e.pilotCleanUpDone = true
	bool wasCustomDisembark = player.p.isCustomDisembark

	wait 0.1

	ClearPlayerAnimViewEntity( player )
	if ( player.ContextAction_IsBusy() )
		player.ContextAction_ClearBusy()

	player.SetCinematicEventFlags( player.GetCinematicEventFlags() & (~CE_FLAG_DISEMBARK) )

	player.Show()
	TitanEmbark_PlayerCleanup( player )
	player.p.isDisembarking = false

	//// give a player a boost out the door
    //
    //
	if ( IsAlive( player ) && !wasCustomDisembark )
	{
		vector angles = player.EyeAngles()
		if ( IsValid( e.titan ) )
			angles = expect entity( e.titan ).GetAngles()

		angles.x = 0
		angles.z = 0
		vector forward = AnglesToForward( angles )
		vector up = AnglesToUp( angles )
		vector vel = forward * 300 + up * 250
		player.SetVelocity( vel )
		//DebugDrawLine( player.GetOrigin(), player.GetOrigin() + forward * 500, 255, 0, 0, true, 5.0 )
	}
}

bool function IsPlayerEmbarking( entity player )
{
	return player.p.isEmbarking
}
#endif // SERVER

bool function IsPlayerDisembarking( entity player )
{
	return player.p.isDisembarking
}

bool function PlayerCanEmbarkIntoTitan( entity player, entity titan ) //TODO: Collapse PlayerCanEmbarkTitan(), PlayerCanEmbarkIntoTitan(), PlayerCanImmediatelyEmbarkTitan() and TitanIsCurrentlyEmbarkableForPlayer() into one function
{
	if ( player.IsNoclipping() )
		return false

	if ( !TitanIsCurrentlyEmbarkableForPlayer( player, titan ) )
		return false

	return FindBestEmbark( player, titan ) != null
}

void function SetCustomTitanIsEmbarkableForPlayerFunc( bool functionref( entity, entity ) func )
{
	file.customTitanIsEmbarkableForPlayer = func
}

bool function TitanIsCurrentlyEmbarkableForPlayer( entity player, entity titan ) //TODO: Collapse PlayerCanEmbarkTitan(), PlayerCanEmbarkIntoTitan(), PlayerCanImmediatelyEmbarkTitan() and TitanIsCurrentlyEmbarkableForPlayer() into one function
{
	if ( !CanEmbark( player ) )
		return false

	if ( player.Anim_IsActive() )
		return false

	if ( !player.IsHuman() )
		return false

	if ( player.ContextAction_IsActive() )
		return false

	if ( !titan.IsEntAlive() )
		return false

	if ( titan.ContextAction_IsActive() )
		return false

	if ( titan.IsPlayer() )
		return false

	if ( !titan.IsInterruptable() )
		return false

	if ( IsValid( titan.GetParent() ) )
		return false

	if ( !HasSoul( titan ) )
		return false

	if ( GetDoomedState( titan ) && !PROTO_AlternateDoomedState() )
		return false

	entity soul = titan.GetTitanSoul()
	if ( soul.IsEjecting() )
		return false

	#if SERVER
		// client doesn't know these things
		if ( IsPlayerEmbarking( player ) )
			return false

		if ( IsPlayerDisembarking( player ) )
			return false
	#endif

	if ( "disembarkTime" in titan.s )
	{
		if ( Time() - titan.s.disembarkTime < 1.65 )
			return false
	}

	if ( Bleedout_IsBleedingOut( player ) )
		return false

	#if SERVER
		if ( file.customTitanIsEmbarkableForPlayer != null )
			return file.customTitanIsEmbarkableForPlayer( player, titan )
	#endif

	return true
}

function FindEmbarkActionForCriteria( table criteria )
{
	local embarkAction
	foreach ( option in level.titanEmbarkActions )
	{
		bool failed = false
		foreach ( key, value in criteria )
		{
			if ( value != option[key] )
			{
				failed = true
				break
			}
		}

		if ( !failed )
		{
			embarkAction = expect table( option )
			break
		}
	}

	return embarkAction
}

table function GetRandomEmbarkAction()
{
	return expect table( level.titanEmbarkActions[ RandomInt( level.titanEmbarkActions.len() ) ] )
}

function FindBestEmbark( entity player, entity titan, bool doDistCheck = true )
{
	//if ( IsServer() )
	//	printt( "finding best embark for " + player + " to " + titan )
	vector playerPos = player.GetOrigin()
	vector titanPos = titan.GetOrigin()

	vector relTitanToPlayerDir = CalculateTitanToPlayerDir( titan, player )

	local bestAction = null
	float bestDot = -2
	float dist = 0

	if ( doDistCheck )
	{
		dist = Distance( playerPos, titanPos )
		if ( dist > level.titanEmbarkFarthestDistance )
			return null
	}
	//if ( IsServer() )
	//	printt( "dist: " + dist )

	for ( int i = 0; i < 3; i++ )
	{
		bestAction = GetBestEmbarkAction( i, player, titan, dist, relTitanToPlayerDir )
		if ( bestAction != null )
			break
	}

	if ( bestAction == null )
		return null

	return GenerateEmbarkActionTable( player, titan, expect table( bestAction ), relTitanToPlayerDir )
}

vector function CalculateTitanToPlayerDir( entity titan, entity player )
{
	vector playerPos = player.GetOrigin()
	vector titanPos = titan.GetOrigin()

	vector absTitanToPlayerDir
	if ( playerPos == titanPos )
	{
		absTitanToPlayerDir = <1,0,0>
	}
	else
	{
		vector angles = player.EyeAngles()
		vector forward = AnglesToForward( angles )

		absTitanToPlayerDir = ( playerPos - titanPos )


		absTitanToPlayerDir.Norm()

//		not needed cause we can't get in without a legal use
//		// is the target in my fov?
//		if ( forward.Dot( absTitanToPlayerDir * -1 ) < 0.77 )
//			return null
	}

	vector titanAngles = titan.GetAngles()
	titanAngles.x = 0
	if ( titan.GetTitanSoul().GetStance() >= STANCE_STANDING )
		titanAngles = AnglesCompose( titanAngles, <0,-30,0> )

	vector relTitanToPlayerDir = CalcRelativeVector( titanAngles, absTitanToPlayerDir )
	return relTitanToPlayerDir
}

table function GenerateEmbarkActionTable( entity player, entity titan, table bestAction, var relTitanToPlayerDir = null )
{
	bool useFastAnims = player.IsPlayer() && PlayerHasFastEmbark( player )

	if ( relTitanToPlayerDir == null )
 		relTitanToPlayerDir = CalculateTitanToPlayerDir( titan, player )

	expect vector( relTitanToPlayerDir )

	table Table
	Table.action <- bestAction

	if ( "animSet" in bestAction )
	{
		Table.animSet <- bestAction.animSet
		Table.audioSet <- bestAction.audioSet
	}
	else
	{
		local bestAnimSet
		local bestAudioSet
		float bestDot = -2
		Assert( "animSets" in bestAction, "Table has no animSet and no animSets!" )
		foreach ( animSet in bestAction.animSets )
		{
			float dot = relTitanToPlayerDir.Dot( animSet.direction )

			if ( dot > bestDot )
			{
				bestAnimSet = animSet
				bestAudioSet = animSet.audioSet
				bestDot = dot
			}
		}

		Table.animSet <- bestAnimSet
		Table.audioSet <- bestAudioSet
	}

	if ( useFastAnims )
	{
		Table.animSet = clone Table.animSet

		foreach ( string idx, item in Table.animSet )
		{
			if ( IsString( item ) )
				Table.animSet[ idx ] = item + "_fast"
		}
	}

	return Table
}

function GetBestEmbarkAction( int priority, entity player, entity titan, float dist, vector relTitanToPlayerDir )
{
	local bestAction = null
	float bestDot = -2

	foreach ( action in level.titanEmbarkActions )
	{
		if ( action.priority != priority )
			continue

		if ( dist > action.distance )
		{
			//if ( IsServer() )
				//printt( "Failed: Action " + action.embark + " had dist " + action.distance + " vs actual dist " + dist )
			continue
		}

		if ( action.lungeCheck )
		{
			if ( player.IsNPC() )
				continue

			if ( player.Lunge_IsActive() != action.lungeCheck )
				continue
		}

		float dot = relTitanToPlayerDir.Dot( action.direction )

		if ( dot < action.minDot )
		{
			//if ( IsServer() )
				//printt( "Failed: Action " + action.embark + " had dot " + dot )
			continue
		}

		if ( expect bool( action.titanCanStandRequired ) && !TitanCanStand( titan ) )
		{
			//if ( IsServer() )
				//printt( "Failed: Action " + action.embark + " cant stand" )
			continue
		}

		if ( dot > bestDot )
		{
			//if ( IsServer() )
				//printt( "Action " + action.embark + " had dot " + dot )
			bestAction = action
			bestDot = dot
		}
	}

	return bestAction
}

function FindBestEmbarkForNpcAnim( entity npc, entity titan )
{
	bool doDistCheck = false
	return FindBestEmbark( npc, titan, doDistCheck )
}

bool function TitanCanStand( entity titan )
{
	#if SERVER
		vector maxs = titan.GetBoundingMaxs()
		vector mins = titan.GetBoundingMins()

		vector start = titan.GetOrigin()
		vector end = titan.GetOrigin()
		entity ignoreEnt = null

		int mask = titan.GetPhysicsSolidMask()
		//printt( "mask has " + MaskTester( mask ) )
		TraceResults result = TraceHull( start, end, mins, maxs, ignoreEnt, mask, TRACE_COLLISION_GROUP_NONE )
		//printt( "start " + start + " end " + end )

		//DebugDrawLine( start, result.endPos, 0, 255, 0, true, 5.0 )
		//DebugDrawLine( result.endPos, end, 255, 0, 0, true, 5.0 )

		bool canStand = result.fraction >= 1.0
		titan.SetCanStand( canStand )
		return canStand
	#else
		return titan.GetCanStand() != 0
	#endif
}

bool function PlayerCanEmbarkTitan( entity player, entity titan ) //TODO: Collapse PlayerCanEmbarkTitan(), PlayerCanEmbarkIntoTitan(), PlayerCanImmediatelyEmbarkTitan() and TitanIsCurrentlyEmbarkableForPlayer() into one function
{
	PerfStart( PerfIndexClient.PlayerCanEmbarkTitan1 )
	if ( !TitanIsCurrentlyEmbarkableForPlayer( player, titan ) )
	{
		PerfEnd( PerfIndexClient.PlayerCanEmbarkTitan1 )
		return false
	}
	PerfEnd( PerfIndexClient.PlayerCanEmbarkTitan1 )

	PerfStart( PerfIndexClient.FindBestEmbark )
	bool res = FindBestEmbark( player, titan ) != null
	PerfEnd( PerfIndexClient.FindBestEmbark )

	return res
}

bool function PlayerCanImmediatelyEmbarkTitan( entity player, entity titan ) //TODO: Collapse PlayerCanEmbarkTitan(), PlayerCanEmbarkIntoTitan(), PlayerCanImmediatelyEmbarkTitan() and TitanIsCurrentlyEmbarkableForPlayer() into one function
{
	if ( "embarkingPlayer" in titan.s )
		return false

	if ( player.IsNoclipping() )
		return false

	if ( !IsAlive( player ) || !IsAlive( titan ) )
		return false

	return FindBestEmbark( player, titan ) != null
}

#if SERVER
void function PlayerLungesToEmbark( entity player, entity ent )
{
	Assert( TitanIsCurrentlyEmbarkableForPlayer( player, ent ) )

	if ( PlayerCanImmediatelyEmbarkTitan( player, ent ) )
	{
		table embarkDirection = expect table( FindBestEmbark( player, ent ) )
		thread PlayerEmbarksTitan( player, ent, embarkDirection )
		return
	}

	if ( player.IsNoclipping() )
		return

	// already lunging
	if ( player.Lunge_IsActive() )
		return

	if ( ShouldStopLunging( player, ent ) )
		return

	player.Lunge_SetTargetEntity( ent )
	player.Lunge_SetSmoothTime( 3.0 )
}

bool function ShouldStopLunging( entity player, entity target )
{
	if ( !IsAlive( player )  )
		return true

	if ( !IsAlive( target ) )
		return true

	if ( !target.IsTitan() )
		return true

	// ejecting?
	return target.GetTitanSoul().IsEjecting()
}

void function SetSmallDisembarkFailSafeTeleportVector( vector value ) //TODO: Re-examine this for next game, probably should have different values for SP versus MP
{
	file.smallDisembarkFailSafeTeleportVector = value
}

void function SetLargeDisembarkFailSafeTeleportVector( vector value ) //TODO: Re-examine this for next game, probably should have different values for SP versus MP
{
	file.largeDisembarkFailSafeTeleportVector = value
}
#endif // SERVER

#if DEVELOPER
void function SetEmbarkDebugPrint( bool value )
{
	file.embarkDebugPrint = value
}
#endif // DEVELOPER

bool function PlayerHasFastEmbark( entity player )
{
	return false
}